<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>PowerSimulations · PowerSimulations</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>PowerSimulations</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">API</span><ul><li class="current"><a class="toctext" href>PowerSimulations</a><ul class="internal"><li><a class="toctext" href="#Index-1">Index</a></li><li><a class="toctext" href="#Exported-1">Exported</a></li><li><a class="toctext" href="#Internal-1">Internal</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>API</li><li><a href>PowerSimulations</a></li></ul><a class="edit-page" href="https://github.com/NREL/PowerSimulations.jl/blob/master/docs/src/api/PowerSimulations.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>PowerSimulations</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="PowerSimulations-1" href="#PowerSimulations-1">PowerSimulations</a></h1><p>API documentation</p><ul><li><a href="#PowerSimulations-1">PowerSimulations</a></li><ul><li><a href="#Index-1">Index</a></li><li><a href="#Exported-1">Exported</a></li><li><a href="#Internal-1">Internal</a></li></ul></ul><h2><a class="nav-anchor" id="Index-1" href="#Index-1">Index</a></h2><ul><li><a href="#PowerSimulations.TimeStatusChange"><code>PowerSimulations.TimeStatusChange</code></a></li><li><a href="#PowerSimulations.UpdateRef"><code>PowerSimulations.UpdateRef</code></a></li><li><a href="#Base.show-Tuple{IO,MIME{Symbol(&quot;text/plain&quot;)},OperationModel}"><code>Base.show</code></a></li><li><a href="#PowerSimulations._container_spec-Union{Tuple{M}, Tuple{M,Vararg{Any,N} where N}} where M&lt;:JuMP.AbstractModel"><code>PowerSimulations._container_spec</code></a></li><li><a href="#PowerSimulations._get_data_for_rocc-Tuple{Array{InitialCondition,1},Dates.Period}"><code>PowerSimulations._get_data_for_rocc</code></a></li><li><a href="#PowerSimulations._get_data_for_tdc-Tuple{Array{InitialCondition,1},Array{InitialCondition,1},Dates.Period}"><code>PowerSimulations._get_data_for_tdc</code></a></li><li><a href="#PowerSimulations._internal_device_constructor!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.CanonicalModel,DeviceModel{T,ThermalBasicUnitCommitment},Type{S},PowerSystems.System}} where S&lt;:PowerModels.AbstractPowerFormulation where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations._internal_device_constructor!</code></a></li><li><a href="#PowerSimulations._internal_device_constructor!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.CanonicalModel,DeviceModel{T,ThermalRampLimited},Type{S},PowerSystems.System}} where S&lt;:PowerModels.AbstractActivePowerFormulation where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations._internal_device_constructor!</code></a></li><li><a href="#PowerSimulations._internal_device_constructor!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.CanonicalModel,DeviceModel{T,D},Type{S},PowerSystems.System}} where S&lt;:PowerModels.AbstractPowerFormulation where D&lt;:PowerSimulations.AbstractThermalFormulation where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations._internal_device_constructor!</code></a></li><li><a href="#PowerSimulations._internal_device_constructor!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.CanonicalModel,DeviceModel{T,ThermalRampLimited},Type{S},PowerSystems.System}} where S&lt;:PowerModels.AbstractPowerFormulation where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations._internal_device_constructor!</code></a></li><li><a href="#PowerSimulations._internal_device_constructor!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.CanonicalModel,DeviceModel{T,D},Type{S},PowerSystems.System}} where S&lt;:PowerModels.AbstractActivePowerFormulation where D&lt;:PowerSimulations.AbstractThermalFormulation where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations._internal_device_constructor!</code></a></li><li><a href="#PowerSimulations._internal_device_constructor!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.CanonicalModel,DeviceModel{T,ThermalBasicUnitCommitment},Type{S},PowerSystems.System}} where S&lt;:PowerModels.AbstractActivePowerFormulation where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations._internal_device_constructor!</code></a></li><li><a href="#PowerSimulations._pwl_cost-Union{Tuple{JV}, Tuple{PowerSimulations.CanonicalModel,JV,Array{Tuple{Float64,Float64},1}}} where JV&lt;:JuMP.AbstractVariableRef"><code>PowerSimulations._pwl_cost</code></a></li><li><a href="#PowerSimulations._pwlgencost_linear-Union{Tuple{JV}, Tuple{PowerSimulations.CanonicalModel,JV,Array{Tuple{Float64,Float64},1}}} where JV&lt;:JuMP.AbstractVariableRef"><code>PowerSimulations._pwlgencost_linear</code></a></li><li><a href="#PowerSimulations._pwlgencost_sos-Union{Tuple{JV}, Tuple{PowerSimulations.CanonicalModel,JV,Array{Tuple{Float64,Float64},1}}} where JV&lt;:JuMP.AbstractVariableRef"><code>PowerSimulations._pwlgencost_sos</code></a></li><li><a href="#PowerSimulations._pwlparamcheck-Tuple{Any}"><code>PowerSimulations._pwlparamcheck</code></a></li><li><a href="#PowerSimulations._retrieve_forecasts-Union{Tuple{C}, Tuple{PowerSystems.System,Type{C}}} where C&lt;:PowerSystems.Component"><code>PowerSimulations._retrieve_forecasts</code></a></li><li><a href="#PowerSimulations.activepower_constraints-Union{Tuple{S}, Tuple{L}, Tuple{PowerSimulations.CanonicalModel,InfrastructureSystems.FlattenIteratorWrapper{L},Type{InterruptiblePowerLoad},Type{S}}} where S&lt;:PowerModels.AbstractPowerFormulation where L&lt;:PowerSystems.ElectricLoad"><code>PowerSimulations.activepower_constraints</code></a></li><li><a href="#PowerSimulations.activepower_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.CanonicalModel,InfrastructureSystems.FlattenIteratorWrapper{T},Type{D},Type{S}}} where S&lt;:PowerModels.AbstractPowerFormulation where D&lt;:PowerSimulations.AbstractThermalDispatchForm where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.activepower_constraints!</code></a></li><li><a href="#PowerSimulations.activepower_constraints!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.CanonicalModel,InfrastructureSystems.FlattenIteratorWrapper{T},Type{ThermalDispatchNoMin},Type{S}}} where S&lt;:PowerModels.AbstractPowerFormulation where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.activepower_constraints!</code></a></li><li><a href="#PowerSimulations.activepower_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.CanonicalModel,InfrastructureSystems.FlattenIteratorWrapper{T},Type{D},Type{S}}} where S&lt;:PowerModels.AbstractPowerFormulation where D&lt;:PowerSimulations.AbstractThermalFormulation where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.activepower_constraints!</code></a></li><li><a href="#PowerSimulations.activepower_variables!-Union{Tuple{T}, Tuple{PowerSimulations.CanonicalModel,InfrastructureSystems.FlattenIteratorWrapper{T}}} where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.activepower_variables!</code></a></li><li><a href="#PowerSimulations.add_to_cost-Union{Tuple{D}, Tuple{PowerSimulations.CanonicalModel,D,Symbol,Symbol}, Tuple{PowerSimulations.CanonicalModel,D,Symbol,Symbol,Float64}} where D&lt;:(InfrastructureSystems.FlattenIteratorWrapper{#s61} where #s61&lt;:PowerSystems.Device)"><code>PowerSimulations.add_to_cost</code></a></li><li><a href="#PowerSimulations.add_variable-Union{Tuple{D}, Tuple{PowerSimulations.CanonicalModel,D,Symbol,Bool}, Tuple{PowerSimulations.CanonicalModel,D,Symbol,Bool,Union{Nothing, Symbol}}, Tuple{PowerSimulations.CanonicalModel,D,Symbol,Bool,Union{Nothing, Symbol},Float64}} where D&lt;:Union{Array{#s223,1} where #s223&lt;:PowerSystems.Device, InfrastructureSystems.FlattenIteratorWrapper{#s224} where #s224&lt;:PowerSystems.Device}"><code>PowerSimulations.add_variable</code></a></li><li><a href="#PowerSimulations.build_nip_expr_model-Tuple{Dict{String,Any},Any}"><code>PowerSimulations.build_nip_expr_model</code></a></li><li><a href="#PowerSimulations.build_nip_model-Tuple{Dict{String,Any},Any}"><code>PowerSimulations.build_nip_model</code></a></li><li><a href="#PowerSimulations.commitment_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.CanonicalModel,InfrastructureSystems.FlattenIteratorWrapper{T},Type{D},Type{S}}} where S&lt;:PowerModels.AbstractPowerFormulation where D&lt;:PowerSimulations.AbstractThermalFormulation where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.commitment_constraints!</code></a></li><li><a href="#PowerSimulations.commitment_variables!-Union{Tuple{T}, Tuple{PowerSimulations.CanonicalModel,InfrastructureSystems.FlattenIteratorWrapper{T}}} where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.commitment_variables!</code></a></li><li><a href="#PowerSimulations.constraint_power_balance_ni-Tuple{PowerModels.GenericPowerModel,Int64,Int64,Int64,Any,Any}"><code>PowerSimulations.constraint_power_balance_ni</code></a></li><li><a href="#PowerSimulations.constraint_power_balance_ni-Union{Tuple{T}, Tuple{PowerModels.GenericPowerModel{T},Int64,Int64,Int64,Any,Any}} where T&lt;:PowerModels.AbstractDCPForm"><code>PowerSimulations.constraint_power_balance_ni</code></a></li><li><a href="#PowerSimulations.constraint_power_balance_ni-Tuple{PowerModels.GenericPowerModel,Int64}"><code>PowerSimulations.constraint_power_balance_ni</code></a></li><li><a href="#PowerSimulations.constraint_power_balance_ni_expr-Tuple{PowerModels.GenericPowerModel,Int64,Int64,Int64,Any,Any,Any,Any}"><code>PowerSimulations.constraint_power_balance_ni_expr</code></a></li><li><a href="#PowerSimulations.constraint_power_balance_ni_expr-Union{Tuple{T}, Tuple{PowerModels.GenericPowerModel{T},Int64,Int64,Int64,Any,Any,Any,Any}} where T&lt;:PowerModels.AbstractDCPForm"><code>PowerSimulations.constraint_power_balance_ni_expr</code></a></li><li><a href="#PowerSimulations.constraint_power_balance_ni_expr-Tuple{PowerModels.GenericPowerModel,Int64}"><code>PowerSimulations.constraint_power_balance_ni_expr</code></a></li><li><a href="#PowerSimulations.device_commitment-Tuple{PowerSimulations.CanonicalModel,Array{InitialCondition,1},Symbol,Tuple{Symbol,Symbol,Symbol}}"><code>PowerSimulations.device_commitment</code></a></li><li><a href="#PowerSimulations.device_duration_look_ahead-Tuple{PowerSimulations.CanonicalModel,Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{InitialCondition,2},Symbol,Tuple{Symbol,Symbol,Symbol}}"><code>PowerSimulations.device_duration_look_ahead</code></a></li><li><a href="#PowerSimulations.device_duration_param-Tuple{PowerSimulations.CanonicalModel,Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{InitialCondition,2},Symbol,Tuple{Symbol,Symbol,Symbol}}"><code>PowerSimulations.device_duration_param</code></a></li><li><a href="#PowerSimulations.device_duration_retrospective-Tuple{PowerSimulations.CanonicalModel,Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{InitialCondition,2},Symbol,Tuple{Symbol,Symbol,Symbol}}"><code>PowerSimulations.device_duration_retrospective</code></a></li><li><a href="#PowerSimulations.device_linear_rateofchange-Tuple{PowerSimulations.CanonicalModel,Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{InitialCondition,1},Symbol,Symbol}"><code>PowerSimulations.device_linear_rateofchange</code></a></li><li><a href="#PowerSimulations.device_mixedinteger_rateofchange-Tuple{PowerSimulations.CanonicalModel,Tuple{Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{NamedTuple{(:min, :max),Tuple{Float64,Float64}},1}},Array{InitialCondition,1},Symbol,Tuple{Symbol,Symbol,Symbol}}"><code>PowerSimulations.device_mixedinteger_rateofchange</code></a></li><li><a href="#PowerSimulations.device_range-Tuple{PowerSimulations.CanonicalModel,Array{Tuple{String,NamedTuple{(:min, :max),Tuple{Float64,Float64}}},1},Symbol,Symbol}"><code>PowerSimulations.device_range</code></a></li><li><a href="#PowerSimulations.device_semicontinuousrange-Tuple{PowerSimulations.CanonicalModel,Array{Tuple{String,NamedTuple{(:min, :max),Tuple{Float64,Float64}}},1},Symbol,Symbol,Symbol}"><code>PowerSimulations.device_semicontinuousrange</code></a></li><li><a href="#PowerSimulations.device_timeseries_lb-Tuple{PowerSimulations.CanonicalModel,Tuple{Array{String,1},Array{Float64,1},Array{Array{Float64,1},1}},Symbol,Symbol}"><code>PowerSimulations.device_timeseries_lb</code></a></li><li><a href="#PowerSimulations.device_timeseries_param_lb-Tuple{PowerSimulations.CanonicalModel,Tuple{Array{String,1},Array{Float64,1},Array{Array{Float64,1},1}},Symbol,PowerSimulations.UpdateRef,Symbol}"><code>PowerSimulations.device_timeseries_param_lb</code></a></li><li><a href="#PowerSimulations.device_timeseries_param_ub-Tuple{PowerSimulations.CanonicalModel,Tuple{Array{String,1},Array{Float64,1},Array{Array{Float64,1},1}},Symbol,PowerSimulations.UpdateRef,Symbol}"><code>PowerSimulations.device_timeseries_param_ub</code></a></li><li><a href="#PowerSimulations.device_timeseries_ub-Tuple{PowerSimulations.CanonicalModel,Tuple{Array{String,1},Array{Float64,1},Array{Array{Float64,1},1}},Symbol,Symbol}"><code>PowerSimulations.device_timeseries_ub</code></a></li><li><a href="#PowerSimulations.device_timeseries_ub_bigM"><code>PowerSimulations.device_timeseries_ub_bigM</code></a></li><li><a href="#PowerSimulations.device_timeseries_ub_bin-Tuple{PowerSimulations.CanonicalModel,Tuple{Array{String,1},Array{Float64,1},Array{Array{Float64,1},1}},Symbol,Symbol,Symbol}"><code>PowerSimulations.device_timeseries_ub_bin</code></a></li><li><a href="#PowerSimulations.energy_balance-Tuple{PowerSimulations.CanonicalModel,Array{InitialCondition,1},Tuple{Array{String,1},Array{NamedTuple{(:in, :out),Tuple{Float64,Float64}},1}},Symbol,Tuple{Symbol,Symbol,Symbol}}"><code>PowerSimulations.energy_balance</code></a></li><li><a href="#PowerSimulations.get_all_constraint_index-Tuple{OperationModel}"><code>PowerSimulations.get_all_constraint_index</code></a></li><li><a href="#PowerSimulations.get_all_var_index-Tuple{OperationModel}"><code>PowerSimulations.get_all_var_index</code></a></li><li><a href="#PowerSimulations.parameter_update!-Tuple{PowerSimulations.UpdateRef{JuMP.VariableRef},JuMP.Containers.DenseAxisArray{ParameterJuMP.ParameterRef,N,Ax,L} where L&lt;:Tuple{Vararg{Dict,N}} where Ax where N,Int64,Simulation}"><code>PowerSimulations.parameter_update!</code></a></li><li><a href="#PowerSimulations.post_nip-Tuple{PowerModels.GenericPowerModel}"><code>PowerSimulations.post_nip</code></a></li><li><a href="#PowerSimulations.post_nip_expr-Tuple{PowerModels.GenericPowerModel}"><code>PowerSimulations.post_nip_expr</code></a></li><li><a href="#PowerSimulations.powermodels_network!-Union{Tuple{S}, Tuple{PowerSimulations.CanonicalModel,Type{S},PowerSystems.System}} where S&lt;:PowerModels.AbstractActivePowerFormulation"><code>PowerSimulations.powermodels_network!</code></a></li><li><a href="#PowerSimulations.powermodels_network!-Union{Tuple{S}, Tuple{PowerSimulations.CanonicalModel,Type{S},PowerSystems.System}} where S&lt;:PowerModels.AbstractPowerFormulation"><code>PowerSimulations.powermodels_network!</code></a></li><li><a href="#PowerSimulations.ps_cost-Union{Tuple{JV}, Tuple{PowerSimulations.CanonicalModel,JuMP.Containers.DenseAxisArray{JV,N,Ax,L} where L&lt;:Tuple{Vararg{Dict,N}} where Ax where N,Float64,Float64,Float64}} where JV&lt;:JuMP.AbstractVariableRef"><code>PowerSimulations.ps_cost</code></a></li><li><a href="#PowerSimulations.ps_cost-Union{Tuple{JV}, Tuple{PowerSimulations.CanonicalModel,JuMP.Containers.DenseAxisArray{JV,N,Ax,L} where L&lt;:Tuple{Vararg{Dict,N}} where Ax where N,PowerSystems.VariableCost{Tuple{Float64,Float64}},Float64,Float64}} where JV&lt;:JuMP.AbstractVariableRef"><code>PowerSimulations.ps_cost</code></a></li><li><a href="#PowerSimulations.ps_cost-Union{Tuple{JV}, Tuple{PowerSimulations.CanonicalModel,JuMP.Containers.DenseAxisArray{JV,N,Ax,L} where L&lt;:Tuple{Vararg{Dict,N}} where Ax where N,PowerSystems.VariableCost{Float64},Float64,Float64}} where JV&lt;:JuMP.AbstractVariableRef"><code>PowerSimulations.ps_cost</code></a></li><li><a href="#PowerSimulations.ps_cost-Union{Tuple{JV}, Tuple{PowerSimulations.CanonicalModel,JuMP.Containers.DenseAxisArray{JV,N,Ax,L} where L&lt;:Tuple{Vararg{Dict,N}} where Ax where N,PowerSystems.VariableCost{Array{Tuple{Float64,Float64},1}},Float64,Float64}} where JV&lt;:JuMP.AbstractVariableRef"><code>PowerSimulations.ps_cost</code></a></li><li><a href="#PowerSimulations.ramp_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.CanonicalModel,InfrastructureSystems.FlattenIteratorWrapper{T},Type{D},Type{S}}} where S&lt;:PowerModels.AbstractPowerFormulation where D&lt;:PowerSimulations.AbstractThermalFormulation where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.ramp_constraints!</code></a></li><li><a href="#PowerSimulations.range_ff-Tuple{PowerSimulations.CanonicalModel,Symbol,Tuple{PowerSimulations.UpdateRef,PowerSimulations.UpdateRef},Symbol}"><code>PowerSimulations.range_ff</code></a></li><li><a href="#PowerSimulations.rating_constraint-Tuple{PowerSimulations.CanonicalModel,Array{Tuple{String,Float64},1},Symbol,Tuple{Symbol,Symbol}}"><code>PowerSimulations.rating_constraint</code></a></li><li><a href="#PowerSimulations.reactive_power_constraints-Union{Tuple{S}, Tuple{D}, Tuple{St}, Tuple{PowerSimulations.CanonicalModel,InfrastructureSystems.FlattenIteratorWrapper{St},Type{D},Type{S}}} where S&lt;:PowerModels.AbstractPowerFormulation where D&lt;:PowerSimulations.AbstractStorageForm where St&lt;:PowerSystems.Storage"><code>PowerSimulations.reactive_power_constraints</code></a></li><li><a href="#PowerSimulations.reactivepower_constraints-Union{Tuple{S}, Tuple{D}, Tuple{L}, Tuple{PowerSimulations.CanonicalModel,InfrastructureSystems.FlattenIteratorWrapper{L},Type{D},Type{S}}} where S&lt;:PowerModels.AbstractPowerFormulation where D&lt;:PowerSimulations.AbstractControllablePowerLoadForm where L&lt;:PowerSystems.ElectricLoad"><code>PowerSimulations.reactivepower_constraints</code></a></li><li><a href="#PowerSimulations.reactivepower_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.CanonicalModel,InfrastructureSystems.FlattenIteratorWrapper{T},Type{D},Type{S}}} where S&lt;:PowerModels.AbstractPowerFormulation where D&lt;:PowerSimulations.AbstractThermalDispatchForm where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.reactivepower_constraints!</code></a></li><li><a href="#PowerSimulations.reactivepower_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.CanonicalModel,InfrastructureSystems.FlattenIteratorWrapper{T},Type{D},Type{S}}} where S&lt;:PowerModels.AbstractPowerFormulation where D&lt;:PowerSimulations.AbstractThermalFormulation where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.reactivepower_constraints!</code></a></li><li><a href="#PowerSimulations.reactivepower_variables!-Union{Tuple{T}, Tuple{PowerSimulations.CanonicalModel,InfrastructureSystems.FlattenIteratorWrapper{T}}} where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.reactivepower_variables!</code></a></li><li><a href="#PowerSimulations.remove_chars-Tuple{String,String}"><code>PowerSimulations.remove_chars</code></a></li><li><a href="#PowerSimulations.replace_chars-Tuple{String,String,String}"><code>PowerSimulations.replace_chars</code></a></li><li><a href="#PowerSimulations.reserve_device_semicontinuousrange-Tuple{PowerSimulations.CanonicalModel,Array{Tuple{String,NamedTuple{(:min, :max),Tuple{Float64,Float64}}},1},Symbol,Symbol,Symbol}"><code>PowerSimulations.reserve_device_semicontinuousrange</code></a></li><li><a href="#PowerSimulations.run_sim_model!-Tuple{Simulation}"><code>PowerSimulations.run_sim_model!</code></a></li><li><a href="#PowerSimulations.semicontinuousrange_ff-Tuple{PowerSimulations.CanonicalModel,Symbol,PowerSimulations.UpdateRef,Symbol}"><code>PowerSimulations.semicontinuousrange_ff</code></a></li><li><a href="#PowerSimulations.set_variable_bounds-Tuple{PowerSimulations.CanonicalModel,Array{Tuple{String,NamedTuple{(:min, :max),Tuple{Float64,Float64}}},1},Symbol}"><code>PowerSimulations.set_variable_bounds</code></a></li><li><a href="#PowerSimulations.sort_data-Tuple{PowerSimulations.OperationModelResults}"><code>PowerSimulations.sort_data</code></a></li><li><a href="#PowerSimulations.status_init-Union{Tuple{PSD}, Tuple{PowerSimulations.CanonicalModel,InfrastructureSystems.FlattenIteratorWrapper{PSD}}} where PSD&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.status_init</code></a></li><li><a href="#PowerSimulations.ub_ff-Tuple{PowerSimulations.CanonicalModel,Symbol,PowerSimulations.UpdateRef,Symbol}"><code>PowerSimulations.ub_ff</code></a></li><li><a href="#PowerSimulations.variable_active_net_injection-Tuple{PowerModels.GenericPowerModel}"><code>PowerSimulations.variable_active_net_injection</code></a></li><li><a href="#PowerSimulations.variable_net_injection-Tuple{PowerModels.GenericPowerModel}"><code>PowerSimulations.variable_net_injection</code></a></li><li><a href="#PowerSimulations.variable_reactive_net_injection-Tuple{PowerModels.GenericPowerModel}"><code>PowerSimulations.variable_reactive_net_injection</code></a></li><li><a href="#PowerSimulations.variable_reactive_net_injection-Union{Tuple{PowerModels.GenericPowerModel{T}}, Tuple{T}} where T&lt;:PowerModels.AbstractDCPForm"><code>PowerSimulations.variable_reactive_net_injection</code></a></li><li><a href="#PowerSimulations.write_model_results-Tuple{PowerSimulations.OperationModelResults,String}"><code>PowerSimulations.write_model_results</code></a></li><li><a href="#PowerSimulations.write_op_model-Tuple{OperationModel,String}"><code>PowerSimulations.write_op_model</code></a></li></ul><h2><a class="nav-anchor" id="Exported-1" href="#Exported-1">Exported</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.TimeStatusChange" href="#PowerSimulations.TimeStatusChange"><code>PowerSimulations.TimeStatusChange</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Tracks the last time status of a device changed in a simulation</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.get_all_constraint_index-Tuple{OperationModel}" href="#PowerSimulations.get_all_constraint_index-Tuple{OperationModel}"><code>PowerSimulations.get_all_constraint_index</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>&quot;Each Tuple corresponds to (con<em>name, internal</em>index, moi_index)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.get_all_var_index-Tuple{OperationModel}" href="#PowerSimulations.get_all_var_index-Tuple{OperationModel}"><code>PowerSimulations.get_all_var_index</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>&quot;Each Tuple corresponds to (con<em>name, internal</em>index, moi_index)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.run_sim_model!-Tuple{Simulation}" href="#PowerSimulations.run_sim_model!-Tuple{Simulation}"><code>PowerSimulations.run_sim_model!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Runs Simulations</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.sort_data-Tuple{PowerSimulations.OperationModelResults}" href="#PowerSimulations.sort_data-Tuple{PowerSimulations.OperationModelResults}"><code>PowerSimulations.sort_data</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">sort_data(results::OperationModelResults)</code></pre><p>This function takes in struct OperationModelResults, sorts the generators in each variable, and outputs the sorted results. The generic function sorts the generators alphabetically.</p><p>kwargs: &#39;Variables&#39; to choose which variables to be sorted.</p><p>each variable has a kwarg, so that a specific order can be generated, such that when plotted, the first generator is on the bottom. if a list of generator names has fewer generators than the variable, only the generators on the list will be outputted.</p><p>#Examples</p><p>example 1: sorted<em>results = sort</em>data(res)</p><blockquote><p>sorted<em>results.variables[P</em>RenewableDispatch] will be in the order</p></blockquote><pre><code class="language-none">[:WindBusA :WindBusB :WindBusC] (alphabetical)</code></pre><p>example 2: my<em>order = [:WindBusC :WindBusB :WindBusA] sorted</em>results = sort<em>data(res; P</em>RenewableDispatch = my_order)</p><blockquote><p>sorted<em>results.variables[P</em>RenewableDispatch] will be in the order</p></blockquote><pre><code class="language-none">[:WindBusC :WindBusB :WindBusA] (my_order)</code></pre><p>example 3: my<em>order = [:WindBusC :WindBusA] sorted</em>results = sort<em>data(res; P</em>RenewableDispatch = my_order)</p><blockquote><p>sorted<em>results.variables[P</em>RenewableDispatch] will be in the order</p></blockquote><pre><code class="language-none">[:WindBusC :WindBusA] (my_order)</code></pre><p>example 4: my<em>variable</em>order = [:P<em>ThermalStandard :ON</em>ThermalStandard] sorted<em>results = sort</em>data(res; Variables = my<em>variable</em>order)</p><blockquote><p>sorted_results.variables</p></blockquote><pre><code class="language-none">Dict{Symbol,DataFrames.DataFrame} with 2 entries:
:P_ThermalStandard =&gt; 24×5 DataFrames.DataFrame…
:ON_ThermalStandard =&gt; 24×5 DataFrames.DataFrame…</code></pre><ul><li>note that only the generators included in &#39;my_order&#39; will be in the</li></ul><p>results, and consequently, only these will be plotted. This can be a nice feature for variables with more than 5 generators.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.write_model_results-Tuple{PowerSimulations.OperationModelResults,String}" href="#PowerSimulations.write_model_results-Tuple{PowerSimulations.OperationModelResults,String}"><code>PowerSimulations.write_model_results</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Exports Operational Model Results to a path</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.write_op_model-Tuple{OperationModel,String}" href="#PowerSimulations.write_op_model-Tuple{OperationModel,String}"><code>PowerSimulations.write_op_model</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Exports the OpModel JuMP object in MathOptFormat</p></div></div></section><h2><a class="nav-anchor" id="Internal-1" href="#Internal-1">Internal</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.UpdateRef" href="#PowerSimulations.UpdateRef"><code>PowerSimulations.UpdateRef</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Reference for parameters update when present</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.show-Tuple{IO,MIME{Symbol(&quot;text/plain&quot;)},OperationModel}" href="#Base.show-Tuple{IO,MIME{Symbol(&quot;text/plain&quot;)},OperationModel}"><code>Base.show</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Base.show(io::IO, ::MIME&quot;text/plain&quot;, op_model::OperationModel)</code></pre><p>This function goes through the fields in OperationModel and then in ModelReference, if the field contains a Device model dictionary, it calls organize<em>device</em>model() &amp; prints the data by field, key, value. If the field is not a Device model dictionary, and a value exists for that field it prints the value.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations._container_spec-Union{Tuple{M}, Tuple{M,Vararg{Any,N} where N}} where M&lt;:JuMP.AbstractModel" href="#PowerSimulations._container_spec-Union{Tuple{M}, Tuple{M,Vararg{Any,N} where N}} where M&lt;:JuMP.AbstractModel"><code>PowerSimulations._container_spec</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Returns the correct container spec for the selected type of JuMP Model</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations._get_data_for_rocc-Tuple{Array{InitialCondition,1},Dates.Period}" href="#PowerSimulations._get_data_for_rocc-Tuple{Array{InitialCondition,1},Dates.Period}"><code>PowerSimulations._get_data_for_rocc</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>This function gets the data for the generators</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations._get_data_for_tdc-Tuple{Array{InitialCondition,1},Array{InitialCondition,1},Dates.Period}" href="#PowerSimulations._get_data_for_tdc-Tuple{Array{InitialCondition,1},Array{InitialCondition,1},Dates.Period}"><code>PowerSimulations._get_data_for_tdc</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>If the fraction of hours that a generator has a duration constraint is less than the fraction of hours that a single time_step represents then it is not binding.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations._internal_device_constructor!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.CanonicalModel,DeviceModel{T,D},Type{S},PowerSystems.System}} where S&lt;:PowerModels.AbstractActivePowerFormulation where D&lt;:PowerSimulations.AbstractThermalFormulation where T&lt;:PowerSystems.ThermalGen" href="#PowerSimulations._internal_device_constructor!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.CanonicalModel,DeviceModel{T,D},Type{S},PowerSystems.System}} where S&lt;:PowerModels.AbstractActivePowerFormulation where D&lt;:PowerSimulations.AbstractThermalFormulation where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations._internal_device_constructor!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>This function creates the model for a full themal dispatch formulation depending on combination of devices, device<em>formulation and system</em>formulation</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations._internal_device_constructor!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.CanonicalModel,DeviceModel{T,D},Type{S},PowerSystems.System}} where S&lt;:PowerModels.AbstractPowerFormulation where D&lt;:PowerSimulations.AbstractThermalFormulation where T&lt;:PowerSystems.ThermalGen" href="#PowerSimulations._internal_device_constructor!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.CanonicalModel,DeviceModel{T,D},Type{S},PowerSystems.System}} where S&lt;:PowerModels.AbstractPowerFormulation where D&lt;:PowerSimulations.AbstractThermalFormulation where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations._internal_device_constructor!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>This function creates the model for a full themal dispatch formulation depending on combination of devices, device<em>formulation and system</em>formulation</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations._internal_device_constructor!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.CanonicalModel,DeviceModel{T,ThermalBasicUnitCommitment},Type{S},PowerSystems.System}} where S&lt;:PowerModels.AbstractActivePowerFormulation where T&lt;:PowerSystems.ThermalGen" href="#PowerSimulations._internal_device_constructor!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.CanonicalModel,DeviceModel{T,ThermalBasicUnitCommitment},Type{S},PowerSystems.System}} where S&lt;:PowerModels.AbstractActivePowerFormulation where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations._internal_device_constructor!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>This function creates the model for a full themal dispatch formulation depending on combination of devices, device<em>formulation and system</em>formulation</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations._internal_device_constructor!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.CanonicalModel,DeviceModel{T,ThermalBasicUnitCommitment},Type{S},PowerSystems.System}} where S&lt;:PowerModels.AbstractPowerFormulation where T&lt;:PowerSystems.ThermalGen" href="#PowerSimulations._internal_device_constructor!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.CanonicalModel,DeviceModel{T,ThermalBasicUnitCommitment},Type{S},PowerSystems.System}} where S&lt;:PowerModels.AbstractPowerFormulation where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations._internal_device_constructor!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>This function creates the model for a full themal dispatch formulation depending on combination of devices, device<em>formulation and system</em>formulation</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations._internal_device_constructor!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.CanonicalModel,DeviceModel{T,ThermalRampLimited},Type{S},PowerSystems.System}} where S&lt;:PowerModels.AbstractActivePowerFormulation where T&lt;:PowerSystems.ThermalGen" href="#PowerSimulations._internal_device_constructor!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.CanonicalModel,DeviceModel{T,ThermalRampLimited},Type{S},PowerSystems.System}} where S&lt;:PowerModels.AbstractActivePowerFormulation where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations._internal_device_constructor!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>This function creates the model for a full themal dispatch formulation depending on combination of devices, device<em>formulation and system</em>formulation</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations._internal_device_constructor!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.CanonicalModel,DeviceModel{T,ThermalRampLimited},Type{S},PowerSystems.System}} where S&lt;:PowerModels.AbstractPowerFormulation where T&lt;:PowerSystems.ThermalGen" href="#PowerSimulations._internal_device_constructor!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.CanonicalModel,DeviceModel{T,ThermalRampLimited},Type{S},PowerSystems.System}} where S&lt;:PowerModels.AbstractPowerFormulation where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations._internal_device_constructor!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>This function creates the model for a full themal dispatch formulation depending on combination of devices, device<em>formulation and system</em>formulation</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations._pwl_cost-Union{Tuple{JV}, Tuple{PowerSimulations.CanonicalModel,JV,Array{Tuple{Float64,Float64},1}}} where JV&lt;:JuMP.AbstractVariableRef" href="#PowerSimulations._pwl_cost-Union{Tuple{JV}, Tuple{PowerSimulations.CanonicalModel,JV,Array{Tuple{Float64,Float64},1}}} where JV&lt;:JuMP.AbstractVariableRef"><code>PowerSimulations._pwl_cost</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">_gen_cost(cost_)</code></pre><p>Returns JuMP expression for a piecewise linear cost function depending on the data compatibility.</p><p>Returns <code>gen_cost</code></p><p><strong>Arguments</strong></p><ul><li>canonical_model::CanonicalModel : the canonical model built in PowerSimulations</li><li>variable::JuMP.Containers.DenseAxisArray{JV} : variable array</li><li>cost_component::PSY.VariableCost{NTuple{2, Float64}} : container for quadratic and linear factors</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations._pwlgencost_linear-Union{Tuple{JV}, Tuple{PowerSimulations.CanonicalModel,JV,Array{Tuple{Float64,Float64},1}}} where JV&lt;:JuMP.AbstractVariableRef" href="#PowerSimulations._pwlgencost_linear-Union{Tuple{JV}, Tuple{PowerSimulations.CanonicalModel,JV,Array{Tuple{Float64,Float64},1}}} where JV&lt;:JuMP.AbstractVariableRef"><code>PowerSimulations._pwlgencost_linear</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">_pwlgencost_sos(canonical_model::CanonicalModel,
            variable::JuMP.Containers.DenseAxisArray{JV},
            cost_component::PSY.VariableCost{NTuple{2, Float64}}) where {JV &lt;: JuMP.AbstractVariableRef}</code></pre><p>Returns piecewise cost expression using linear implementation for canonical model.</p><p><strong>Equations</strong></p><p><code>0 &lt;= pwl_var[i] &lt;= (cost_component[2][i] - cost_component[2][i-1])</code></p><p><code>variable = sum(pwl_var[i])</code></p><p><code>gen_cost = sum(pwl_var[i]*cost_component[1][i]/cost_component[2][i])</code></p><p><strong>LaTeX</strong></p><p><span>$0 &lt;= pwl_i &lt;= (c_{2, i} - c_{2, i-1})$</span></p><p><span>$variable = (sum_{i\in I} pwl_i)$</span></p><p><span>$gen_cost = (sum_{i\in I}  pwl_i) c_{1, i}/c_{2, i}$</span></p><p>Returns <code>gen_cost</code></p><p><strong>Arguments</strong></p><ul><li>canonical_model::CanonicalModel : the canonical model built in PowerSimulations</li><li>variable::JuMP.Containers.DenseAxisArray{JV} : variable array</li><li>cost_component::PSY.VariableCost{NTuple{2, Float64}} : container for quadratic and linear factors</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations._pwlgencost_sos-Union{Tuple{JV}, Tuple{PowerSimulations.CanonicalModel,JV,Array{Tuple{Float64,Float64},1}}} where JV&lt;:JuMP.AbstractVariableRef" href="#PowerSimulations._pwlgencost_sos-Union{Tuple{JV}, Tuple{PowerSimulations.CanonicalModel,JV,Array{Tuple{Float64,Float64},1}}} where JV&lt;:JuMP.AbstractVariableRef"><code>PowerSimulations._pwlgencost_sos</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">_pwlgencost_sos(canonical_model::CanonicalModel,
            variable::JuMP.Containers.DenseAxisArray{JV},
            cost_component::PSY.VariableCost{NTuple{2, Float64}}) where {JV &lt;: JuMP.AbstractVariableRef}</code></pre><p>Returns piecewise cost expression using SOS Type-2 implementation for canonical model.</p><p><strong>Equations</strong></p><p><code>variable = sum(sos_var[i]*cost_component[2][i])</code></p><p><code>gen_cost = sum(sos_var[i]*cost_component[1][i])</code></p><p><strong>LaTeX</strong></p><p><span>$variable = (sum_{i\in I} c_{2, i} sos_i)$</span></p><p><span>$gen_cost = (sum_{i\in I} c_{1, i} sos_i)$</span></p><p>Returns <code>gen_cost</code></p><p><strong>Arguments</strong></p><ul><li>canonical_model::CanonicalModel : the canonical model built in PowerSimulations</li><li>variable::JuMP.Containers.DenseAxisArray{JV} : variable array</li><li>cost_component::PSY.VariableCost{NTuple{2, Float64}} : container for quadratic and linear factors</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations._pwlparamcheck-Tuple{Any}" href="#PowerSimulations._pwlparamcheck-Tuple{Any}"><code>PowerSimulations._pwlparamcheck</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">_pwlparamcheck(cost_)</code></pre><p>Returns True/False depending on compatibility of the cost data with the linear implementation method</p><p>Returns <code>flag</code></p><p><strong>Arguments</strong></p><ul><li>cost_::PSY.VariableCost{NTuple{2, Float64}} : container for quadratic and linear factors</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations._retrieve_forecasts-Union{Tuple{C}, Tuple{PowerSystems.System,Type{C}}} where C&lt;:PowerSystems.Component" href="#PowerSimulations._retrieve_forecasts-Union{Tuple{C}, Tuple{PowerSystems.System,Type{C}}} where C&lt;:PowerSystems.Component"><code>PowerSimulations._retrieve_forecasts</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Only used when building the model</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.activepower_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.CanonicalModel,InfrastructureSystems.FlattenIteratorWrapper{T},Type{D},Type{S}}} where S&lt;:PowerModels.AbstractPowerFormulation where D&lt;:PowerSimulations.AbstractThermalDispatchForm where T&lt;:PowerSystems.ThermalGen" href="#PowerSimulations.activepower_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.CanonicalModel,InfrastructureSystems.FlattenIteratorWrapper{T},Type{D},Type{S}}} where S&lt;:PowerModels.AbstractPowerFormulation where D&lt;:PowerSimulations.AbstractThermalDispatchForm where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.activepower_constraints!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>This function adds the active power limits of generators when there are no CommitmentVariables</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.activepower_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.CanonicalModel,InfrastructureSystems.FlattenIteratorWrapper{T},Type{D},Type{S}}} where S&lt;:PowerModels.AbstractPowerFormulation where D&lt;:PowerSimulations.AbstractThermalFormulation where T&lt;:PowerSystems.ThermalGen" href="#PowerSimulations.activepower_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.CanonicalModel,InfrastructureSystems.FlattenIteratorWrapper{T},Type{D},Type{S}}} where S&lt;:PowerModels.AbstractPowerFormulation where D&lt;:PowerSimulations.AbstractThermalFormulation where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.activepower_constraints!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>This function adds the active power limits of generators when there are CommitmentVariables</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.activepower_constraints!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.CanonicalModel,InfrastructureSystems.FlattenIteratorWrapper{T},Type{ThermalDispatchNoMin},Type{S}}} where S&lt;:PowerModels.AbstractPowerFormulation where T&lt;:PowerSystems.ThermalGen" href="#PowerSimulations.activepower_constraints!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.CanonicalModel,InfrastructureSystems.FlattenIteratorWrapper{T},Type{ThermalDispatchNoMin},Type{S}}} where S&lt;:PowerModels.AbstractPowerFormulation where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.activepower_constraints!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>This function adds the active power limits of generators when there are     no CommitmentVariables</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.activepower_constraints-Union{Tuple{S}, Tuple{L}, Tuple{PowerSimulations.CanonicalModel,InfrastructureSystems.FlattenIteratorWrapper{L},Type{InterruptiblePowerLoad},Type{S}}} where S&lt;:PowerModels.AbstractPowerFormulation where L&lt;:PowerSystems.ElectricLoad" href="#PowerSimulations.activepower_constraints-Union{Tuple{S}, Tuple{L}, Tuple{PowerSimulations.CanonicalModel,InfrastructureSystems.FlattenIteratorWrapper{L},Type{InterruptiblePowerLoad},Type{S}}} where S&lt;:PowerModels.AbstractPowerFormulation where L&lt;:PowerSystems.ElectricLoad"><code>PowerSimulations.activepower_constraints</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>This function works only if the the Param<em>L &lt;= PSY.get</em>maxactivepower(g)</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.activepower_variables!-Union{Tuple{T}, Tuple{PowerSimulations.CanonicalModel,InfrastructureSystems.FlattenIteratorWrapper{T}}} where T&lt;:PowerSystems.ThermalGen" href="#PowerSimulations.activepower_variables!-Union{Tuple{T}, Tuple{PowerSimulations.CanonicalModel,InfrastructureSystems.FlattenIteratorWrapper{T}}} where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.activepower_variables!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>This function add the variables for power generation output to the model</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.add_to_cost-Union{Tuple{D}, Tuple{PowerSimulations.CanonicalModel,D,Symbol,Symbol}, Tuple{PowerSimulations.CanonicalModel,D,Symbol,Symbol,Float64}} where D&lt;:(InfrastructureSystems.FlattenIteratorWrapper{#s61} where #s61&lt;:PowerSystems.Device)" href="#PowerSimulations.add_to_cost-Union{Tuple{D}, Tuple{PowerSimulations.CanonicalModel,D,Symbol,Symbol}, Tuple{PowerSimulations.CanonicalModel,D,Symbol,Symbol,Float64}} where D&lt;:(InfrastructureSystems.FlattenIteratorWrapper{#s61} where #s61&lt;:PowerSystems.Device)"><code>PowerSimulations.add_to_cost</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">add_to_cost(canonical_model::CanonicalModel,
                 devices::D,
                 var_name::Symbol,
                 cost_symbol::Symbol,
                 sign::Float64 = 1.0) where {D&lt;:IS.FlattenIteratorWrapper{&lt;:PSY.Device}}</code></pre><p>Adds cost expression for each device using appropriate call to <code>ps_cost</code>.</p><p><strong>Expression</strong></p><p>for d in devices</p><pre><code class="language-cost_expression">                              variable[PSY.get_name(d), :],
                              getfield(PSY.get_op_cost(d), cost_symbol),
                              dt,
                              sign) ```</code></pre><p>canonical<em>model.cost</em>function += cost_expression ```</p><p><strong>LaTeX</strong></p><p><span>$COST = \sum_{d\in D} cost_d$</span></p><p><strong>Arguments</strong></p><ul><li>canonical_model::CanonicalModel : the canonical model built in PowerSimulations</li><li>devices::D : set of devices</li><li>var_name::Symbol : name of variable</li><li>cost_symbol::Symbol : symbol associated with costx</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.add_variable-Union{Tuple{D}, Tuple{PowerSimulations.CanonicalModel,D,Symbol,Bool}, Tuple{PowerSimulations.CanonicalModel,D,Symbol,Bool,Union{Nothing, Symbol}}, Tuple{PowerSimulations.CanonicalModel,D,Symbol,Bool,Union{Nothing, Symbol},Float64}} where D&lt;:Union{Array{#s223,1} where #s223&lt;:PowerSystems.Device, InfrastructureSystems.FlattenIteratorWrapper{#s224} where #s224&lt;:PowerSystems.Device}" href="#PowerSimulations.add_variable-Union{Tuple{D}, Tuple{PowerSimulations.CanonicalModel,D,Symbol,Bool}, Tuple{PowerSimulations.CanonicalModel,D,Symbol,Bool,Union{Nothing, Symbol}}, Tuple{PowerSimulations.CanonicalModel,D,Symbol,Bool,Union{Nothing, Symbol},Float64}} where D&lt;:Union{Array{#s223,1} where #s223&lt;:PowerSystems.Device, InfrastructureSystems.FlattenIteratorWrapper{#s224} where #s224&lt;:PowerSystems.Device}"><code>PowerSimulations.add_variable</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">add_variable(canonical_model::CanonicalModel,
                  devices::D,
                  var_name::Symbol,
                  binary::Bool,
                  expression::Symbol,
                  sign::Float64)</code></pre><p>Adds a variable to the optimization model and to the affine expressions contained in the canonical model according to the specified sign. Based on the inputs, the variable can be specified as binary.</p><p><strong>Bounds</strong></p><p><code>lb_value_function &lt;= varstart[name, t] &lt;= ub_value_function</code></p><p>If binary = true:</p><p><code>varstart[name, t] in {0,1}</code></p><p><strong>LaTeX</strong></p><p><span>$lb \ge x^{device}_t \le ub \forall t$</span></p><p><span>$x^{device}_t \in {0,1} \forall t iff \text{binary = true}$</span></p><p><strong>Arguments</strong></p><ul><li>canonical_model::CanonicalModel : the canonical model built in PowerSimulations</li><li>devices : Vector or Iterator with the devices</li><li>var_name::Symbol : Base Name for the variable</li><li>binary::Bool : Select if the variable is binary</li><li>expression::Symbol : Expression name stored in canonical_model.expressions to add the variable</li><li>sign::Float64 : sign of the addition of the variable to the expression. Default Value is 1.0</li></ul><p><strong>Accepted Keyword Arguments</strong></p><ul><li>ub<em>value</em>function : Provides the function over device to obtain the value for a upper_bound</li><li>lb<em>value</em>function : Provides the function over device to obtain the value for a lower_bound. If the variable is meant to be positive define lb = x -&gt; 0.0</li><li>initial<em>value</em>function : Provides the function over device to obtain the warm start value</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.build_nip_expr_model-Tuple{Dict{String,Any},Any}" href="#PowerSimulations.build_nip_expr_model-Tuple{Dict{String,Any},Any}"><code>PowerSimulations.build_nip_expr_model</code></a> — <span class="docstring-category">Method</span>.</div><div><div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.build_nip_model-Tuple{Dict{String,Any},Any}" href="#PowerSimulations.build_nip_model-Tuple{Dict{String,Any},Any}"><code>PowerSimulations.build_nip_model</code></a> — <span class="docstring-category">Method</span>.</div><div><div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.commitment_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.CanonicalModel,InfrastructureSystems.FlattenIteratorWrapper{T},Type{D},Type{S}}} where S&lt;:PowerModels.AbstractPowerFormulation where D&lt;:PowerSimulations.AbstractThermalFormulation where T&lt;:PowerSystems.ThermalGen" href="#PowerSimulations.commitment_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.CanonicalModel,InfrastructureSystems.FlattenIteratorWrapper{T},Type{D},Type{S}}} where S&lt;:PowerModels.AbstractPowerFormulation where D&lt;:PowerSimulations.AbstractThermalFormulation where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.commitment_constraints!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>This function adds the Commitment Status constraint when there are CommitmentVariables</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.commitment_variables!-Union{Tuple{T}, Tuple{PowerSimulations.CanonicalModel,InfrastructureSystems.FlattenIteratorWrapper{T}}} where T&lt;:PowerSystems.ThermalGen" href="#PowerSimulations.commitment_variables!-Union{Tuple{T}, Tuple{PowerSimulations.CanonicalModel,InfrastructureSystems.FlattenIteratorWrapper{T}}} where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.commitment_variables!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>This function add the variables for power generation commitment to the model</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.constraint_power_balance_ni-Tuple{PowerModels.GenericPowerModel,Int64,Int64,Int64,Any,Any}" href="#PowerSimulations.constraint_power_balance_ni-Tuple{PowerModels.GenericPowerModel,Int64,Int64,Int64,Any,Any}"><code>PowerSimulations.constraint_power_balance_ni</code></a> — <span class="docstring-category">Method</span>.</div><div><div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.constraint_power_balance_ni-Tuple{PowerModels.GenericPowerModel,Int64}" href="#PowerSimulations.constraint_power_balance_ni-Tuple{PowerModels.GenericPowerModel,Int64}"><code>PowerSimulations.constraint_power_balance_ni</code></a> — <span class="docstring-category">Method</span>.</div><div><div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.constraint_power_balance_ni-Union{Tuple{T}, Tuple{PowerModels.GenericPowerModel{T},Int64,Int64,Int64,Any,Any}} where T&lt;:PowerModels.AbstractDCPForm" href="#PowerSimulations.constraint_power_balance_ni-Union{Tuple{T}, Tuple{PowerModels.GenericPowerModel{T},Int64,Int64,Int64,Any,Any}} where T&lt;:PowerModels.AbstractDCPForm"><code>PowerSimulations.constraint_power_balance_ni</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>active power only models ignore reactive power flows</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.constraint_power_balance_ni_expr-Tuple{PowerModels.GenericPowerModel,Int64,Int64,Int64,Any,Any,Any,Any}" href="#PowerSimulations.constraint_power_balance_ni_expr-Tuple{PowerModels.GenericPowerModel,Int64,Int64,Int64,Any,Any,Any,Any}"><code>PowerSimulations.constraint_power_balance_ni_expr</code></a> — <span class="docstring-category">Method</span>.</div><div><div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.constraint_power_balance_ni_expr-Tuple{PowerModels.GenericPowerModel,Int64}" href="#PowerSimulations.constraint_power_balance_ni_expr-Tuple{PowerModels.GenericPowerModel,Int64}"><code>PowerSimulations.constraint_power_balance_ni_expr</code></a> — <span class="docstring-category">Method</span>.</div><div><div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.constraint_power_balance_ni_expr-Union{Tuple{T}, Tuple{PowerModels.GenericPowerModel{T},Int64,Int64,Int64,Any,Any,Any,Any}} where T&lt;:PowerModels.AbstractDCPForm" href="#PowerSimulations.constraint_power_balance_ni_expr-Union{Tuple{T}, Tuple{PowerModels.GenericPowerModel{T},Int64,Int64,Int64,Any,Any,Any,Any}} where T&lt;:PowerModels.AbstractDCPForm"><code>PowerSimulations.constraint_power_balance_ni_expr</code></a> — <span class="docstring-category">Method</span>.</div><div><div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.device_commitment-Tuple{PowerSimulations.CanonicalModel,Array{InitialCondition,1},Symbol,Tuple{Symbol,Symbol,Symbol}}" href="#PowerSimulations.device_commitment-Tuple{PowerSimulations.CanonicalModel,Array{InitialCondition,1},Symbol,Tuple{Symbol,Symbol,Symbol}}"><code>PowerSimulations.device_commitment</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">device_commitment(canonical_model::CanonicalModel,
                    initial_conditions::Vector{InitialCondition},
                    cons_name::Symbol,
                    var_names::Tuple{Symbol, Symbol, Symbol})</code></pre><p>Constructs multi-timestep constraint from initial conditions and binary variable tuple.</p><p><strong>Constraints</strong></p><p><code>varstart + varstop &lt;= 1.0</code></p><p>If t = 1:</p><p><code>varon[name, 1] == ic.value + varstart[name, 1] - varstop[name, 1]</code></p><p>where ic in initial_condtions.</p><p>If t &gt; 1:</p><p><code>varon[name, t] == varon[name, t-1] + varstart[name, t] - varstop[name, t]</code></p><p><strong>LaTeX</strong></p><p><span>$x^{on}_t + x^{off}_t \leq 1.0 \forall t$</span></p><p><span>$x^{on}_1 = x^{on}_{init} + x^{start}_1 - x^{stop}_1, \text{ for } t = 1$</span></p><p><span>$x^{on}_t = x^{on}_{t-1} + x^{start}_t - x^{stop}_t, \forall t \geq 2$</span></p><p><strong>Arguments</strong></p><ul><li>canonical_model::CanonicalModel : the canonical model built in PowerSimulations</li><li>initial_conditions::Vector{InitialCondition} : for time zero &#39;varon&#39;</li><li>cons_name::Symbol : name of the constraint</li><li>var_names::Tuple{Symbol, Symbol, Symbol} : the names of the variables</li><li>: var_names[1] : varstart</li><li>: var_names[2] : varstop</li><li>: var_names[3] : varon</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.device_duration_look_ahead-Tuple{PowerSimulations.CanonicalModel,Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{InitialCondition,2},Symbol,Tuple{Symbol,Symbol,Symbol}}" href="#PowerSimulations.device_duration_look_ahead-Tuple{PowerSimulations.CanonicalModel,Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{InitialCondition,2},Symbol,Tuple{Symbol,Symbol,Symbol}}"><code>PowerSimulations.device_duration_look_ahead</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">device_duration_look_ahead(canonical_model::CanonicalModel,
                            duration_data::Vector{UpDown},
                            initial_duration::Matrix{InitialCondition},
                            cons_name::Symbol,
                            var_names::Tuple{Symbol, Symbol, Symbol})</code></pre><p>This formulation of the duration constraints looks ahead in the time frame of the model.</p><p><strong>LaTeX</strong></p><ul><li>Minimum up-time constraint:</li></ul><p>If <span>$t \leq d_{min}^{up}$</span></p><p><span>$d_{min}^{down}x_t^{stop} - \sum_{i=t-d_{min}^{up} + 1}^t x_i^{on} - x_{init}^{up} \leq 0$</span></p><p>for i in the set of time steps. Otherwise:</p><p><span>$d_{min}^{down}x_t^{stop} - \sum_{i=t-d_{min}^{up} + 1}^t x_i^{on} \leq 0$</span></p><p>for i in the set of time steps.</p><ul><li>Minimum down-time constraint:</li></ul><p>If <span>$t \leq d_{min}^{down}$</span></p><p><span>$d_{min}^{up}x_t^{start} - \sum_{i=t-d_{min^{down} + 1}^t (1 - x_i^{on}) - x_{init}^{down} \leq 0$</span></p><p>for i in the set of time steps. Otherwise:</p><p><span>$d_{min}^{up}x_t^{start} - \sum_{i=t-d_{min^{down} + 1}^t (1 - x_i^{on}) \leq 0$</span></p><p>for i in the set of time steps.</p><p><strong>Arguments</strong></p><ul><li>canonical_model::CanonicalModel : the canonical model built in PowerSimulations</li><li>duration_data::Vector{UpDown} : gives how many time steps variable needs to be up or down</li><li>initial_duration::Matrix{InitialCondition} : gives initial conditions for up (column 1) and down (column 2)</li><li>cons_name::Symbol : name of the constraint</li><li>var_names::Tuple{Symbol, Symbol, Symbol}) : names of the variables</li><li>: var_names[1] : varon</li><li>: var_names[2] : varstart</li><li>: var_names[3] : varstop</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.device_duration_param-Tuple{PowerSimulations.CanonicalModel,Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{InitialCondition,2},Symbol,Tuple{Symbol,Symbol,Symbol}}" href="#PowerSimulations.device_duration_param-Tuple{PowerSimulations.CanonicalModel,Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{InitialCondition,2},Symbol,Tuple{Symbol,Symbol,Symbol}}"><code>PowerSimulations.device_duration_param</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">device_duration_param(canonical_model::CanonicalModel,
                         duration_data::Vector{UpDown},
                         initial_duration_on::Vector{InitialCondition},
                         initial_duration_off::Vector{InitialCondition},
                         cons_name::Symbol,
                         var_names::Tuple{Symbol, Symbol, Symbol})</code></pre><p>This formulation of the duration constraints considers parameters.</p><p><strong>LaTeX</strong></p><ul><li>Minimum up-time constraint:</li></ul><p>If <span>$t \leq d_{min}^{up}$</span></p><p><span>$d_{min}^{down}x_t^{stop} - \sum_{i=t-d_{min}^{up} + 1}^t x_i^{on} - x_{init}^{up} \leq 0$</span></p><p>for i in the set of time steps. Otherwise:</p><p><span>$\sum_{i=t-d_{min}^{up} + 1}^t x_i^{start} - x_t^{on} \leq 0$</span></p><p>for i in the set of time steps.</p><ul><li>Minimum down-time constraint:</li></ul><p>If <span>$t \leq d_{min}^{down}$</span></p><p><span>$d_{min}^{up}x_t^{start} - \sum_{i=t-d_{min^{down} + 1}^t (1 - x_i^{on}) - x_{init}^{down} \leq 0$</span></p><p>for i in the set of time steps. Otherwise:</p><p><span>$\sum_{i=t-d_{min}^{down} + 1}^t x_i^{stop} + x_t^{on} \leq 1$</span></p><p>for i in the set of time steps.</p><p><strong>Arguments</strong></p><ul><li>canonical_model::CanonicalModel : the canonical model built in PowerSimulations</li><li>duration_data::Vector{UpDown} : gives how many time steps variable needs to be up or down</li><li>initial<em>duration</em>on::Vector{InitialCondition} : gives initial number of time steps variable is up</li><li>initial<em>duration</em>off::Vector{InitialCondition} : gives initial number of time steps variable is down</li><li>cons_name::Symbol : name of the constraint</li><li>var_names::Tuple{Symbol, Symbol, Symbol}) : names of the variables</li><li>: var_names[1] : varon</li><li>: var_names[2] : varstart</li><li>: var_names[3] : varstop</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.device_duration_retrospective-Tuple{PowerSimulations.CanonicalModel,Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{InitialCondition,2},Symbol,Tuple{Symbol,Symbol,Symbol}}" href="#PowerSimulations.device_duration_retrospective-Tuple{PowerSimulations.CanonicalModel,Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{InitialCondition,2},Symbol,Tuple{Symbol,Symbol,Symbol}}"><code>PowerSimulations.device_duration_retrospective</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">device_duration_retrospective(canonical_model::CanonicalModel,
                                    duration_data::Vector{UpDown},
                                    initial_duration::Matrix{InitialCondition},
                                    cons_name::Symbol,
                                    var_names::Tuple{Symbol, Symbol, Symbol})</code></pre><p>This formulation of the duration constraints adds over the start times looking backwards.</p><p><strong>LaTeX</strong></p><ul><li>Minimum up-time constraint:</li></ul><p>If <span>$t \leq d_{min}^{up} - d_{init}^{up}$</span> and <span>$d_{init}^{up} &gt; 0$</span></p><p><span>$1 + \sum_{i=t-d_{min}^{up} + 1}^t x_i^{start} - x_t^{on} \leq 0$</span></p><p>for i in the set of time steps. Otherwise:</p><p><span>$\sum_{i=t-d_{min}^{up} + 1}^t x_i^{start} - x_t^{on} \leq 0$</span></p><p>for i in the set of time steps.</p><ul><li>Minimum down-time constraint:</li></ul><p>If <span>$t \leq d_{min}^{down} - d_{init}^{down}$</span> and <span>$d_{init}^{down} &gt; 0$</span></p><p><span>$1 + \sum_{i=t-d_{min}^{down} + 1}^t x_i^{stop} + x_t^{on} \leq 1$</span></p><p>for i in the set of time steps. Otherwise:</p><p><span>$\sum_{i=t-d_{min}^{down} + 1}^t x_i^{stop} + x_t^{on} \leq 1$</span></p><p>for i in the set of time steps.</p><p><strong>Arguments</strong></p><ul><li>canonical_model::CanonicalModel : the canonical model built in PowerSimulations</li><li>duration_data::Vector{UpDown} : gives how many time steps variable needs to be up or down</li><li>initial_duration::Matrix{InitialCondition} : gives initial conditions for up (column 1) and down (column 2)</li><li>cons_name::Symbol : name of the constraint</li><li>var_names::Tuple{Symbol, Symbol, Symbol}) : names of the variables</li><li>: var_names[1] : varon</li><li>: var_names[2] : varstart</li><li>: var_names[3] : varstop</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.device_linear_rateofchange-Tuple{PowerSimulations.CanonicalModel,Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{InitialCondition,1},Symbol,Symbol}" href="#PowerSimulations.device_linear_rateofchange-Tuple{PowerSimulations.CanonicalModel,Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{InitialCondition,1},Symbol,Symbol}"><code>PowerSimulations.device_linear_rateofchange</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">device_linear_rateofchange(canonical_model::CanonicalModel,
                                rate_data::Tuple{Vector{String}, Vector{UpDown}},
                                initial_conditions::Vector{InitialCondition},
                                cons_name::Symbol,
                                var_name::Symbol)</code></pre><p>Constructs allowed rate-of-change constraints from variables, initial condtions, and rate data.</p><p><strong>Constraints</strong></p><p>If t = 1:</p><p><code>variable[name, 1] - initial_conditions[ix].value &lt;= rate_data[1][ix].up</code></p><p><code>initial_conditions[ix].value - variable[name, 1] &lt;= rate_data[1][ix].down</code></p><p>If t &gt; 1:</p><p><code>variable[name, t] - variable[name, t-1] &lt;= rate_data[1][ix].up</code></p><p><code>variable[name, t-1] - variable[name, t] &lt;= rate_data[1][ix].down</code></p><p><strong>LaTeX</strong></p><p><span>$r^{down} \leq x_1 - x_{init} \leq r^{up}, \text{ for } t = 1$</span></p><p><span>$r^{down} \leq x_t - x_{t-1} \leq r^{up}, \forall t \geq 2$</span></p><p><strong>Arguments</strong></p><ul><li>canonical_model::CanonicalModel : the canonical model built in PowerSimulations</li><li>rate_data::Tuple{Vector{String}, Vector{UpDown}} : gives name (1) and max ramp up/down rates (2)</li><li>initial_conditions::Vector{InitialCondition} : for time zero &#39;variable&#39;</li><li>cons_name::Symbol : name of the constraint</li><li>var_name::Tuple{Symbol, Symbol, Symbol} : the name of the variable</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.device_mixedinteger_rateofchange-Tuple{PowerSimulations.CanonicalModel,Tuple{Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{NamedTuple{(:min, :max),Tuple{Float64,Float64}},1}},Array{InitialCondition,1},Symbol,Tuple{Symbol,Symbol,Symbol}}" href="#PowerSimulations.device_mixedinteger_rateofchange-Tuple{PowerSimulations.CanonicalModel,Tuple{Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{NamedTuple{(:min, :max),Tuple{Float64,Float64}},1}},Array{InitialCondition,1},Symbol,Tuple{Symbol,Symbol,Symbol}}"><code>PowerSimulations.device_mixedinteger_rateofchange</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">device_mixedinteger_rateofchange(canonical_model::CanonicalModel,
                                      rate_data::Tuple{Vector{String}, Vector{UpDown}, Vector{MinMax}},
                                      initial_conditions::Vector{InitialCondition},
                                      cons_name::Symbol,
                                      var_names::Tuple{Symbol, Symbol, Symbol})</code></pre><p>Constructs allowed rate-of-change constraints from variables, initial condtions, start/stop status, and rate data</p><p><strong>Equations</strong></p><p>If t = 1:</p><p><code>variable[name, 1] - initial_conditions[ix].value &lt;= rate_data[1][ix].up + rate_data[2][ix].max*varstart[name, 1]</code></p><p><code>initial_conditions[ix].value - variable[name, 1] &lt;= rate_data[1][ix].down + rate_data[2][ix].min*varstop[name, 1]</code></p><p>If t &gt; 1:</p><p><code>variable[name, t] - variable[name, t-1] &lt;= rate_data[1][ix].up + rate_data[2][ix].max*varstart[name, t]</code></p><p><code>variable[name, t-1] - variable[name, t] &lt;= rate_data[1][ix].down + rate_data[2][ix].min*varstop[name, t]</code></p><p><strong>LaTeX</strong></p><p><span>$r^{down} + r^{min} x^{stop}_1 \leq x_1 - x_{init} \leq r^{up} + r^{max} x^{start}_1, \text{ for } t = 1$</span></p><p><span>$r^{down} + r^{min} x^{stop}_t \leq x_t - x_{t-1} \leq r^{up} + r^{max} x^{start}_t, \forall t \geq 2$</span></p><p><strong>Arguments</strong></p><ul><li>canonical_model::CanonicalModel : the canonical model built in PowerSimulations</li><li>rate_data::Tuple{Vector{String}, Vector{UpDown}, Vector{MinMax}} : (1) gives name                                                                    (2) gives min/max ramp rates                                                                    (3) gives min/max for &#39;variable&#39;</li><li>initial_conditions::Vector{InitialCondition} : for time zero &#39;variable&#39;</li><li>cons_name::Symbol : name of the constraint</li><li>var_names::Tuple{Symbol, Symbol, Symbol} : the names of the variables</li><li>: var_names[1] : &#39;variable&#39;</li><li>: var_names[2] : &#39;varstart&#39;</li><li>: var_names[3] : &#39;varstop&#39;</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.device_range-Tuple{PowerSimulations.CanonicalModel,Array{Tuple{String,NamedTuple{(:min, :max),Tuple{Float64,Float64}}},1},Symbol,Symbol}" href="#PowerSimulations.device_range-Tuple{PowerSimulations.CanonicalModel,Array{Tuple{String,NamedTuple{(:min, :max),Tuple{Float64,Float64}}},1},Symbol,Symbol}"><code>PowerSimulations.device_range</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">device_range(canonical_model::CanonicalModel,
                    range_data::Vector{NamedMinMax},
                    cons_name::Symbol,
                    var_name::Symbol)</code></pre><p>Constructs min/max range constraint from device variable.</p><p><strong>Constraints</strong></p><p>If min and max within an epsilon width:</p><p><code>variable[r[1], t] == r[2].max</code></p><p>Otherwise:</p><p><code>r[2].min &lt;= variable[r[1], t] &lt;= r[2].max</code></p><p>where r in range_data.</p><p><strong>LaTeX</strong></p><p><span>$x = r^{max}, \text{ for } |r^{max} - r^{min}| &lt; \varepsilon$</span></p><p><span>$r^{min} \leq x \leq r^{max}, \text{ otherwise }$</span></p><p><strong>Arguments</strong></p><ul><li>canonical_model::CanonicalModel : the canonical model built in PowerSimulations</li><li>range_data::Vector{NamedMinMax} : contains name of device (1) and its min/max (2)</li><li>cons_name::Symbol : name of the constraint</li><li>var_name::Symbol : the name of the continuous variable</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.device_semicontinuousrange-Tuple{PowerSimulations.CanonicalModel,Array{Tuple{String,NamedTuple{(:min, :max),Tuple{Float64,Float64}}},1},Symbol,Symbol,Symbol}" href="#PowerSimulations.device_semicontinuousrange-Tuple{PowerSimulations.CanonicalModel,Array{Tuple{String,NamedTuple{(:min, :max),Tuple{Float64,Float64}}},1},Symbol,Symbol,Symbol}"><code>PowerSimulations.device_semicontinuousrange</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">device_semicontinuousrange(canonical_model::CanonicalModel,
                                scrange_data::Vector{NamedMinMax},
                                cons_name::Symbol,
                                var_name::Symbol,
                                binvar_name::Symbol)</code></pre><p>Constructs min/max range constraint from device variable and on/off decision variable.</p><p><strong>Constraints</strong></p><p>If device min = 0:</p><p><code>varcts[r[1], t] &lt;= r[2].max*varbin[r[1], t])</code></p><p><code>varcts[r[1], t] &gt;= 0.0</code></p><p>Otherwise:</p><p><code>varcts[r[1], t] &lt;= r[2].max*varbin[r[1], t]</code></p><p><code>varcts[r[1], t] &gt;= r[2].min*varbin[r[1], t]</code></p><p>where r in range_data.</p><p><strong>LaTeX</strong></p><p><span>$0 \leq x^{cts} \leq r^{max} x^{bin}, \text{ for } r^{min} = 0$</span></p><p><span>$r^{min} x^{bin} \leq x^{cts} \leq r^{max} x^{bin}, \text{ otherwise }$</span></p><p><strong>Arguments</strong></p><ul><li>canonical_model::CanonicalModel : the canonical model built in PowerSimulations</li><li>scrange_data::Vector{NamedMinMax} : contains name of device (1) and its min/max (2)</li><li>cons_name::Symbol : name of the constraint</li><li>var_name::Symbol : the name of the continuous variable</li><li>binvar_name::Symbol : the name of the binary variable</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.device_timeseries_lb-Tuple{PowerSimulations.CanonicalModel,Tuple{Array{String,1},Array{Float64,1},Array{Array{Float64,1},1}},Symbol,Symbol}" href="#PowerSimulations.device_timeseries_lb-Tuple{PowerSimulations.CanonicalModel,Tuple{Array{String,1},Array{Float64,1},Array{Array{Float64,1},1}},Symbol,Symbol}"><code>PowerSimulations.device_timeseries_lb</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">device_timeseries_lb(canonical_model::CanonicalModel,
                 ts_data::Tuple{Vector{String}, Vector{Float64}, Vector{Vector{Float64}}},
                 cons_name::Symbol,
                 var_name::Symbol)</code></pre><p>Constructs lower bound for given variable subject to time series data and a multiplier.</p><p><strong>Constraint</strong></p><p><code>ts_data[2][ix]*ts_data[3][ix][t] &lt;= variable[name, t]</code></p><p><strong>LaTeX</strong></p><p><span>$r^{val} r_t \leq x_t, \forall t$</span></p><p>where (ix, name) in enumerate(ts_data[1]).</p><p><strong>Arguments</strong></p><ul><li>canonical_model::CanonicalModel : the canonical model built in PowerSimulations</li><li>ts_data::Tuple{Vector{String}, Vector{Float64}, Vector{Vector{Float64}}} : timeseries data name (1), multiplier (2) and values (3)</li><li>cons_name::Symbol : name of the constraint</li><li>var_name::Symbol : the name of the variable</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.device_timeseries_param_lb-Tuple{PowerSimulations.CanonicalModel,Tuple{Array{String,1},Array{Float64,1},Array{Array{Float64,1},1}},Symbol,PowerSimulations.UpdateRef,Symbol}" href="#PowerSimulations.device_timeseries_param_lb-Tuple{PowerSimulations.CanonicalModel,Tuple{Array{String,1},Array{Float64,1},Array{Array{Float64,1},1}},Symbol,PowerSimulations.UpdateRef,Symbol}"><code>PowerSimulations.device_timeseries_param_lb</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">device_timeseries_param_lb(canonical_model::CanonicalModel,
                                ts_data::Tuple{Vector{String}, Vector{Float64}, Vector{Vector{Float64}}},
                                cons_name::Symbol,
                                param_reference::UpdateRef,
                                var_name::Symbol)</code></pre><p>Constructs lower bound for given variable using a parameter. The constraint is     built with a time series data vector and a multiplier</p><p><strong>Constraint</strong></p><p><code>ts_data[2][ix] * param[name, t] &lt;= variable[name, t]</code></p><p><strong>LaTeX</strong></p><p><span>$r^{val} x^{param}_t \leq x^{var}_t, \forall t$</span></p><p><strong>Arguments</strong></p><ul><li>canonical_model::CanonicalModel : the canonical model built in PowerSimulations</li><li>ts_data::Tuple{Vector{String}, Vector{Vector{Float64}}} : timeseries data name (1) and values (2)</li><li>cons_name::Symbol : name of the constraint</li><li>param_reference::UpdateRef : UpdateRef to access the parameter</li><li>var_name::Symbol : the name of the variable</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.device_timeseries_param_ub-Tuple{PowerSimulations.CanonicalModel,Tuple{Array{String,1},Array{Float64,1},Array{Array{Float64,1},1}},Symbol,PowerSimulations.UpdateRef,Symbol}" href="#PowerSimulations.device_timeseries_param_ub-Tuple{PowerSimulations.CanonicalModel,Tuple{Array{String,1},Array{Float64,1},Array{Array{Float64,1},1}},Symbol,PowerSimulations.UpdateRef,Symbol}"><code>PowerSimulations.device_timeseries_param_ub</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">device_timeseries_param_ub(canonical_model::CanonicalModel,
                                ts_data::Tuple{Vector{String}, Vector{Float64}, Vector{Vector{Float64}}},
                                cons_name::Symbol,
                                param_reference::UpdateRef,
                                var_name::Symbol)</code></pre><p>Constructs upper bound for given variable using a parameter. The constraint is     built with a time series data vector and a multiplier</p><p><strong>Constraint</strong></p><p><code>variable[name, t] &lt;= ts_data[2][ix]*param[name, t]</code></p><p><strong>LaTeX</strong></p><p><span>$x^{var}_t \leq r^{val} x^{param}_t, \forall t$</span></p><p><strong>Arguments</strong></p><ul><li>canonical_model::CanonicalModel : the canonical model built in PowerSimulations</li><li>ts_data::Tuple{Vector{String}, Vector{Float64}, Vector{Vector{Float64}}} : timeseries data name (1), multiplier (2) and values (3)</li><li>cons_name::Symbol : name of the constraint</li><li>param_reference::UpdateRef : UpdateRef to access the parameter</li><li>var_name::Symbol : the name of the variable</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.device_timeseries_ub-Tuple{PowerSimulations.CanonicalModel,Tuple{Array{String,1},Array{Float64,1},Array{Array{Float64,1},1}},Symbol,Symbol}" href="#PowerSimulations.device_timeseries_ub-Tuple{PowerSimulations.CanonicalModel,Tuple{Array{String,1},Array{Float64,1},Array{Array{Float64,1},1}},Symbol,Symbol}"><code>PowerSimulations.device_timeseries_ub</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">device_timeseries_ub(canonical_model::CanonicalModel,
                 ts_data::Tuple{Vector{String}, Vector{Float64}, Vector{Vector{Float64}}},
                 cons_name::Symbol,
                 var_name::Symbol)</code></pre><p>Constructs upper bound for given variable and time series data and a multiplier.</p><p><strong>Constraint</strong></p><p><code>variable[name, t] &lt;= ts_data[2][ix]*ts_data[3][ix][t]</code></p><p><strong>LaTeX</strong></p><p><span>$x_t \leq r^{val} r_t, \forall t$</span></p><p><strong>Arguments</strong></p><ul><li>canonical_model::CanonicalModel : the canonical model built in PowerSimulations</li><li>ts_data::Tuple{Vector{String}, Vector{Float64}, Vector{Vector{Float64}}} : timeseries data name (1), multiplier (2) and values (3)</li><li>cons_name::Symbol : name of the constraint</li><li>var_name::Symbol : the name of the variable</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.device_timeseries_ub_bigM" href="#PowerSimulations.device_timeseries_ub_bigM"><code>PowerSimulations.device_timeseries_ub_bigM</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">device_timeseries_ub_bigM(canonical_model::CanonicalModel,
                                ts_data::Tuple{Vector{String}, Vector{Float64}, Vector{Vector{Float64}}},
                                cons_name::Symbol,
                                var_name::Symbol,
                                param_reference::UpdateRef,
                                binvar_name::Symbol,
                                M_value::Float64 = 1e6)</code></pre><p>Constructs upper bound for variable and time series and a multiplier or confines to 0 depending on binary variable.     Uses BigM constraint type to allow for parameter since ParameterJuMP doesn&#39;t support var*parameter</p><p><strong>Constraints</strong></p><p><code>varcts[name, t] - ts_data[2][ix] * param[name, t] &lt;= (1 - varbin[name, t])*M_value</code></p><p><code>varcts[name, t] &lt;= varbin[name, t]*M_value</code></p><p><strong>LaTeX</strong></p><p><span>$x^{cts}_t - r^{val} x^{param}_t \leq M(1 - x^{bin}_t ), forall t$</span></p><p><span>$x^{cts}_t \leq M x^{bin}_t, \forall t$</span></p><p><strong>Arguments</strong></p><ul><li>canonical_model::CanonicalModel : the canonical model built in PowerSimulations</li><li>ts_data::Tuple{Vector{String}, Vector{Vector{Float64}}} : timeseries data name (1) and values (2)</li><li>cons_name::Symbol : name of the constraint</li><li>var_name::Symbol :  name of the variable</li></ul><p>param_reference::UpdateRef : UpdateRef of access the parameters</p><ul><li>binvar_name::Symbol : name of binary variable</li><li>M_value::Float64 : bigM</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.device_timeseries_ub_bin-Tuple{PowerSimulations.CanonicalModel,Tuple{Array{String,1},Array{Float64,1},Array{Array{Float64,1},1}},Symbol,Symbol,Symbol}" href="#PowerSimulations.device_timeseries_ub_bin-Tuple{PowerSimulations.CanonicalModel,Tuple{Array{String,1},Array{Float64,1},Array{Array{Float64,1},1}},Symbol,Symbol,Symbol}"><code>PowerSimulations.device_timeseries_ub_bin</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">device_timeseries_ub_bin(canonical_model::CanonicalModel,
                                ts_data::Tuple{Vector{String}, Vector{Float64}, Vector{Vector{Float64}}},
                                cons_name::Symbol,
                                var_name::Symbol,
                                binvar_name::Symbol)</code></pre><p>Constructs upper bound for variable and time series or confines to 0 depending on binary variable.     The upper bound is defined by a time series and a multiplier.</p><p><strong>Constraints</strong></p><p><code>varcts[name, t] &lt;= varbin[name, t]* ts_data[2][ix] * ts_data[3][ix][t]</code></p><p>where (ix, name) in enumerate(ts_data[1]).</p><p><strong>LaTeX</strong></p><p><span>$x^{cts}_t \leq r^{val} r_t x^{bin}_t, \forall t$</span></p><p><strong>Arguments</strong></p><ul><li>canonical_model::CanonicalModel : the canonical model built in PowerSimulations</li><li>ts_data::Tuple{Vector{String}, Vector{Vector{Float64}}} : timeseries data name (1) and values (2)</li><li>cons_name::Symbol : name of the constraint</li><li>var_name::Symbol :  name of the variable</li><li>binvar_name::Symbol : name of binary variable</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.energy_balance-Tuple{PowerSimulations.CanonicalModel,Array{InitialCondition,1},Tuple{Array{String,1},Array{NamedTuple{(:in, :out),Tuple{Float64,Float64}},1}},Symbol,Tuple{Symbol,Symbol,Symbol}}" href="#PowerSimulations.energy_balance-Tuple{PowerSimulations.CanonicalModel,Array{InitialCondition,1},Tuple{Array{String,1},Array{NamedTuple{(:in, :out),Tuple{Float64,Float64}},1}},Symbol,Tuple{Symbol,Symbol,Symbol}}"><code>PowerSimulations.energy_balance</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">energy_balance(canonical_model::CanonicalModel,
                    initial_conditions::Vector{InitialCondition},
                    efficiency_data::Tuple{Vector{String}, Vector{InOut}},
                    cons_name::Symbol,
                    var_names::Tuple{Symbol, Symbol, Symbol})</code></pre><p>Constructs multi-timestep constraint from initial condition, efficiency data, and variable tuple</p><p><strong>Constraints</strong></p><p>If t = 1:</p><p><code>varenergy[name, 1] == initial_conditions[ix].value + varin[name, 1]*eff_in*fraction_of_hour - varout[name, 1]*fraction_of_hour/eff_out</code></p><p>If t &gt; 1:</p><p><code>varenergy[name, t] == varenergy[name, t-1] + varin[name, t]*eff_in*fraction_of_hour - varout[name, t]*fraction_of_hour/eff_out</code></p><p><strong>LaTeX</strong></p><p><span>$x^{energy}_1 == x^{energy}_{init} + frhr \eta^{in} x^{in}_1 - \frac{frhr}{\eta^{out}} x^{out}_1, \text{ for } t = 1$</span></p><p><span>$x^{energy}_t == x^{energy}_{t-1} + frhr \eta^{in} x^{in}_t - \frac{frhr}{\eta^{out}} x^{out}_t, \forall t \geq 2$</span></p><p><strong>Arguments</strong></p><ul><li>canonical_model::CanonicalModel : the canonical model built in PowerSimulations</li><li>initial_conditions::Vector{InitialCondition} : for time zero &#39;varenergy&#39;</li><li>efficiency_data::Tuple{Vector{String}, Vector{InOut}} :: charging/discharging efficiencies</li><li>cons_name::Symbol : name of the constraint</li><li>var_names::Tuple{Symbol, Symbol, Symbol} : the names of the variables</li><li>: var_names[1] : varin</li><li>: var_names[2] : varout</li><li>: var_names[3] : varenergy</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.parameter_update!-Tuple{PowerSimulations.UpdateRef{JuMP.VariableRef},JuMP.Containers.DenseAxisArray{ParameterJuMP.ParameterRef,N,Ax,L} where L&lt;:Tuple{Vararg{Dict,N}} where Ax where N,Int64,Simulation}" href="#PowerSimulations.parameter_update!-Tuple{PowerSimulations.UpdateRef{JuMP.VariableRef},JuMP.Containers.DenseAxisArray{ParameterJuMP.ParameterRef,N,Ax,L} where L&lt;:Tuple{Vararg{Dict,N}} where Ax where N,Int64,Simulation}"><code>PowerSimulations.parameter_update!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Updates the forecast parameter value</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.post_nip-Tuple{PowerModels.GenericPowerModel}" href="#PowerSimulations.post_nip-Tuple{PowerModels.GenericPowerModel}"><code>PowerSimulations.post_nip</code></a> — <span class="docstring-category">Method</span>.</div><div><div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.post_nip_expr-Tuple{PowerModels.GenericPowerModel}" href="#PowerSimulations.post_nip_expr-Tuple{PowerModels.GenericPowerModel}"><code>PowerSimulations.post_nip_expr</code></a> — <span class="docstring-category">Method</span>.</div><div><div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.powermodels_network!-Union{Tuple{S}, Tuple{PowerSimulations.CanonicalModel,Type{S},PowerSystems.System}} where S&lt;:PowerModels.AbstractActivePowerFormulation" href="#PowerSimulations.powermodels_network!-Union{Tuple{S}, Tuple{PowerSimulations.CanonicalModel,Type{S},PowerSystems.System}} where S&lt;:PowerModels.AbstractActivePowerFormulation"><code>PowerSimulations.powermodels_network!</code></a> — <span class="docstring-category">Method</span>.</div><div><div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.powermodels_network!-Union{Tuple{S}, Tuple{PowerSimulations.CanonicalModel,Type{S},PowerSystems.System}} where S&lt;:PowerModels.AbstractPowerFormulation" href="#PowerSimulations.powermodels_network!-Union{Tuple{S}, Tuple{PowerSimulations.CanonicalModel,Type{S},PowerSystems.System}} where S&lt;:PowerModels.AbstractPowerFormulation"><code>PowerSimulations.powermodels_network!</code></a> — <span class="docstring-category">Method</span>.</div><div><div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.ps_cost-Union{Tuple{JV}, Tuple{PowerSimulations.CanonicalModel,JuMP.Containers.DenseAxisArray{JV,N,Ax,L} where L&lt;:Tuple{Vararg{Dict,N}} where Ax where N,Float64,Float64,Float64}} where JV&lt;:JuMP.AbstractVariableRef" href="#PowerSimulations.ps_cost-Union{Tuple{JV}, Tuple{PowerSimulations.CanonicalModel,JuMP.Containers.DenseAxisArray{JV,N,Ax,L} where L&lt;:Tuple{Vararg{Dict,N}} where Ax where N,Float64,Float64,Float64}} where JV&lt;:JuMP.AbstractVariableRef"><code>PowerSimulations.ps_cost</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ps_cost(canonical_model::CanonicalModel,
            variable::JuMP.Containers.DenseAxisArray{JV},
            cost_component::Float64,
            dt::Float64,
            sign::Float64) where {JV &lt;: JuMP.AbstractVariableRef}</code></pre><p>Returns linear cost terms for sum of variables with common factor to be used for cost expression for canonical model.</p><p><strong>Equation</strong></p><p><code>gen_cost = sum(variable)*cost_component</code></p><p><strong>LaTeX</strong></p><p><span>$cost = dt\times sign\sum_{i\in I} c x_i$</span></p><p>Returns:</p><p><code>sign*gen_cost*dt</code></p><p><strong>Arguments</strong></p><ul><li>canonical_model::CanonicalModel : the canonical model built in PowerSimulations</li><li>variable::JuMP.Containers.DenseAxisArray{JV} : variable array</li><li>cost_component::Float64 : cost to be associated with variable</li><li>dt::Float64 : fraction of hour</li><li>sign::Float64 : positive or negative sign to be associated cost term</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.ps_cost-Union{Tuple{JV}, Tuple{PowerSimulations.CanonicalModel,JuMP.Containers.DenseAxisArray{JV,N,Ax,L} where L&lt;:Tuple{Vararg{Dict,N}} where Ax where N,PowerSystems.VariableCost{Array{Tuple{Float64,Float64},1}},Float64,Float64}} where JV&lt;:JuMP.AbstractVariableRef" href="#PowerSimulations.ps_cost-Union{Tuple{JV}, Tuple{PowerSimulations.CanonicalModel,JuMP.Containers.DenseAxisArray{JV,N,Ax,L} where L&lt;:Tuple{Vararg{Dict,N}} where Ax where N,PowerSystems.VariableCost{Array{Tuple{Float64,Float64},1}},Float64,Float64}} where JV&lt;:JuMP.AbstractVariableRef"><code>PowerSimulations.ps_cost</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ps_cost(canonical_model::CanonicalModel,
             variable::JuMP.Containers.DenseAxisArray{JV},
             cost_component::PSY.VariableCost{Vector{NTuple{2, Float64}}},
             dt::Float64,
             sign::Float64) where {JV&lt;:JuMP.AbstractVariableRef}</code></pre><p>Creates piecewise linear cost function using a sum of variables and expression with sign and time step included.</p><p><strong>Expression</strong></p><p><code>JuMP.add_to_expression!(gen_cost, c)</code></p><p>Returns sign<em>gen_cost</em>dt</p><p><strong>LaTeX</strong></p><p><span>$cost = sign\times dt \sum_{v\in V} c_v$</span></p><p>where <span>$c_v$</span> is given by</p><p><span>$c_v = \sum_{i\in Ix} \frac{y_i - y_{i-1}}{x_i - x_{i-1}} v^{p.w.}_i$</span></p><p><strong>Arguments</strong></p><ul><li>canonical_model::CanonicalModel : the canonical model built in PowerSimulations</li><li>variable::JuMP.Containers.DenseAxisArray{JV} : variable array</li><li>cost_component::PSY.VariableCost{Vector{NTuple{2, Float64}}}</li><li>dt::Float64 : fraction of hour</li><li>sign::Float64 : positive or negative sign to be associated cost term</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.ps_cost-Union{Tuple{JV}, Tuple{PowerSimulations.CanonicalModel,JuMP.Containers.DenseAxisArray{JV,N,Ax,L} where L&lt;:Tuple{Vararg{Dict,N}} where Ax where N,PowerSystems.VariableCost{Float64},Float64,Float64}} where JV&lt;:JuMP.AbstractVariableRef" href="#PowerSimulations.ps_cost-Union{Tuple{JV}, Tuple{PowerSimulations.CanonicalModel,JuMP.Containers.DenseAxisArray{JV,N,Ax,L} where L&lt;:Tuple{Vararg{Dict,N}} where Ax where N,PowerSystems.VariableCost{Float64},Float64,Float64}} where JV&lt;:JuMP.AbstractVariableRef"><code>PowerSimulations.ps_cost</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ps_cost(canonical_model::CanonicalModel,
            variable::JuMP.Containers.DenseAxisArray{JV},
            cost_component::PSY.VariableCost{Float64},
            dt::Float64,
            sign::Float64) where {JV &lt;: JuMP.AbstractVariableRef}</code></pre><p>Returns linear cost terms for sum of variables with common factor to be used for cost expression for canonical model. Does this by calling <code>ps_cost</code> that has Float64 cost component input.</p><p>Returns:</p><p><code>ps_cost(canonical_model, variable, PSY.get_cost(cost_component), dt, sign)</code></p><p><strong>Arguments</strong></p><ul><li>canonical_model::CanonicalModel : the canonical model built in PowerSimulations</li><li>variable::JuMP.Containers.DenseAxisArray{JV} : variable array</li><li>cost_component::PSY.VariableCost{Float64} : container for cost to be associated with variable</li><li>dt::Float64 : fraction of hour</li><li>sign::Float64 : positive or negative sign to be associated cost term</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.ps_cost-Union{Tuple{JV}, Tuple{PowerSimulations.CanonicalModel,JuMP.Containers.DenseAxisArray{JV,N,Ax,L} where L&lt;:Tuple{Vararg{Dict,N}} where Ax where N,PowerSystems.VariableCost{Tuple{Float64,Float64}},Float64,Float64}} where JV&lt;:JuMP.AbstractVariableRef" href="#PowerSimulations.ps_cost-Union{Tuple{JV}, Tuple{PowerSimulations.CanonicalModel,JuMP.Containers.DenseAxisArray{JV,N,Ax,L} where L&lt;:Tuple{Vararg{Dict,N}} where Ax where N,PowerSystems.VariableCost{Tuple{Float64,Float64}},Float64,Float64}} where JV&lt;:JuMP.AbstractVariableRef"><code>PowerSimulations.ps_cost</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ps_cost(canonical_model::CanonicalModel,
            variable::JuMP.Containers.DenseAxisArray{JV},
            cost_component::PSY.VariableCost{NTuple{2, Float64}}
            dt::Float64,
            sign::Float64) where {JV &lt;: JuMP.AbstractVariableRef}</code></pre><p>Returns quadratic cost terms for sum of variables with common factor to be used for cost expression for canonical model.</p><p><strong>Equation</strong></p><p><code>gen_cost = dt*sign*(sum(variable.^2)*cost_component[1] + sum(variable)*cost_component[2])</code></p><p><strong>LaTeX</strong></p><p><span>$cost = dt\times sign (sum_{i\in I} c_1 v_i^2 + sum_{i\in I} c_2 v_i )$</span></p><p>for quadratic factor large enough. Otherwise</p><p><code>return ps_cost(canonical_model, variable, cost_component[2], dt, 1.0)</code></p><p>Returns <code>gen_cost</code></p><p><strong>Arguments</strong></p><ul><li>canonical_model::CanonicalModel : the canonical model built in PowerSimulations</li><li>variable::JuMP.Containers.DenseAxisArray{JV} : variable array</li><li>cost_component::PSY.VariableCost{NTuple{2, Float64}} : container for quadratic and linear factors</li><li>sign::Float64 : positive or negative sign to be associated cost term</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.ramp_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.CanonicalModel,InfrastructureSystems.FlattenIteratorWrapper{T},Type{D},Type{S}}} where S&lt;:PowerModels.AbstractPowerFormulation where D&lt;:PowerSimulations.AbstractThermalFormulation where T&lt;:PowerSystems.ThermalGen" href="#PowerSimulations.ramp_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.CanonicalModel,InfrastructureSystems.FlattenIteratorWrapper{T},Type{D},Type{S}}} where S&lt;:PowerModels.AbstractPowerFormulation where D&lt;:PowerSimulations.AbstractThermalFormulation where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.ramp_constraints!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>This function adds the ramping limits of generators when there are CommitmentVariables</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.range_ff-Tuple{PowerSimulations.CanonicalModel,Symbol,Tuple{PowerSimulations.UpdateRef,PowerSimulations.UpdateRef},Symbol}" href="#PowerSimulations.range_ff-Tuple{PowerSimulations.CanonicalModel,Symbol,Tuple{PowerSimulations.UpdateRef,PowerSimulations.UpdateRef},Symbol}"><code>PowerSimulations.range_ff</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">    range_ff(canonical_model::CanonicalModel,
                    cons_name::Symbol,
                    param_reference::NTuple{2, UpdateRef},
                    var_name::Symbol)</code></pre><p>Constructs min/max range parametrized constraint from device variable to include feedforward.</p><p><strong>Constraints</strong></p><p><code>param_reference[1][var_name] &lt;= variable[var_name, t]</code> <code>variable[var_name, t] &lt;= param_reference[2][var_name]</code></p><p>where r in range_data.</p><p><strong>LaTeX</strong></p><p><span>$param^{min} \leq x$</span> <span>$x \leq param^{max}$</span></p><p><strong>Arguments</strong></p><ul><li>canonical_model::CanonicalModel : the canonical model built in PowerSimulations</li><li>param_reference::NTuple{2, UpdateRef} : Tuple with the lower bound and upper bound parameter reference</li><li>cons_name::Symbol : name of the constraint</li><li>var_name::Symbol : the name of the continuous variable</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.rating_constraint-Tuple{PowerSimulations.CanonicalModel,Array{Tuple{String,Float64},1},Symbol,Tuple{Symbol,Symbol}}" href="#PowerSimulations.rating_constraint-Tuple{PowerSimulations.CanonicalModel,Array{Tuple{String,Float64},1},Symbol,Tuple{Symbol,Symbol}}"><code>PowerSimulations.rating_constraint</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">rating_constraint(canonical_model::CanonicalModel,
                        rating_data::Vector{Tuple{String, Float64}},
                        cons_name::Symbol,
                        var_names::Tuple{Symbol, Symbol})</code></pre><p>Constructs constraint from rating data and related variable tuple.</p><p><strong>Constraint</strong></p><p><code>var1[r[1], t]^2 + var2[r[1], t]^2 &lt;= r[2]^2</code></p><p>where r in rating data and t in time steps.</p><p><strong>LaTeX</strong></p><p><span>$x_1^2 + x_2^2 \leq r^2$</span></p><p><strong>Arguments</strong></p><ul><li>canonical_model::CanonicalModel : the canonical model built in PowerSimulations</li><li>rating_data::Vector{Tuple{String, Float64}} : rating data name (1) and value (2)</li><li>cons_name::Symbol : name of the constraint</li><li>var_names::Tuple{Symbol, Symbol} : the names of the variables</li><li>: var_names[1] : var1</li><li>: var_names[2] : var2</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.reactive_power_constraints-Union{Tuple{S}, Tuple{D}, Tuple{St}, Tuple{PowerSimulations.CanonicalModel,InfrastructureSystems.FlattenIteratorWrapper{St},Type{D},Type{S}}} where S&lt;:PowerModels.AbstractPowerFormulation where D&lt;:PowerSimulations.AbstractStorageForm where St&lt;:PowerSystems.Storage" href="#PowerSimulations.reactive_power_constraints-Union{Tuple{S}, Tuple{D}, Tuple{St}, Tuple{PowerSimulations.CanonicalModel,InfrastructureSystems.FlattenIteratorWrapper{St},Type{D},Type{S}}} where S&lt;:PowerModels.AbstractPowerFormulation where D&lt;:PowerSimulations.AbstractStorageForm where St&lt;:PowerSystems.Storage"><code>PowerSimulations.reactive_power_constraints</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>This function adds the reactive  power limits of generators when there are CommitmentVariables</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.reactivepower_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.CanonicalModel,InfrastructureSystems.FlattenIteratorWrapper{T},Type{D},Type{S}}} where S&lt;:PowerModels.AbstractPowerFormulation where D&lt;:PowerSimulations.AbstractThermalDispatchForm where T&lt;:PowerSystems.ThermalGen" href="#PowerSimulations.reactivepower_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.CanonicalModel,InfrastructureSystems.FlattenIteratorWrapper{T},Type{D},Type{S}}} where S&lt;:PowerModels.AbstractPowerFormulation where D&lt;:PowerSimulations.AbstractThermalDispatchForm where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.reactivepower_constraints!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>This function adds the reactive  power limits of generators when there are CommitmentVariables</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.reactivepower_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.CanonicalModel,InfrastructureSystems.FlattenIteratorWrapper{T},Type{D},Type{S}}} where S&lt;:PowerModels.AbstractPowerFormulation where D&lt;:PowerSimulations.AbstractThermalFormulation where T&lt;:PowerSystems.ThermalGen" href="#PowerSimulations.reactivepower_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.CanonicalModel,InfrastructureSystems.FlattenIteratorWrapper{T},Type{D},Type{S}}} where S&lt;:PowerModels.AbstractPowerFormulation where D&lt;:PowerSimulations.AbstractThermalFormulation where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.reactivepower_constraints!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>This function adds the reactive power limits of generators when there CommitmentVariables</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.reactivepower_constraints-Union{Tuple{S}, Tuple{D}, Tuple{L}, Tuple{PowerSimulations.CanonicalModel,InfrastructureSystems.FlattenIteratorWrapper{L},Type{D},Type{S}}} where S&lt;:PowerModels.AbstractPowerFormulation where D&lt;:PowerSimulations.AbstractControllablePowerLoadForm where L&lt;:PowerSystems.ElectricLoad" href="#PowerSimulations.reactivepower_constraints-Union{Tuple{S}, Tuple{D}, Tuple{L}, Tuple{PowerSimulations.CanonicalModel,InfrastructureSystems.FlattenIteratorWrapper{L},Type{D},Type{S}}} where S&lt;:PowerModels.AbstractPowerFormulation where D&lt;:PowerSimulations.AbstractControllablePowerLoadForm where L&lt;:PowerSystems.ElectricLoad"><code>PowerSimulations.reactivepower_constraints</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Reactive Power Constraints on Loads Assume Constant PowerFactor</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.reactivepower_variables!-Union{Tuple{T}, Tuple{PowerSimulations.CanonicalModel,InfrastructureSystems.FlattenIteratorWrapper{T}}} where T&lt;:PowerSystems.ThermalGen" href="#PowerSimulations.reactivepower_variables!-Union{Tuple{T}, Tuple{PowerSimulations.CanonicalModel,InfrastructureSystems.FlattenIteratorWrapper{T}}} where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.reactivepower_variables!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>This function add the variables for power generation output to the model</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.remove_chars-Tuple{String,String}" href="#PowerSimulations.remove_chars-Tuple{String,String}"><code>PowerSimulations.remove_chars</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Removes the string <code>char</code> from the original string</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.replace_chars-Tuple{String,String,String}" href="#PowerSimulations.replace_chars-Tuple{String,String,String}"><code>PowerSimulations.replace_chars</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Replaces the string in <code>char</code> with the string<code>replacement</code></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.reserve_device_semicontinuousrange-Tuple{PowerSimulations.CanonicalModel,Array{Tuple{String,NamedTuple{(:min, :max),Tuple{Float64,Float64}}},1},Symbol,Symbol,Symbol}" href="#PowerSimulations.reserve_device_semicontinuousrange-Tuple{PowerSimulations.CanonicalModel,Array{Tuple{String,NamedTuple{(:min, :max),Tuple{Float64,Float64}}},1},Symbol,Symbol,Symbol}"><code>PowerSimulations.reserve_device_semicontinuousrange</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">reserve_device_semicontinuousrange(canonical_model::CanonicalModel,
                                scrange_data::Vector{NamedMinMax},
                                cons_name::Symbol,
                                var_name::Symbol,
                                binvar_name::Symbol)</code></pre><p>Constructs min/max range constraint from device variable and on/off decision variable.</p><p><strong>Constraints</strong></p><p>If device min = 0:</p><p><code>varcts[r[1], t] &lt;= r[2].max*(1-varbin[r[1], t])</code></p><p><code>varcts[r[1], t] &gt;= 0.0</code></p><p>Otherwise:</p><p><code>varcts[r[1], t] &lt;= r[2].max*(1-varbin[r[1], t])</code></p><p><code>varcts[r[1], t] &gt;= r[2].min*(1-varbin[r[1], t])</code></p><p>where r in range_data.</p><p><strong>LaTeX</strong></p><p><span>$0 \leq x^{cts} \leq r^{max} (1 - x^{bin} ), \text{ for } r^{min} = 0$</span></p><p><span>$r^{min} (1 - x^{bin} ) \leq x^{cts} \leq r^{max} (1 - x^{bin} ), \text{ otherwise }$</span></p><p><strong>Arguments</strong></p><ul><li>canonical_model::CanonicalModel : the canonical model built in PowerSimulations</li><li>scrange_data::Vector{NamedMinMax} : contains name of device (1) and its min/max (2)</li><li>cons_name::Symbol : name of the constraint</li><li>var_name::Symbol : the name of the continuous variable</li><li>binvar_name::Symbol : the name of the binary variable</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.semicontinuousrange_ff-Tuple{PowerSimulations.CanonicalModel,Symbol,PowerSimulations.UpdateRef,Symbol}" href="#PowerSimulations.semicontinuousrange_ff-Tuple{PowerSimulations.CanonicalModel,Symbol,PowerSimulations.UpdateRef,Symbol}"><code>PowerSimulations.semicontinuousrange_ff</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">        semicontinuousrange_ff(canonical_model::CanonicalModel,
                                cons_name::Symbol,
                                var_name::Symbol,
                                param_reference::UpdateRef)</code></pre><p>Constructs min/max range constraint from device variable with parameter setting.</p><p><strong>Constraints</strong></p><p>If device min = 0:</p><p><code>variable[var_name, t] &lt;= r[2].max*param_reference[var_name]</code></p><p>Otherwise:</p><p><code>variable[var_name, t] &lt;= r[2].max*param_reference[var_name]</code></p><p><code>variable[var_name, t] &gt;= r[2].min*param_reference[var_name]</code></p><p>where r in range_data.</p><p><strong>LaTeX</strong></p><p><span>$0.0 \leq x^{var} \leq r^{max} x^{param}, \text{ for } r^{min} = 0$</span></p><p><span>$r^{min} x^{param} \leq x^{var} \leq r^{min} x^{param}, \text{ otherwise }$</span></p><p><strong>Arguments</strong></p><ul><li>canonical_model::CanonicalModel : the canonical model built in PowerSimulations</li><li>cons_name::Symbol : name of the constraint</li><li>var_name::Symbol : the name of the continuous variable</li><li>param_reference::UpdateRef : UpdateRef of the parameter</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.set_variable_bounds-Tuple{PowerSimulations.CanonicalModel,Array{Tuple{String,NamedTuple{(:min, :max),Tuple{Float64,Float64}}},1},Symbol}" href="#PowerSimulations.set_variable_bounds-Tuple{PowerSimulations.CanonicalModel,Array{Tuple{String,NamedTuple{(:min, :max),Tuple{Float64,Float64}}},1},Symbol}"><code>PowerSimulations.set_variable_bounds</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">set_variable_bounds(canonical_model::CanonicalModel,
                        bounds::Vector{NamedMinMax},
                        var_name::Symbol)</code></pre><p>Adds a bounds to a variable in the optimization model.</p><p><strong>Bounds</strong></p><p><code>bounds.min &lt;= varstart[name, t] &lt;= bounds.max</code></p><p><strong>LaTeX</strong></p><p><span>$x^{device}_t &gt;= bound^{min} \forall t$</span></p><p><span>$x^{device}_t &lt;= bound^{max} \forall t$</span></p><p><strong>Arguments</strong></p><ul><li>canonical_model::CanonicalModel : the canonical model built in PowerSimulations</li><li>bounds::Vector{NamedMinMax} : contains name of device (1) and its min/max (2)</li><li>var_name::Symbol : Base Name for the variable</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.status_init-Union{Tuple{PSD}, Tuple{PowerSimulations.CanonicalModel,InfrastructureSystems.FlattenIteratorWrapper{PSD}}} where PSD&lt;:PowerSystems.ThermalGen" href="#PowerSimulations.status_init-Union{Tuple{PSD}, Tuple{PowerSimulations.CanonicalModel,InfrastructureSystems.FlattenIteratorWrapper{PSD}}} where PSD&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.status_init</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Status Initis is always calculated based on the Power Output of the device This is to make it easier to calculate when the previous model doesn&#39;t contain binaries. For instance, looking back on an ED model to find the IC of the UC model</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.ub_ff-Tuple{PowerSimulations.CanonicalModel,Symbol,PowerSimulations.UpdateRef,Symbol}" href="#PowerSimulations.ub_ff-Tuple{PowerSimulations.CanonicalModel,Symbol,PowerSimulations.UpdateRef,Symbol}"><code>PowerSimulations.ub_ff</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">    ub_ff(canonical_model::CanonicalModel,
          cons_name::Symbol,
          param_reference::UpdateRef,
          var_name::Symbol)</code></pre><p>Constructs a parametrized upper bound constraint to implement feedforward from other models. The Parameters are initialized using the uppper boundary values of the provided variables.</p><p><strong>Constraints</strong></p><p><code>variable[var_name, t] &lt;= param_reference[var_name]</code></p><p><strong>LaTeX</strong></p><p><span>$x \leq param^{max}$</span></p><p><strong>Arguments</strong></p><ul><li>canonical_model::CanonicalModel : the canonical model built in PowerSimulations</li><li>cons_name::Symbol : name of the constraint</li><li>param_reference : Reference to the Parameter used to determine the upperbound</li><li>var_name::Symbol : the name of the continuous variable</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.variable_active_net_injection-Tuple{PowerModels.GenericPowerModel}" href="#PowerSimulations.variable_active_net_injection-Tuple{PowerModels.GenericPowerModel}"><code>PowerSimulations.variable_active_net_injection</code></a> — <span class="docstring-category">Method</span>.</div><div><div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.variable_net_injection-Tuple{PowerModels.GenericPowerModel}" href="#PowerSimulations.variable_net_injection-Tuple{PowerModels.GenericPowerModel}"><code>PowerSimulations.variable_net_injection</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>generates variables for both <code>active</code> and <code>reactive</code> net injection</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.variable_reactive_net_injection-Tuple{PowerModels.GenericPowerModel}" href="#PowerSimulations.variable_reactive_net_injection-Tuple{PowerModels.GenericPowerModel}"><code>PowerSimulations.variable_reactive_net_injection</code></a> — <span class="docstring-category">Method</span>.</div><div><div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PowerSimulations.variable_reactive_net_injection-Union{Tuple{PowerModels.GenericPowerModel{T}}, Tuple{T}} where T&lt;:PowerModels.AbstractDCPForm" href="#PowerSimulations.variable_reactive_net_injection-Union{Tuple{PowerModels.GenericPowerModel{T}}, Tuple{T}} where T&lt;:PowerModels.AbstractDCPForm"><code>PowerSimulations.variable_reactive_net_injection</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>active power only models ignore reactive power variables</p></div></div></section><footer><hr/><a class="previous" href="../../"><span class="direction">Previous</span><span class="title">Home</span></a></footer></article></body></html>
