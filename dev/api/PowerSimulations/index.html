<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>PowerSimulations · PowerSimulations.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="PowerSimulations.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">PowerSimulations.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../../man/logging/">Logging</a></li><li><a class="tocitem" href="../../man/op_problem/">Operation Model</a></li><li><a class="tocitem" href="../../man/simulation_recorder/">Simulation Recorder</a></li><li><span class="tocitem">API</span><ul><li class="is-active"><a class="tocitem" href>PowerSimulations</a><ul class="internal"><li><a class="tocitem" href="#Index-1"><span>Index</span></a></li><li><a class="tocitem" href="#Exported-1"><span>Exported</span></a></li><li><a class="tocitem" href="#Internal-1"><span>Internal</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>PowerSimulations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>PowerSimulations</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/master/docs/src/api/PowerSimulations.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="PowerSimulations-1"><a class="docs-heading-anchor" href="#PowerSimulations-1">PowerSimulations</a><a class="docs-heading-anchor-permalink" href="#PowerSimulations-1" title="Permalink"></a></h1><p>API documentation</p><ul><li><a href="#PowerSimulations-1">PowerSimulations</a></li><ul><li><a href="#Index-1">Index</a></li><li><a href="#Exported-1">Exported</a></li><li><a href="#Internal-1">Internal</a></li></ul></ul><h2 id="Index-1"><a class="docs-heading-anchor" href="#Index-1">Index</a><a class="docs-heading-anchor-permalink" href="#Index-1" title="Permalink"></a></h2><ul><li><a href="#PowerSimulations.AbstractSimulationStatusEvent"><code>PowerSimulations.AbstractSimulationStatusEvent</code></a></li><li><a href="#PowerSimulations.DeviceModel"><code>PowerSimulations.DeviceModel</code></a></li><li><a href="#PowerSimulations.DeviceRange"><code>PowerSimulations.DeviceRange</code></a></li><li><a href="#PowerSimulations.IntraStageChronology"><code>PowerSimulations.IntraStageChronology</code></a></li><li><a href="#PowerSimulations.OperationsProblem-Union{Tuple{M}, Tuple{Type{M},OperationsProblemTemplate,PowerSystems.System}, Tuple{Type{M},OperationsProblemTemplate,PowerSystems.System,Union{Nothing, JuMP.AbstractModel}}} where M&lt;:PowerSimulations.AbstractOperationsProblem"><code>PowerSimulations.OperationsProblem</code></a></li><li><a href="#PowerSimulations.OperationsProblem-Tuple{AbstractString}"><code>PowerSimulations.OperationsProblem</code></a></li><li><a href="#PowerSimulations.OperationsProblem-Union{Tuple{T}, Tuple{Type{T},PowerSystems.System}, Tuple{Type{T},PowerSystems.System,Union{Nothing, JuMP.AbstractModel}}} where T&lt;:PowerModels.AbstractPowerModel"><code>PowerSimulations.OperationsProblem</code></a></li><li><a href="#PowerSimulations.OperationsProblem-Union{Tuple{T}, Tuple{M}, Tuple{Type{M},Type{T},PowerSystems.System}, Tuple{Type{M},Type{T},PowerSystems.System,Union{Nothing, JuMP.AbstractModel}}} where T&lt;:PowerModels.AbstractPowerModel where M&lt;:PowerSimulations.AbstractOperationsProblem"><code>PowerSimulations.OperationsProblem</code></a></li><li><a href="#PowerSimulations.OperationsProblemTemplate-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:PowerModels.AbstractPowerModel"><code>PowerSimulations.OperationsProblemTemplate</code></a></li><li><a href="#PowerSimulations.RecedingHorizon"><code>PowerSimulations.RecedingHorizon</code></a></li><li><a href="#PowerSimulations.Simulation-Tuple{AbstractString,Dict}"><code>PowerSimulations.Simulation</code></a></li><li><a href="#PowerSimulations.Simulation"><code>PowerSimulations.Simulation</code></a></li><li><a href="#PowerSimulations.SimulationSequence"><code>PowerSimulations.SimulationSequence</code></a></li><li><a href="#PowerSimulations.Stage-Union{Tuple{M}, Tuple{Type{M},OperationsProblemTemplate,PowerSystems.System,MathOptInterface.OptimizerWithAttributes}, Tuple{Type{M},OperationsProblemTemplate,PowerSystems.System,MathOptInterface.OptimizerWithAttributes,Union{Nothing, JuMP.AbstractModel}}} where M&lt;:PowerSimulations.AbstractOperationsProblem"><code>PowerSimulations.Stage</code></a></li><li><a href="#PowerSimulations.Stage"><code>PowerSimulations.Stage</code></a></li><li><a href="#PowerSimulations.Synchronize"><code>PowerSimulations.Synchronize</code></a></li><li><a href="#PowerSimulations.TimeStatusChange"><code>PowerSimulations.TimeStatusChange</code></a></li><li><a href="#PowerSimulations.UpdateRef"><code>PowerSimulations.UpdateRef</code></a></li><li><a href="#Base.show-Tuple{IO,MIME{Symbol(&quot;text/plain&quot;)},OperationsProblem}"><code>Base.show</code></a></li><li><a href="#InfrastructureSystems.write_results-Tuple{PowerSimulations.OperationsProblemResults,String}"><code>InfrastructureSystems.write_results</code></a></li><li><a href="#PowerSimulations._allocate_execution_order-Tuple{Dict{Int64,Int64}}"><code>PowerSimulations._allocate_execution_order</code></a></li><li><a href="#PowerSimulations._calculate_interval_inner_counts-Tuple{Dict{Int64,String},Dict{String,Tuple{Dates.TimePeriod,#s96} where #s96&lt;:PowerSimulations.FeedForwardChronology},Dates.TimePeriod}"><code>PowerSimulations._calculate_interval_inner_counts</code></a></li><li><a href="#PowerSimulations._get_data_for_rocc-Tuple{Array{InitialCondition,1},Dates.TimePeriod}"><code>PowerSimulations._get_data_for_rocc</code></a></li><li><a href="#PowerSimulations._get_data_for_tdc-Tuple{Array{InitialCondition,1},Array{InitialCondition,1},Dates.TimePeriod}"><code>PowerSimulations._get_data_for_tdc</code></a></li><li><a href="#PowerSimulations._pwl_cost-Union{Tuple{JV}, Tuple{PowerSimulations.PSIContainer,JV,Array{Tuple{Float64,Float64},1}}} where JV&lt;:JuMP.AbstractVariableRef"><code>PowerSimulations._pwl_cost</code></a></li><li><a href="#PowerSimulations._pwlgencost_linear-Union{Tuple{JV}, Tuple{PowerSimulations.PSIContainer,JV,Array{Tuple{Float64,Float64},1}}} where JV&lt;:JuMP.AbstractVariableRef"><code>PowerSimulations._pwlgencost_linear</code></a></li><li><a href="#PowerSimulations._pwlgencost_sos-Union{Tuple{JV}, Tuple{PowerSimulations.PSIContainer,JV,Array{Tuple{Float64,Float64},1}}} where JV&lt;:JuMP.AbstractVariableRef"><code>PowerSimulations._pwlgencost_sos</code></a></li><li><a href="#PowerSimulations._pwlparamcheck-Tuple{Any}"><code>PowerSimulations._pwlparamcheck</code></a></li><li><a href="#PowerSimulations._update_stage!-Tuple{Stage,Simulation}"><code>PowerSimulations._update_stage!</code></a></li><li><a href="#PowerSimulations._write_psi_container-Tuple{PowerSimulations.PSIContainer,String}"><code>PowerSimulations._write_psi_container</code></a></li><li><a href="#PowerSimulations.activepower_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},DeviceModel{T,#s509} where #s509&lt;:PowerSimulations.AbstractThermalDispatchFormulation,Type{#s508} where #s508&lt;:PowerModels.AbstractPowerModel,Nothing}} where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.activepower_constraints!</code></a></li><li><a href="#PowerSimulations.activepower_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},DeviceModel{T,ThermalDispatchNoMin},Type{#s509} where #s509&lt;:PowerModels.AbstractPowerModel,Nothing}} where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.activepower_constraints!</code></a></li><li><a href="#PowerSimulations.activepower_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},DeviceModel{T,#s509} where #s509&lt;:PowerSimulations.AbstractThermalFormulation,Type{#s508} where #s508&lt;:PowerModels.AbstractPowerModel,Nothing}} where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.activepower_constraints!</code></a></li><li><a href="#PowerSimulations.activepower_variables!-Union{Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T}}} where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.activepower_variables!</code></a></li><li><a href="#PowerSimulations.activeservice_variables!-Union{Tuple{SR}, Tuple{PowerSimulations.PSIContainer,SR,Array{#s511,1} where #s511&lt;:PowerSystems.Device}} where SR&lt;:PowerSystems.Reserve"><code>PowerSimulations.activeservice_variables!</code></a></li><li><a href="#PowerSimulations.add_to_cost-Union{Tuple{D}, Tuple{PowerSimulations.PSIContainer,D,Symbol,Symbol}, Tuple{PowerSimulations.PSIContainer,D,Symbol,Symbol,Float64}} where D&lt;:(InfrastructureSystems.FlattenIteratorWrapper{#s509} where #s509&lt;:PowerSystems.Device)"><code>PowerSimulations.add_to_cost</code></a></li><li><a href="#PowerSimulations.add_variable-Union{Tuple{D}, Tuple{PowerSimulations.PSIContainer,D,Symbol,Bool}, Tuple{PowerSimulations.PSIContainer,D,Symbol,Bool,Union{Nothing, Symbol}}, Tuple{PowerSimulations.PSIContainer,D,Symbol,Bool,Union{Nothing, Symbol},Float64}} where D&lt;:Union{Array{#s35,1} where #s35&lt;:PowerSystems.Device, InfrastructureSystems.FlattenIteratorWrapper{#s34} where #s34&lt;:PowerSystems.Device}"><code>PowerSimulations.add_variable</code></a></li><li><a href="#PowerSimulations.build!-Tuple{Simulation}"><code>PowerSimulations.build!</code></a></li><li><a href="#PowerSimulations.build_nip-Tuple{PowerModels.AbstractPowerModel}"><code>PowerSimulations.build_nip</code></a></li><li><a href="#PowerSimulations.check_file_integrity-Tuple{String}"><code>PowerSimulations.check_file_integrity</code></a></li><li><a href="#PowerSimulations.commitment_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},DeviceModel{T,D},Type{S},Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S&lt;:PowerModels.AbstractPowerModel where D&lt;:PowerSimulations.AbstractThermalFormulation where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.commitment_constraints!</code></a></li><li><a href="#PowerSimulations.commitment_variables!-Union{Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T}}} where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.commitment_variables!</code></a></li><li><a href="#PowerSimulations.compute_sha256-Tuple{AbstractString}"><code>PowerSimulations.compute_sha256</code></a></li><li><a href="#PowerSimulations.configure_logging-Tuple{}"><code>PowerSimulations.configure_logging</code></a></li><li><a href="#PowerSimulations.constraint_power_balance_ni-Tuple{PowerModels.AbstractPowerModel,Int64}"><code>PowerSimulations.constraint_power_balance_ni</code></a></li><li><a href="#PowerSimulations.constraint_power_balance_ni-Tuple{PowerModels.AbstractPowerModel,Int64,Int64,Any,Any}"><code>PowerSimulations.constraint_power_balance_ni</code></a></li><li><a href="#PowerSimulations.constraint_power_balance_ni-Tuple{PowerModels.AbstractActivePowerModel,Int64,Int64,Any,Any}"><code>PowerSimulations.constraint_power_balance_ni</code></a></li><li><a href="#PowerSimulations.constraint_power_balance_ni_expr-Tuple{PowerModels.AbstractActivePowerModel,Int64,Int64,Any,Any,Any,Any}"><code>PowerSimulations.constraint_power_balance_ni_expr</code></a></li><li><a href="#PowerSimulations.constraint_power_balance_ni_expr-Tuple{PowerModels.AbstractPowerModel,Int64,Int64,Any,Any,Any,Any}"><code>PowerSimulations.constraint_power_balance_ni_expr</code></a></li><li><a href="#PowerSimulations.constraint_power_balance_ni_expr-Tuple{PowerModels.AbstractPowerModel,Int64}"><code>PowerSimulations.constraint_power_balance_ni_expr</code></a></li><li><a href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,PowerSystems.System,DeviceModel{T,ThermalBasicUnitCommitment},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.construct_device!</code></a></li><li><a href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,PowerSystems.System,DeviceModel{T,ThermalRampLimited},Type{S}}} where S&lt;:PowerModels.AbstractActivePowerModel where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.construct_device!</code></a></li><li><a href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,PowerSystems.System,DeviceModel{T,ThermalRampLimited},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.construct_device!</code></a></li><li><a href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,PowerSystems.System,DeviceModel{T,ThermalBasicUnitCommitment},Type{S}}} where S&lt;:PowerModels.AbstractActivePowerModel where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.construct_device!</code></a></li><li><a href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,PowerSystems.System,DeviceModel{T,D},Type{S}}} where S&lt;:PowerModels.AbstractActivePowerModel where D&lt;:PowerSimulations.AbstractThermalFormulation where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.construct_device!</code></a></li><li><a href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,PowerSystems.System,DeviceModel{T,D},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where D&lt;:PowerSimulations.AbstractThermalFormulation where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.construct_device!</code></a></li><li><a href="#PowerSimulations.container_spec-Union{Tuple{M}, Tuple{M,Vararg{Any,N} where N}} where M&lt;:JuMP.AbstractModel"><code>PowerSimulations.container_spec</code></a></li><li><a href="#PowerSimulations.device_commitment-Tuple{PowerSimulations.PSIContainer,Array{InitialCondition,1},Symbol,Tuple{Symbol,Symbol,Symbol}}"><code>PowerSimulations.device_commitment</code></a></li><li><a href="#PowerSimulations.device_duration_look_ahead-Tuple{PowerSimulations.PSIContainer,Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{InitialCondition,2},Symbol,Tuple{Symbol,Symbol,Symbol}}"><code>PowerSimulations.device_duration_look_ahead</code></a></li><li><a href="#PowerSimulations.device_duration_parameters-Tuple{PowerSimulations.PSIContainer,Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{InitialCondition,2},Symbol,Tuple{Symbol,Symbol,Symbol}}"><code>PowerSimulations.device_duration_parameters</code></a></li><li><a href="#PowerSimulations.device_duration_retrospective-Tuple{PowerSimulations.PSIContainer,Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{InitialCondition,2},Symbol,Tuple{Symbol,Symbol,Symbol}}"><code>PowerSimulations.device_duration_retrospective</code></a></li><li><a href="#PowerSimulations.device_linear_rateofchange-Tuple{PowerSimulations.PSIContainer,Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{InitialCondition,1},Symbol,Symbol}"><code>PowerSimulations.device_linear_rateofchange</code></a></li><li><a href="#PowerSimulations.device_mixedinteger_rateofchange-Tuple{PowerSimulations.PSIContainer,Tuple{Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{NamedTuple{(:min, :max),Tuple{Float64,Float64}},1}},Array{InitialCondition,1},Symbol,Tuple{Symbol,Symbol,Symbol}}"><code>PowerSimulations.device_mixedinteger_rateofchange</code></a></li><li><a href="#PowerSimulations.device_range-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceRange,1},Symbol,Symbol}"><code>PowerSimulations.device_range</code></a></li><li><a href="#PowerSimulations.device_semicontinuousrange-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceRange,1},Symbol,Symbol,Symbol}"><code>PowerSimulations.device_semicontinuousrange</code></a></li><li><a href="#PowerSimulations.device_timeseries_lb-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceTimeSeries,1},Symbol,Symbol}"><code>PowerSimulations.device_timeseries_lb</code></a></li><li><a href="#PowerSimulations.device_timeseries_param_lb-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceTimeSeries,1},Symbol,PowerSimulations.UpdateRef,Symbol}"><code>PowerSimulations.device_timeseries_param_lb</code></a></li><li><a href="#PowerSimulations.device_timeseries_param_ub-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceTimeSeries,1},Symbol,PowerSimulations.UpdateRef,Symbol}"><code>PowerSimulations.device_timeseries_param_ub</code></a></li><li><a href="#PowerSimulations.device_timeseries_ub-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceTimeSeries,1},Symbol,Symbol}"><code>PowerSimulations.device_timeseries_ub</code></a></li><li><a href="#PowerSimulations.device_timeseries_ub_bigM"><code>PowerSimulations.device_timeseries_ub_bigM</code></a></li><li><a href="#PowerSimulations.device_timeseries_ub_bin-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceTimeSeries,1},Symbol,Symbol,Symbol}"><code>PowerSimulations.device_timeseries_ub_bin</code></a></li><li><a href="#PowerSimulations.energy_balance-Tuple{PowerSimulations.PSIContainer,Array{InitialCondition,1},Tuple{Array{String,1},Array{NamedTuple{(:in, :out),Tuple{Float64,Float64}},1}},Symbol,Tuple{Symbol,Symbol,Symbol}}"><code>PowerSimulations.energy_balance</code></a></li><li><a href="#PowerSimulations.export_op_model-Tuple{OperationsProblem,String}"><code>PowerSimulations.export_op_model</code></a></li><li><a href="#PowerSimulations.find_key_with_value-Tuple{Any,Any}"><code>PowerSimulations.find_key_with_value</code></a></li><li><a href="#PowerSimulations.get_all_constraint_index-Tuple{OperationsProblem}"><code>PowerSimulations.get_all_constraint_index</code></a></li><li><a href="#PowerSimulations.get_all_var_index-Tuple{OperationsProblem}"><code>PowerSimulations.get_all_var_index</code></a></li><li><a href="#PowerSimulations.initial_condition_update!-Tuple{Stage,PowerSimulations.ICKey,Array{InitialCondition,1},IntraStageChronology,Simulation}"><code>PowerSimulations.initial_condition_update!</code></a></li><li><a href="#PowerSimulations.initial_condition_update!-Tuple{Stage,PowerSimulations.ICKey,Array{InitialCondition,1},InterStageChronology,Simulation}"><code>PowerSimulations.initial_condition_update!</code></a></li><li><a href="#PowerSimulations.instantiate_nip_expr-Tuple{PowerModels.AbstractPowerModel}"><code>PowerSimulations.instantiate_nip_expr</code></a></li><li><a href="#PowerSimulations.instantiate_nip_expr_model-Tuple{Dict{String,Any},Any}"><code>PowerSimulations.instantiate_nip_expr_model</code></a></li><li><a href="#PowerSimulations.instantiate_nip_model-Tuple{Dict{String,Any},Any}"><code>PowerSimulations.instantiate_nip_model</code></a></li><li><a href="#PowerSimulations.integral_limit_ff-Tuple{PowerSimulations.PSIContainer,Symbol,PowerSimulations.UpdateRef,Symbol}"><code>PowerSimulations.integral_limit_ff</code></a></li><li><a href="#PowerSimulations.iterate_initial_conditions-Tuple{PowerSimulations.InitialConditions}"><code>PowerSimulations.iterate_initial_conditions</code></a></li><li><a href="#PowerSimulations.list_simulation_events-Union{Tuple{T}, Tuple{Type{T},AbstractString}, Tuple{Type{T},AbstractString,Union{Nothing, Function}}} where T&lt;:InfrastructureSystems.AbstractRecorderEvent"><code>PowerSimulations.list_simulation_events</code></a></li><li><a href="#PowerSimulations.load_operation_results-Tuple{AbstractString}"><code>PowerSimulations.load_operation_results</code></a></li><li><a href="#PowerSimulations.load_simulation_results-Tuple{String,String,Vararg{Any,N} where N}"><code>PowerSimulations.load_simulation_results</code></a></li><li><a href="#PowerSimulations.load_simulation_results-Tuple{SimulationResultsReference,String}"><code>PowerSimulations.load_simulation_results</code></a></li><li><a href="#PowerSimulations.make_references-Tuple{Simulation,String}"><code>PowerSimulations.make_references</code></a></li><li><a href="#PowerSimulations.powermodels_network!-Union{Tuple{S}, Tuple{PowerSimulations.PSIContainer,Type{S},PowerSystems.System}} where S&lt;:PowerModels.AbstractActivePowerModel"><code>PowerSimulations.powermodels_network!</code></a></li><li><a href="#PowerSimulations.powermodels_network!-Union{Tuple{S}, Tuple{PowerSimulations.PSIContainer,Type{S},PowerSystems.System}} where S&lt;:PowerModels.AbstractPowerModel"><code>PowerSimulations.powermodels_network!</code></a></li><li><a href="#PowerSimulations.ps_cost-Union{Tuple{JV}, Tuple{PowerSimulations.PSIContainer,JuMP.Containers.DenseAxisArray{JV,N,Ax,L} where L&lt;:Tuple{Vararg{Dict,N}} where Ax where N,PowerSystems.VariableCost{Array{Tuple{Float64,Float64},1}},Float64,Float64}} where JV&lt;:JuMP.AbstractVariableRef"><code>PowerSimulations.ps_cost</code></a></li><li><a href="#PowerSimulations.ps_cost-Union{Tuple{JV}, Tuple{PowerSimulations.PSIContainer,JuMP.Containers.DenseAxisArray{JV,N,Ax,L} where L&lt;:Tuple{Vararg{Dict,N}} where Ax where N,Float64,Float64,Float64}} where JV&lt;:JuMP.AbstractVariableRef"><code>PowerSimulations.ps_cost</code></a></li><li><a href="#PowerSimulations.ps_cost-Union{Tuple{JV}, Tuple{PowerSimulations.PSIContainer,JuMP.Containers.DenseAxisArray{JV,N,Ax,L} where L&lt;:Tuple{Vararg{Dict,N}} where Ax where N,PowerSystems.VariableCost{Tuple{Float64,Float64}},Float64,Float64}} where JV&lt;:JuMP.AbstractVariableRef"><code>PowerSimulations.ps_cost</code></a></li><li><a href="#PowerSimulations.ps_cost-Union{Tuple{JV}, Tuple{PowerSimulations.PSIContainer,JuMP.Containers.DenseAxisArray{JV,N,Ax,L} where L&lt;:Tuple{Vararg{Dict,N}} where Ax where N,PowerSystems.VariableCost{Float64},Float64,Float64}} where JV&lt;:JuMP.AbstractVariableRef"><code>PowerSimulations.ps_cost</code></a></li><li><a href="#PowerSimulations.ramp_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},DeviceModel{T,D},Type{S},Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S&lt;:PowerModels.AbstractPowerModel where D&lt;:PowerSimulations.AbstractThermalFormulation where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.ramp_constraints!</code></a></li><li><a href="#PowerSimulations.range_ff-Tuple{PowerSimulations.PSIContainer,Symbol,Tuple{PowerSimulations.UpdateRef,PowerSimulations.UpdateRef},Symbol}"><code>PowerSimulations.range_ff</code></a></li><li><a href="#PowerSimulations.rating_constraint!-Tuple{PowerSimulations.PSIContainer,Array{Tuple{String,Float64},1},Symbol,Tuple{Symbol,Symbol}}"><code>PowerSimulations.rating_constraint!</code></a></li><li><a href="#PowerSimulations.reactive_power_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{St}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{St},DeviceModel{St,D},Type{S},Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S&lt;:PowerModels.AbstractPowerModel where D&lt;:PowerSimulations.AbstractStorageFormulation where St&lt;:PowerSystems.Storage"><code>PowerSimulations.reactive_power_constraints!</code></a></li><li><a href="#PowerSimulations.reactivepower_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},DeviceModel{T,#s509} where #s509&lt;:PowerSimulations.AbstractThermalDispatchFormulation,Type{#s508} where #s508&lt;:PowerModels.AbstractPowerModel,Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.reactivepower_constraints!</code></a></li><li><a href="#PowerSimulations.reactivepower_constraints!-Union{Tuple{L}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{L},DeviceModel{L,#s508} where #s508&lt;:PowerSimulations.AbstractControllablePowerLoadFormulation,Type{#s507} where #s507&lt;:PowerModels.AbstractPowerModel,Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where L&lt;:PowerSystems.ElectricLoad"><code>PowerSimulations.reactivepower_constraints!</code></a></li><li><a href="#PowerSimulations.reactivepower_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},DeviceModel{T,#s509} where #s509&lt;:PowerSimulations.AbstractThermalFormulation,Type{#s508} where #s508&lt;:PowerModels.AbstractPowerModel,Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.reactivepower_constraints!</code></a></li><li><a href="#PowerSimulations.reactivepower_variables!-Union{Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T}}} where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.reactivepower_variables!</code></a></li><li><a href="#PowerSimulations.read_json-Tuple{AbstractString}"><code>PowerSimulations.read_json</code></a></li><li><a href="#PowerSimulations.remove_chars-Tuple{String,String}"><code>PowerSimulations.remove_chars</code></a></li><li><a href="#PowerSimulations.replace_chars-Tuple{String,String,String}"><code>PowerSimulations.replace_chars</code></a></li><li><a href="#PowerSimulations.reserve_device_semicontinuousrange-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceRange,1},Symbol,Symbol,Symbol}"><code>PowerSimulations.reserve_device_semicontinuousrange</code></a></li><li><a href="#PowerSimulations.reservoir_energy_balance-Tuple{PowerSimulations.PSIContainer,Array{InitialCondition,1},Array{PowerSimulations.DeviceTimeSeries,1},Symbol,Tuple{Symbol,Symbol,Symbol}}"><code>PowerSimulations.reservoir_energy_balance</code></a></li><li><a href="#PowerSimulations.reservoir_energy_balance_param-Tuple{PowerSimulations.PSIContainer,Array{InitialCondition,1},Array{PowerSimulations.DeviceTimeSeries,1},Symbol,Tuple{Symbol,Symbol,Symbol},PowerSimulations.UpdateRef}"><code>PowerSimulations.reservoir_energy_balance_param</code></a></li><li><a href="#PowerSimulations.semicontinuousrange_ff-Tuple{PowerSimulations.PSIContainer,Symbol,PowerSimulations.UpdateRef,Symbol}"><code>PowerSimulations.semicontinuousrange_ff</code></a></li><li><a href="#PowerSimulations.serialize-Tuple{Simulation}"><code>PowerSimulations.serialize</code></a></li><li><a href="#PowerSimulations.set_variable_bounds!-Union{Tuple{T}, Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceRange,1},AbstractString,Type{T}}} where T&lt;:PowerSystems.Device"><code>PowerSimulations.set_variable_bounds!</code></a></li><li><a href="#PowerSimulations.show_recorder_events-Union{Tuple{T}, Tuple{Type{T},AbstractString}, Tuple{Type{T},AbstractString,Union{Nothing, Function}}} where T&lt;:InfrastructureSystems.AbstractRecorderEvent"><code>PowerSimulations.show_recorder_events</code></a></li><li><a href="#PowerSimulations.show_simulation_events-Union{Tuple{T}, Tuple{Type{T},AbstractString}, Tuple{Type{T},AbstractString,Union{Nothing, Function}}} where T&lt;:InfrastructureSystems.AbstractRecorderEvent"><code>PowerSimulations.show_simulation_events</code></a></li><li><a href="#PowerSimulations.solve!-Union{Tuple{OperationsProblem{T}}, Tuple{T}} where T&lt;:PowerSimulations.AbstractOperationsProblem"><code>PowerSimulations.solve!</code></a></li><li><a href="#PowerSimulations.status_init-Union{Tuple{T}, Tuple{PowerSimulations.InitialConditions,InfrastructureSystems.FlattenIteratorWrapper{T}}} where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.status_init</code></a></li><li><a href="#PowerSimulations.template_economic_dispatch-Tuple{}"><code>PowerSimulations.template_economic_dispatch</code></a></li><li><a href="#PowerSimulations.template_unit_commitment-Tuple{}"><code>PowerSimulations.template_unit_commitment</code></a></li><li><a href="#PowerSimulations.ub_ff-Tuple{PowerSimulations.PSIContainer,Symbol,PowerSimulations.UpdateRef,Symbol}"><code>PowerSimulations.ub_ff</code></a></li><li><a href="#PowerSimulations.update_parameter!-Tuple{PowerSimulations.UpdateRef{JuMP.VariableRef},PowerSimulations.ParameterContainer,Stage,Simulation}"><code>PowerSimulations.update_parameter!</code></a></li><li><a href="#PowerSimulations.update_stage!-Union{Tuple{M}, Tuple{Stage{M},Simulation}} where M&lt;:PowerSimulations.AbstractOperationsProblem"><code>PowerSimulations.update_stage!</code></a></li><li><a href="#PowerSimulations.variable_active_net_injection-Tuple{PowerModels.AbstractPowerModel}"><code>PowerSimulations.variable_active_net_injection</code></a></li><li><a href="#PowerSimulations.variable_net_injection-Tuple{PowerModels.AbstractPowerModel}"><code>PowerSimulations.variable_net_injection</code></a></li><li><a href="#PowerSimulations.variable_reactive_net_injection-Tuple{PowerModels.AbstractActivePowerModel}"><code>PowerSimulations.variable_reactive_net_injection</code></a></li><li><a href="#PowerSimulations.variable_reactive_net_injection-Tuple{PowerModels.AbstractPowerModel}"><code>PowerSimulations.variable_reactive_net_injection</code></a></li></ul><h2 id="Exported-1"><a class="docs-heading-anchor" href="#Exported-1">Exported</a><a class="docs-heading-anchor-permalink" href="#Exported-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.DeviceModel" href="#PowerSimulations.DeviceModel"><code>PowerSimulations.DeviceModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DeviceModel(::Type{D}, ::Type{B}) where {D&lt;:PSY.Device,
                                   B&lt;:AbstractDeviceFormulation}</code></pre><p>This validates the device formulation for the Power System Device and the abstract device formulation and returns  Power System Device and the abstract device formulation if the power system device is a concrete type.</p><p><strong>Arguments</strong></p><p>-<code>::Type{D}</code>: Power System Device -<code>::Type{B}</code>: Abstract Device Formulation</p><p><strong>Outputs</strong></p><p><code>DeviceModel(D, B, nothing)</code>: D::PSY.Device, B::AbstractDeviceFormulation</p><p><strong>Example</strong></p><pre><code class="language-julia">branches = Dict{Symbol, DeviceModel}
    (:L =&gt; DeviceModel(PSY.Line, StaticLine),
    :T =&gt; DeviceModel(PSY.Transformer2W, StaticTransformer),
    :TT =&gt; DeviceModel(PSY.TapTransformer , StaticTransformer),
    :dc_line =&gt; DeviceModel(PSY.HVDCLine, HVDCDispatch))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/devices_models/device_model.jl#L12-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.IntraStageChronology" href="#PowerSimulations.IntraStageChronology"><code>PowerSimulations.IntraStageChronology</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">InterStageChronology()

Type struct to select an information sharing model between stages that uses results from the same recent stage to calculate the initial conditions. This model ignores solutions from stages defined finer resolutions.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/core/initial_condition_types.jl#L12-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.OperationsProblem-Tuple{AbstractString}" href="#PowerSimulations.OperationsProblem-Tuple{AbstractString}"><code>PowerSimulations.OperationsProblem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">OperationsProblem(filename::AbstractString)</code></pre><p>Construct an OperationsProblem from a serialized file.</p><p><strong>Arguments</strong></p><ul><li><code>filename::AbstractString</code>: path to serialized file</li><li><code>jump_model::Union{Nothing, JuMP.AbstractModel}</code> = nothing: The JuMP model does not get  serialized. Callers should pass whatever they passed to the original problem.</li><li><code>optimizer::Union{Nothing,JuMP.MOI.OptimizerWithAttributes}</code> = nothing: The optimizer does  not get serialized. Callers should pass whatever they passed to the original problem.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/core/operations_problem.jl#L178-L189">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.OperationsProblem-Union{Tuple{M}, Tuple{Type{M},OperationsProblemTemplate,PowerSystems.System}, Tuple{Type{M},OperationsProblemTemplate,PowerSystems.System,Union{Nothing, JuMP.AbstractModel}}} where M&lt;:PowerSimulations.AbstractOperationsProblem" href="#PowerSimulations.OperationsProblem-Union{Tuple{M}, Tuple{Type{M},OperationsProblemTemplate,PowerSystems.System}, Tuple{Type{M},OperationsProblemTemplate,PowerSystems.System,Union{Nothing, JuMP.AbstractModel}}} where M&lt;:PowerSimulations.AbstractOperationsProblem"><code>PowerSimulations.OperationsProblem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">OperationsProblem(::Type{M},
template::OperationsProblemTemplate,
sys::PSY.System,
jump_model::Union{Nothing, JuMP.AbstractModel}=nothing;
kwargs...) where {M&lt;:AbstractOperationsProblem,
                  T&lt;:PM.AbstractPowerFormulation}</code></pre><p>This builds the optimization problem of type M with the specific system and template.</p><p><strong>Arguments</strong></p><ul><li><code>::Type{M} where M&lt;:AbstractOperationsProblem</code>: The abstract operation model type</li><li><code>template::OperationsProblemTemplate</code>: The model reference made up of transmission, devices,                                         branches, and services.</li><li><code>sys::PSY.System</code>: the system created using Power Systems</li><li><code>jump_model::Union{Nothing, JuMP.AbstractModel}</code>: Enables passing a custom JuMP model. Use with care</li></ul><p><strong>Output</strong></p><ul><li><code>op_problem::OperationsProblem</code>: The operation model containing the model type, built JuMP model, Power</li></ul><p>Systems system.</p><p><strong>Example</strong></p><pre><code class="language-julia">template = OperationsProblemTemplate(CopperPlatePowerModel, devices, branches, services)
OpModel = OperationsProblem(TestOpProblem, template, system)</code></pre><p><strong>Accepted Key Words</strong></p><ul><li><code>Horizon::Int</code>: Manually specify the length of the forecast Horizon</li><li><code>initial_time::Dates.DateTime</code>: Initial Time for the model solve</li><li><code>use_forecast_data::Bool</code> : If true uses the data in the system forecasts. If false uses the data for current operating point in the system.</li><li><code>PTDF::PTDF</code>: Passes the PTDF matrix into the optimization model for StandardPTDFModel networks.</li><li><code>optimizer::JuMP.MOI.OptimizerWithAttributes</code>: The optimizer that will be used in the optimization model.</li><li><code>use_parameters::Bool</code>: True will substitute will implement formulations using ParameterJuMP parameters. Defatul is false.</li><li><code>warm_start::Bool</code> True will use the current operation point in the system to initialize variable values. False initializes all variables to zero. Default is true</li><li><code>slack_variables::Bool</code> True will add slacks to the system balance constraints</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/core/operations_problem.jl#L9-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.OperationsProblem-Union{Tuple{T}, Tuple{M}, Tuple{Type{M},Type{T},PowerSystems.System}, Tuple{Type{M},Type{T},PowerSystems.System,Union{Nothing, JuMP.AbstractModel}}} where T&lt;:PowerModels.AbstractPowerModel where M&lt;:PowerSimulations.AbstractOperationsProblem" href="#PowerSimulations.OperationsProblem-Union{Tuple{T}, Tuple{M}, Tuple{Type{M},Type{T},PowerSystems.System}, Tuple{Type{M},Type{T},PowerSystems.System,Union{Nothing, JuMP.AbstractModel}}} where T&lt;:PowerModels.AbstractPowerModel where M&lt;:PowerSimulations.AbstractOperationsProblem"><code>PowerSimulations.OperationsProblem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">OperationsProblem(op_problem::Type{M},
                ::Type{T},
                sys::PSY.System,
                jump_model::Union{Nothing, JuMP.AbstractModel}=nothing;
                kwargs...) where {M&lt;:AbstractOperationsProblem,
                                  T&lt;:PM.AbstractPowerFormulation}</code></pre><p>Return an unbuilt operation problem of type M with the specific system and network model T.     This constructor doesn&#39;t build any device model; it is meant to built device models individually using <a href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,PowerSystems.System,DeviceModel{T,D},Type{S}}} where S&lt;:PowerModels.AbstractActivePowerModel where D&lt;:PowerSimulations.AbstractThermalFormulation where T&lt;:PowerSystems.ThermalGen"><code>construct_device!</code></a></p><p><strong>Arguments</strong></p><ul><li><code>::Type{M} where M&lt;:AbstractOperationsProblem</code>: The abstract operation model type</li><li><code>::Type{T} where T&lt;:AbstractPowerModel</code>: The abstract network formulation</li><li><code>sys::PSY.System</code>: the system created using Power Systems</li><li><code>jump_model::Union{Nothing, JuMP.AbstractModel}</code>: Enables passing a custom JuMP model. Use with care</li></ul><p><strong>Output</strong></p><ul><li><code>op_problem::OperationsProblem</code>: The operation model containing the model type, unbuilt JuMP model, Power</li></ul><p>Systems system.</p><p><strong>Example</strong></p><pre><code class="language-julia">OpModel = OperationsProblem(MyCustomOpProblem, DCPPowerModel, system)
model = DeviceModel(ThermalStandard, ThermalStandardUnitCommitment)
construct_device!(op_problem, :Thermal, model)</code></pre><p><strong>Accepted Key Words</strong></p><ul><li><code>Horizon::Int</code>: Manually specify the length of the forecast Horizon</li><li><code>initial_time::Dates.DateTime</code>: Initial Time for the model solve</li><li><code>use_forecast_data::Bool</code> : If true uses the data in the system forecasts. If false uses the data for current operating point in the system.</li><li><code>PTDF::PTDF</code>: Passes the PTDF matrix into the optimization model for StandardPTDFModel networks.</li><li><code>optimizer::JuMP.MOI.OptimizerWithAttributes</code>: The optimizer that will be used in the optimization model.</li><li><code>use_parameters::Bool</code>: True will substitute will implement formulations using ParameterJuMP parameters. Defatul is false.</li><li><code>warm_start::Bool</code> True will use the current operation point in the system to initialize variable values. False initializes all variables to zero. Default is true</li><li><code>slack_variables::Bool</code> True will add slacks to the system balance constraints</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/core/operations_problem.jl#L76-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.OperationsProblem-Union{Tuple{T}, Tuple{Type{T},PowerSystems.System}, Tuple{Type{T},PowerSystems.System,Union{Nothing, JuMP.AbstractModel}}} where T&lt;:PowerModels.AbstractPowerModel" href="#PowerSimulations.OperationsProblem-Union{Tuple{T}, Tuple{Type{T},PowerSystems.System}, Tuple{Type{T},PowerSystems.System,Union{Nothing, JuMP.AbstractModel}}} where T&lt;:PowerModels.AbstractPowerModel"><code>PowerSimulations.OperationsProblem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">OperationsProblem(::Type{T},
                sys::PSY.System,
                jump_model::Union{Nothing, JuMP.AbstractModel}=nothing;
                kwargs...) where {M&lt;:AbstractOperationsProblem,
                                  T&lt;:PM.AbstractPowerFormulation}</code></pre><p>Return an unbuilt operation problem of type GenericOpProblem with the specific system and network model T.     This constructor doesn&#39;t build any device model; it is meant to built device models individually using <a href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,PowerSystems.System,DeviceModel{T,D},Type{S}}} where S&lt;:PowerModels.AbstractActivePowerModel where D&lt;:PowerSimulations.AbstractThermalFormulation where T&lt;:PowerSystems.ThermalGen"><code>construct_device!</code></a></p><p><strong>Arguments</strong></p><ul><li><code>::Type{T} where T&lt;:AbstractPowerModel</code>: The abstract network formulation</li><li><code>sys::PSY.System</code>: the system created using Power Systems</li><li><code>jump_model::Union{Nothing, JuMP.AbstractModel}</code>: Enables passing a custom JuMP model. Use with care</li></ul><p><strong>Output</strong></p><ul><li><code>op_problem::OperationsProblem</code>: The operation model containing the model type, unbuilt JuMP model, Power</li></ul><p>Systems system.</p><p><strong>Example</strong></p><pre><code class="language-julia">OpModel = OperationsProblem(DCPPowerModel, system)
model = DeviceModel(ThermalStandard, ThermalStandardUnitCommitment)
construct_device!(op_problem, :Thermal, model)</code></pre><p><strong>Accepted Key Words</strong></p><ul><li><code>Horizon::Int</code>: Manually specify the length of the forecast Horizon</li><li><code>initial_time::Dates.DateTime</code>: Initial Time for the model solve</li><li><code>use_forecast_data::Bool</code> : If true uses the data in the system forecasts. If false uses the data for current operating point in the system.</li><li><code>PTDF::PTDF</code>: Passes the PTDF matrix into the optimization model for StandardPTDFModel networks.</li><li><code>optimizer::JuMP.MOI.OptimizerWithAttributes</code>: The optimizer that will be used in the optimization model.</li><li><code>use_parameters::Bool</code>: True will substitute will implement formulations using ParameterJuMP parameters. Defatul is false.</li><li><code>warm_start::Bool</code> True will use the current operation point in the system to initialize variable values. False initializes all variables to zero. Default is true</li><li><code>slack_variables::Bool</code> True will add slacks to the system balance constraints</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/core/operations_problem.jl#L119-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.OperationsProblemTemplate-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:PowerModels.AbstractPowerModel" href="#PowerSimulations.OperationsProblemTemplate-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:PowerModels.AbstractPowerModel"><code>PowerSimulations.OperationsProblemTemplate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">OperationsProblemTemplate(::Type{T}) where {T&lt;:PM.AbstractPowerFormulation}</code></pre><p>Creates a model reference of the Power Formulation, devices, branches, and services.</p><p><strong>Arguments</strong></p><ul><li><code>model::Type{T&lt;:PM.AbstractPowerFormulation}</code>:</li><li><code>devices::Dict{Symbol, DeviceModel}</code>: device dictionary</li><li><code>branches::Dict{Symbol, BranchModel}</code>: branch dictionary</li><li><code>services::Dict{Symbol, ServiceModel}</code>: service dictionary</li></ul><p><strong>Example</strong></p><pre><code class="language-julia">template = OperationsProblemTemplate(CopperPlatePowerModel, devices, branches, services)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/core/operations_problem_template.jl#L8-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.RecedingHorizon" href="#PowerSimulations.RecedingHorizon"><code>PowerSimulations.RecedingHorizon</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RecedingHorizon(period::Int)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/core/feedforward.jl#L16-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.Simulation" href="#PowerSimulations.Simulation"><code>PowerSimulations.Simulation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Simulation(steps::Int
            stages::Dict{String, Stage{&lt;:AbstractOperationsProblem}}
            sequence::Union{Nothing, SimulationSequence}
            simulation_folder::String
            name::String
            internal::Union{Nothing, SimulationInternal}
            )</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/core/simulation.jl#L151-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.Simulation-Tuple{AbstractString,Dict}" href="#PowerSimulations.Simulation-Tuple{AbstractString,Dict}"><code>PowerSimulations.Simulation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Simulation(directory::AbstractString)</code></pre><p>Constructs Simulation from a serialized directory. Callers should pass any kwargs here that they passed to the original Simulation.</p><p><strong>Arguments</strong></p><ul><li><code>directory::AbstractString</code>: the directory returned from the call to serialize</li><li><code>stage_info::Dict</code>: Two-level dictionary containing stage parameters that cannot be serialized. The outer dict should be keyed by the stage name. The inner dict must contain &#39;optimizer&#39; and may contain &#39;jump_model&#39;. These should be the same values used for the original simulation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/core/simulation.jl#L182-L194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.SimulationSequence" href="#PowerSimulations.SimulationSequence"><code>PowerSimulations.SimulationSequence</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SimulationSequence(initial_time::Union{Dates.DateTime, Nothing}
                    horizons::Dict{String, Int}
                    intervals::Dict{String, &lt;:Tuple{&lt;:Dates.TimePeriod, &lt;:FeedForwardChronology}}
                    order::Dict{Int, String}
                    feedforward_chronologies::Dict{Pair{String, String}, &lt;:FeedForwardChronology}
                    feedforward::Dict{Tuple{String, Symbol, Symbol}, &lt;:AbstractAffectFeedForward}
                    ini_cond_chronology::Dict{String, &lt;:FeedForwardChronology}
                    cache::Dict{String, AbstractCache}
                    )</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/core/simulation_sequence.jl#L158-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.Stage" href="#PowerSimulations.Stage"><code>PowerSimulations.Stage</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Stage({M&lt;:AbstractOperationsProblem}
    template::OperationsProblemTemplate
    sys::PSY.System
    optimizer::JuMP.MOI.OptimizerWithAttributes
    internal::Union{Nothing, StageInternal}
    )</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/core/simulation_stages.jl#L30-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.Stage-Union{Tuple{M}, Tuple{Type{M},OperationsProblemTemplate,PowerSystems.System,MathOptInterface.OptimizerWithAttributes}, Tuple{Type{M},OperationsProblemTemplate,PowerSystems.System,MathOptInterface.OptimizerWithAttributes,Union{Nothing, JuMP.AbstractModel}}} where M&lt;:PowerSimulations.AbstractOperationsProblem" href="#PowerSimulations.Stage-Union{Tuple{M}, Tuple{Type{M},OperationsProblemTemplate,PowerSystems.System,MathOptInterface.OptimizerWithAttributes}, Tuple{Type{M},OperationsProblemTemplate,PowerSystems.System,MathOptInterface.OptimizerWithAttributes,Union{Nothing, JuMP.AbstractModel}}} where M&lt;:PowerSimulations.AbstractOperationsProblem"><code>PowerSimulations.Stage</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Stage(::Type{M},
template::OperationsProblemTemplate,
sys::PSY.System,
optimizer::JuMP.MOI.OptimizerWithAttributes,
jump_model::Union{Nothing, JuMP.AbstractModel}=nothing;
kwargs...) where {M&lt;:AbstractOperationsProblem}</code></pre><p>This builds the optimization problem of type M with the specific system and template for the simulation stage</p><p><strong>Arguments</strong></p><ul><li><code>::Type{M} where M&lt;:AbstractOperationsProblem</code>: The abstract operation model type</li><li><code>template::OperationsProblemTemplate</code>: The model reference made up of transmission, devices,                                         branches, and services.</li><li><code>sys::PSY.System</code>: the system created using Power Systems</li><li><code>jump_model::Union{Nothing, JuMP.AbstractModel}</code>: Enables passing a custom JuMP model. Use with care</li></ul><p><strong>Output</strong></p><ul><li><code>Stage::Stage</code>: The operation model containing the model type, unbuilt JuMP model, Power</li></ul><p>Systems system.</p><p><strong>Example</strong></p><pre><code class="language-julia">template = OperationsProblemTemplate(CopperPlatePowerModel, devices, branches, services)
stage = Stage(MyOpProblemType template, system, optimizer)</code></pre><p><strong>Accepted Key Words</strong></p><ul><li><code>initial_time::Dates.DateTime</code>: Initial Time for the model solve</li><li><code>PTDF::PTDF</code>: Passes the PTDF matrix into the optimization model for StandardPTDFModel networks.</li><li><code>warm_start::Bool</code> True will use the current operation point in the system to initialize variable values. False initializes all variables to zero. Default is true</li><li><code>slack_variables::Bool</code> True will add slacks to the system balance constraints</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/core/simulation_stages.jl#L66-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.Synchronize" href="#PowerSimulations.Synchronize"><code>PowerSimulations.Synchronize</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Synchronize(periods::Int)</code></pre><p>Defines the co-ordination of time between Two stages.</p><p><strong>Arguments</strong></p><ul><li><code>periods::Int</code>: Number of time periods to grab data from</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/core/feedforward.jl#L2-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.TimeStatusChange" href="#PowerSimulations.TimeStatusChange"><code>PowerSimulations.TimeStatusChange</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Tracks the last time status of a device changed in a simulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/core/cache.jl#L10-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.write_results-Tuple{PowerSimulations.OperationsProblemResults,String}" href="#InfrastructureSystems.write_results-Tuple{PowerSimulations.OperationsProblemResults,String}"><code>InfrastructureSystems.write_results</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">write_results(results::IS.Results, save_path::String)</code></pre><p>Exports Operational Problem Results to a path</p><p><strong>Arguments</strong></p><ul><li><code>results::OperationsProblemResults</code>: results from the simulation</li><li><code>save_path::String</code>: folder path where the files will be written</li></ul><p><strong>Accepted Key Words</strong></p><ul><li><code>file_type = CSV</code>: only CSV and featherfile are accepted</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/core/operations_problem_results.jl#L104-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.build!-Tuple{Simulation}" href="#PowerSimulations.build!-Tuple{Simulation}"><code>PowerSimulations.build!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">build!(sim::Simulation)</code></pre><p>Build the Simulation and all stages.</p><p><strong>Arguments</strong></p><ul><li><code>sim::Simulation</code>: simulation object</li><li><code>output_dir = nothing</code>: If nothing then generate a unique name.</li><li><code>recorders::Vector{Symbol} = []</code>: recorder names to register</li><li><code>console_level = Logging.Error</code>:</li><li><code>file_level = Logging.Info</code>:</li></ul><p>Throws an exception if label is passed and the directory already exists.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/core/simulation.jl#L472-L485">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.check_file_integrity-Tuple{String}" href="#PowerSimulations.check_file_integrity-Tuple{String}"><code>PowerSimulations.check_file_integrity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">check_file_integrity(path::String)</code></pre><p>Checks the hash value for each file made with the file is written with the new hash_value to verify the file hasn&#39;t been tampered with since written</p><p><strong>Arguments</strong></p><ul><li><code>path::String</code>: this is the folder path that contains the results and the check.sha256 file</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/core/simulation_results.jl#L404-L411">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.configure_logging-Tuple{}" href="#PowerSimulations.configure_logging-Tuple{}"><code>PowerSimulations.configure_logging</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">configure_logging(;
    console_level = Logging.Error,
    file_level = Logging.Info,
    filename = &quot;power-simulations.log&quot;,
)</code></pre><p>Creates console and file loggers.</p><p><strong>Note:</strong> Log messages may not be written to the file until flush() or close() is called on the returned logger.</p><p><strong>Arguments</strong></p><ul><li><code>console_level = Logging.Error</code>: level for console messages</li><li><code>file_level = Logging.Info</code>: level for file messages</li><li><code>filename::String = power-simulations.log</code>: log file</li></ul><p><strong>Example</strong></p><pre><code class="language-julia">logger = configure_logging(console_level = Logging.Info)
@info &quot;log message&quot;
close(logger)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/logging.jl#L1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,PowerSystems.System,DeviceModel{T,D},Type{S}}} where S&lt;:PowerModels.AbstractActivePowerModel where D&lt;:PowerSimulations.AbstractThermalFormulation where T&lt;:PowerSystems.ThermalGen" href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,PowerSystems.System,DeviceModel{T,D},Type{S}}} where S&lt;:PowerModels.AbstractActivePowerModel where D&lt;:PowerSimulations.AbstractThermalFormulation where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function creates the model for a full themal dispatch formulation depending on combination of devices, device<em>formulation and system</em>formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/devices_models/device_constructors/thermalgeneration_constructor.jl#L39-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,PowerSystems.System,DeviceModel{T,D},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where D&lt;:PowerSimulations.AbstractThermalFormulation where T&lt;:PowerSystems.ThermalGen" href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,PowerSystems.System,DeviceModel{T,D},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where D&lt;:PowerSimulations.AbstractThermalFormulation where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function creates the model for a full themal dispatch formulation depending on combination of devices, device<em>formulation and system</em>formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/devices_models/device_constructors/thermalgeneration_constructor.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,PowerSystems.System,DeviceModel{T,ThermalBasicUnitCommitment},Type{S}}} where S&lt;:PowerModels.AbstractActivePowerModel where T&lt;:PowerSystems.ThermalGen" href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,PowerSystems.System,DeviceModel{T,ThermalBasicUnitCommitment},Type{S}}} where S&lt;:PowerModels.AbstractActivePowerModel where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function creates the model for a full themal dispatch formulation depending on combination of devices, device<em>formulation and system</em>formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/devices_models/device_constructors/thermalgeneration_constructor.jl#L115-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,PowerSystems.System,DeviceModel{T,ThermalBasicUnitCommitment},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where T&lt;:PowerSystems.ThermalGen" href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,PowerSystems.System,DeviceModel{T,ThermalBasicUnitCommitment},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function creates the model for a full themal dispatch formulation depending on combination of devices, device<em>formulation and system</em>formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/devices_models/device_constructors/thermalgeneration_constructor.jl#L79-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,PowerSystems.System,DeviceModel{T,ThermalRampLimited},Type{S}}} where S&lt;:PowerModels.AbstractActivePowerModel where T&lt;:PowerSystems.ThermalGen" href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,PowerSystems.System,DeviceModel{T,ThermalRampLimited},Type{S}}} where S&lt;:PowerModels.AbstractActivePowerModel where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function creates the model for a full themal dispatch formulation depending on combination of devices, device<em>formulation and system</em>formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/devices_models/device_constructors/thermalgeneration_constructor.jl#L184-L186">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,PowerSystems.System,DeviceModel{T,ThermalRampLimited},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where T&lt;:PowerSystems.ThermalGen" href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,PowerSystems.System,DeviceModel{T,ThermalRampLimited},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function creates the model for a full themal dispatch formulation depending on combination of devices, device<em>formulation and system</em>formulation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/devices_models/device_constructors/thermalgeneration_constructor.jl#L149-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.get_all_constraint_index-Tuple{OperationsProblem}" href="#PowerSimulations.get_all_constraint_index-Tuple{OperationsProblem}"><code>PowerSimulations.get_all_constraint_index</code></a> — <span class="docstring-category">Method</span></header><section><div><p>&quot;Each Tuple corresponds to (con<em>name, internal</em>index, moi_index)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/core/operations_problem.jl#L539">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.get_all_var_index-Tuple{OperationsProblem}" href="#PowerSimulations.get_all_var_index-Tuple{OperationsProblem}"><code>PowerSimulations.get_all_var_index</code></a> — <span class="docstring-category">Method</span></header><section><div><p>&quot;Each Tuple corresponds to (con<em>name, internal</em>index, moi_index)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/core/operations_problem.jl#L551">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.list_simulation_events-Union{Tuple{T}, Tuple{Type{T},AbstractString}, Tuple{Type{T},AbstractString,Union{Nothing, Function}}} where T&lt;:InfrastructureSystems.AbstractRecorderEvent" href="#PowerSimulations.list_simulation_events-Union{Tuple{T}, Tuple{Type{T},AbstractString}, Tuple{Type{T},AbstractString,Union{Nothing, Function}}} where T&lt;:InfrastructureSystems.AbstractRecorderEvent"><code>PowerSimulations.list_simulation_events</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">list_simulation_events(
    ::Type{T},
    output_dir::AbstractString,
    filter_func::Union{Nothing, Function} = nothing;
    step = nothing,
    stage = nothing,
) where {T &lt;: IS.AbstractRecorderEvent}</code></pre><p>List simulation events of type T in a simulation output directory.</p><p><strong>Arguments</strong></p><ul><li><code>output_dir::AbstractString</code>: Simulation output directory</li><li><code>filter_func::Union{Nothing, Function} = nothing</code>: Refer to <a href="#PowerSimulations.show_simulation_events-Union{Tuple{T}, Tuple{Type{T},AbstractString}, Tuple{Type{T},AbstractString,Union{Nothing, Function}}} where T&lt;:InfrastructureSystems.AbstractRecorderEvent"><code>show_simulation_events</code></a>.</li><li><code>step::Int = nothing</code>: Filter events by step. Required if stage is passed.</li><li><code>stage::Int = nothing</code>: Filter events by stage.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/core/recorder_events.jl#L126-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.load_operation_results-Tuple{AbstractString}" href="#PowerSimulations.load_operation_results-Tuple{AbstractString}"><code>PowerSimulations.load_operation_results</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">results = load_operation_results(path)</code></pre><p>This function can be used to load results from a folder of results from a single-step problem, or for a single foulder within a simulation.</p><p><strong>Arguments</strong></p><ul><li><code>path::AbstractString = folder path</code></li><li><code>directory::AbstractString = &quot;2019-10-03T09-18-00&quot;</code>: the foulder name that contains</li></ul><p>feather files of the results.</p><p><strong>Example</strong></p><pre><code class="language-julia">results = load_operation_results(&quot;/Users/test/2019-10-03T09-18-00&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/core/operations_problem_results.jl#L36-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.load_simulation_results-Tuple{SimulationResultsReference,String}" href="#PowerSimulations.load_simulation_results-Tuple{SimulationResultsReference,String}"><code>PowerSimulations.load_simulation_results</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">load_simulation_results(sim_output, stage)</code></pre><p>This function goes through the reference table of file paths and aggregates the results over time into a struct of type OperationsProblemResults</p><p><strong>Arguments</strong></p><ul><li><code>sim_output::SimulationResultsReference</code>: the container for the reference dictionary created in execute!</li><li><code>stage_number::String</code>: The stage of the results getting parsed</li></ul><p><strong>Example</strong></p><pre><code class="language-julia">sim_output = execute!(simulation)
results = load_simulation_results(sim_output, &quot;stage_name&quot;)</code></pre><p><strong>Accepted Key Words</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/core/simulation_results.jl#L338-L354">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.load_simulation_results-Tuple{String,String,Vararg{Any,N} where N}" href="#PowerSimulations.load_simulation_results-Tuple{String,String,Vararg{Any,N} where N}"><code>PowerSimulations.load_simulation_results</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">load_simulation_results(file_path, stage)</code></pre><p>This function goes through the reference table of file paths and aggregates the results over time into a struct of type OperationsProblemResults</p><p><strong>Arguments</strong></p><ul><li><code>file_path::String</code>: the file path to the dated folder with the raw results</li><li><code>stage_number::String</code>: The stage of the results getting parsed</li></ul><p><strong>Example</strong></p><pre><code class="language-julia">execute!(simulation)
results = load_simulation_results(&quot;file_path&quot;, &quot;stage_name&quot;)</code></pre><p><strong>Accepted Key Words</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/core/simulation_results.jl#L317-L333">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.make_references-Tuple{Simulation,String}" href="#PowerSimulations.make_references-Tuple{Simulation,String}"><code>PowerSimulations.make_references</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">make_references(sim::Simulation, date_run::String; kwargs...)</code></pre><p>Creates a dictionary of variables with a dictionary of stages that contains dataframes of date/step/and desired file path so that the results can be parsed sequentially by variable and stage type.</p><p><strong>Note:</strong> make<em>references can only be run after run</em>sim_model or else, the folder structure will not yet be populated with results</p><p><strong>Arguments</strong></p><ul><li><code>sim::Simulation = sim</code>: simulation object created by Simulation()</li><li><code>date_run::String = &quot;2019-10-03T09-18-00&quot;</code>`: the name of the file created</li></ul><p>that contains the specific simulation run of the date run and &quot;-test&quot;</p><p><strong>Example</strong></p><pre><code class="language-julia">sim = Simulation(&quot;Test&quot;, 7, stages, &quot;/Users/yourusername/Desktop/&quot;; system_to_file = false)
execute!(sim::Simulation; kwargs...)
references = make_references(sim, &quot;2019-10-03T09-18-00-test&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/core/simulation_results.jl#L46-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.show_recorder_events-Union{Tuple{T}, Tuple{Type{T},AbstractString}, Tuple{Type{T},AbstractString,Union{Nothing, Function}}} where T&lt;:InfrastructureSystems.AbstractRecorderEvent" href="#PowerSimulations.show_recorder_events-Union{Tuple{T}, Tuple{Type{T},AbstractString}, Tuple{Type{T},AbstractString,Union{Nothing, Function}}} where T&lt;:InfrastructureSystems.AbstractRecorderEvent"><code>PowerSimulations.show_recorder_events</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">show_recorder_events(
    ::Type{T},
    filename::AbstractString,
    filter_func::Union{Nothing, Function} = nothing;
    wall_time = false,
    kwargs...,
) where {T &lt;: IS.AbstractRecorderEvent}</code></pre><p>Show the events of type T in a recorder file.</p><p><strong>Arguments</strong></p><ul><li><code>::Type{T}</code>: Recorder event type</li><li><code>filename::AbstractString</code>: recorder filename</li><li><code>filter_func::Union{Nothing, Function} = nothing</code>: Optional function that accepts an event  of type T and returns a Bool. Apply this function to each event and only return events  where the result is true.</li><li><code>wall_time = false</code>: If true, show the wall_time timestamp.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/core/recorder_events.jl#L267-L285">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.show_simulation_events-Union{Tuple{T}, Tuple{Type{T},AbstractString}, Tuple{Type{T},AbstractString,Union{Nothing, Function}}} where T&lt;:InfrastructureSystems.AbstractRecorderEvent" href="#PowerSimulations.show_simulation_events-Union{Tuple{T}, Tuple{Type{T},AbstractString}, Tuple{Type{T},AbstractString,Union{Nothing, Function}}} where T&lt;:InfrastructureSystems.AbstractRecorderEvent"><code>PowerSimulations.show_simulation_events</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">show_simulation_events(
    ::Type{T},
    output_dir::AbstractString,
    filter_func::Union{Nothing,Function} = nothing;
    step = nothing,
    stage = nothing,
    wall_time = false,
    kwargs...,
) where { T &lt;: IS.AbstractRecorderEvent}</code></pre><p>Show all simulation events of type T in a simulation output directory.</p><p><strong>Arguments</strong></p><ul><li><code>::Type{T}</code>: Recorder event type</li><li><code>output_dir::AbstractString</code>: Simulation output directory</li><li><code>filter_func::Union{Nothing, Function} = nothing</code>: Refer to <a href="#PowerSimulations.show_recorder_events-Union{Tuple{T}, Tuple{Type{T},AbstractString}, Tuple{Type{T},AbstractString,Union{Nothing, Function}}} where T&lt;:InfrastructureSystems.AbstractRecorderEvent"><code>show_recorder_events</code></a>.</li><li><code>step::Int = nothing</code>: Filter events by step. Required if stage is passed.</li><li><code>stage::Int = nothing</code>: Filter events by stage.</li><li><code>wall_time = false</code>: If true, show the wall_time timestamp.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/core/recorder_events.jl#L182-L202">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.solve!-Union{Tuple{OperationsProblem{T}}, Tuple{T}} where T&lt;:PowerSimulations.AbstractOperationsProblem" href="#PowerSimulations.solve!-Union{Tuple{OperationsProblem{T}}, Tuple{T}} where T&lt;:PowerSimulations.AbstractOperationsProblem"><code>PowerSimulations.solve!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">solve!(op_problem::OperationsProblem; kwargs...)</code></pre><p>This solves the operational model for a single instance and outputs results of type OperationsProblemResult</p><p><strong>Arguments</strong></p><ul><li><code>op_problem::OperationModel = op_problem</code>: operation model</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">results = solve!(OpModel)</code></pre><p><strong>Accepted Key Words</strong></p><ul><li><code>save_path::String</code>: If a file path is provided the results</li></ul><p>automatically get written to feather files</p><ul><li><code>optimizer::MOI.OptimizerWithAttributes</code>: The optimizer that is used to solve the model</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/core/operations_problem.jl#L411-L425">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.template_economic_dispatch-Tuple{}" href="#PowerSimulations.template_economic_dispatch-Tuple{}"><code>PowerSimulations.template_economic_dispatch</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">template_economic_dispatch(; kwargs...)</code></pre><p>Creates an <code>OperationsProblemTemplate</code> with default DeviceModels for an Economic Dispatch problem.</p><p><strong>Example</strong></p><pre><code class="language-julia">template = template_economic_dispatch()</code></pre><p><strong>Accepted Key Words</strong></p><ul><li><code>network::Type{&lt;:PM.AbstractPowerModel}</code> : override default network model settings</li><li><code>devices::Dict{Symbol, DeviceModel}</code> : override default <code>DeviceModel</code> settings</li><li><code>branches::Dict{Symbol, DeviceModel}</code> : override default <code>DeviceModel</code> settings</li><li><code>services::Dict{Symbol, ServiceModel}</code> : override default <code>ServiceModel</code> settings</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/operations_problems_templates.jl#L70-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.template_unit_commitment-Tuple{}" href="#PowerSimulations.template_unit_commitment-Tuple{}"><code>PowerSimulations.template_unit_commitment</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">template_unit_commitment(; kwargs...)</code></pre><p>Creates an <code>OperationsProblemTemplate</code> with default DeviceModels for a Unit Commitment problem.</p><p><strong>Example</strong></p><pre><code class="language-julia">template = template_unit_commitment()</code></pre><p><strong>Accepted Key Words</strong></p><ul><li><code>network::Type{&lt;:PM.AbstractPowerModel}</code> : override default network model settings</li><li><code>devices::Dict{Symbol, DeviceModel}</code> : override default <code>DeviceModel</code> settings</li><li><code>branches::Dict{Symbol, DeviceModel}</code> : override default <code>DeviceModel</code> settings</li><li><code>services::Dict{Symbol, ServiceModel}</code> : override default <code>ServiceModel</code> settings</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/operations_problems_templates.jl#L48-L64">source</a></section></article><h2 id="Internal-1"><a class="docs-heading-anchor" href="#Internal-1">Internal</a><a class="docs-heading-anchor-permalink" href="#Internal-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.AbstractSimulationStatusEvent" href="#PowerSimulations.AbstractSimulationStatusEvent"><code>PowerSimulations.AbstractSimulationStatusEvent</code></a> — <span class="docstring-category">Type</span></header><section><div><p>All events subtyped from this need to be recorded under :simulation_status.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/core/recorder_events.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.DeviceRange" href="#PowerSimulations.DeviceRange"><code>PowerSimulations.DeviceRange</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Data Container to construct range constraints</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/devices_models/devices/common/constraints_structs.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.UpdateRef" href="#PowerSimulations.UpdateRef"><code>PowerSimulations.UpdateRef</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Reference for parameters update when present</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/core/aux_structs.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.show-Tuple{IO,MIME{Symbol(&quot;text/plain&quot;)},OperationsProblem}" href="#Base.show-Tuple{IO,MIME{Symbol(&quot;text/plain&quot;)},OperationsProblem}"><code>Base.show</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.show(io::IO, ::MIME&quot;text/plain&quot;, op_problem::OperationsProblem)</code></pre><p>This function goes through the fields in OperationsProblem and then in OperationsProblemTemplate, if the field contains a Device model dictionary, it calls organize<em>device</em>model() &amp; prints the data by field, key, value. If the field is not a Device model dictionary, and a value exists for that field it prints the value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/printing.jl#L27-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations._allocate_execution_order-Tuple{Dict{Int64,Int64}}" href="#PowerSimulations._allocate_execution_order-Tuple{Dict{Int64,Int64}}"><code>PowerSimulations._allocate_execution_order</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Function calculates the total number of stage executions in the simulation and allocates the appropiate vector</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/core/simulation_sequence.jl#L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations._calculate_interval_inner_counts-Tuple{Dict{Int64,String},Dict{String,Tuple{Dates.TimePeriod,#s96} where #s96&lt;:PowerSimulations.FeedForwardChronology},Dates.TimePeriod}" href="#PowerSimulations._calculate_interval_inner_counts-Tuple{Dict{Int64,String},Dict{String,Tuple{Dates.TimePeriod,#s96} where #s96&lt;:PowerSimulations.FeedForwardChronology},Dates.TimePeriod}"><code>PowerSimulations._calculate_interval_inner_counts</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_calculate_interval_inner_counts(order::Dict{Int,String},
                                      intervals::Dict{String,&lt;:Dates.TimePeriod},
                                      step_resolution::Dates.TimePeriod)</code></pre><p>Calculates how many times a stage is executed for every interval of the previous stage</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/core/simulation_sequence.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations._get_data_for_rocc-Tuple{Array{InitialCondition,1},Dates.TimePeriod}" href="#PowerSimulations._get_data_for_rocc-Tuple{Array{InitialCondition,1},Dates.TimePeriod}"><code>PowerSimulations._get_data_for_rocc</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function gets the data for the generators</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/devices_models/devices/thermal_generation.jl#L305-L307">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations._get_data_for_tdc-Tuple{Array{InitialCondition,1},Array{InitialCondition,1},Dates.TimePeriod}" href="#PowerSimulations._get_data_for_tdc-Tuple{Array{InitialCondition,1},Array{InitialCondition,1},Dates.TimePeriod}"><code>PowerSimulations._get_data_for_tdc</code></a> — <span class="docstring-category">Method</span></header><section><div><p>If the fraction of hours that a generator has a duration constraint is less than the fraction of hours that a single time_step represents then it is not binding.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/devices_models/devices/thermal_generation.jl#L423-L426">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations._pwl_cost-Union{Tuple{JV}, Tuple{PowerSimulations.PSIContainer,JV,Array{Tuple{Float64,Float64},1}}} where JV&lt;:JuMP.AbstractVariableRef" href="#PowerSimulations._pwl_cost-Union{Tuple{JV}, Tuple{PowerSimulations.PSIContainer,JV,Array{Tuple{Float64,Float64},1}}} where JV&lt;:JuMP.AbstractVariableRef"><code>PowerSimulations._pwl_cost</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_gen_cost(cost_)</code></pre><p>Returns JuMP expression for a piecewise linear cost function depending on the data compatibility.</p><p>Returns <code>gen_cost</code></p><p><strong>Arguments</strong></p><ul><li>psi<em>container::PSIContainer : the psi</em>container model built in PowerSimulations</li><li>variable::JuMP.Containers.DenseAxisArray{JV} : variable array</li><li>cost_component::PSY.VariableCost{NTuple{2, Float64}} : container for quadratic and linear factors</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/devices_models/devices/common/cost_functions.jl#L279-L291">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations._pwlgencost_linear-Union{Tuple{JV}, Tuple{PowerSimulations.PSIContainer,JV,Array{Tuple{Float64,Float64},1}}} where JV&lt;:JuMP.AbstractVariableRef" href="#PowerSimulations._pwlgencost_linear-Union{Tuple{JV}, Tuple{PowerSimulations.PSIContainer,JV,Array{Tuple{Float64,Float64},1}}} where JV&lt;:JuMP.AbstractVariableRef"><code>PowerSimulations._pwlgencost_linear</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_pwlgencost_sos(psi_container::PSIContainer,
            variable::JuMP.Containers.DenseAxisArray{JV},
            cost_component::PSY.VariableCost{NTuple{2, Float64}}) where {JV &lt;: JuMP.AbstractVariableRef}</code></pre><p>Returns piecewise cost expression using linear implementation for psi_container model.</p><p><strong>Equations</strong></p><p><code>0 &lt;= pwl_var[i] &lt;= (cost_component[2][i] - cost_component[2][i-1])</code></p><p><code>variable = sum(pwl_var[i])</code></p><p><code>gen_cost = sum(pwl_var[i]*cost_component[1][i]/cost_component[2][i])</code></p><p><strong>LaTeX</strong></p><p><span>$0 &lt;= pwl_i &lt;= (c_{2, i} - c_{2, i-1})$</span></p><p><span>$variable = (sum_{i\in I} pwl_i)$</span></p><p><span>$gen_cost = (sum_{i\in I}  pwl_i) c_{1, i}/c_{2, i}$</span></p><p>Returns <code>gen_cost</code></p><p><strong>Arguments</strong></p><ul><li>psi<em>container::PSIContainer : the psi</em>container model built in PowerSimulations</li><li>variable::JuMP.Containers.DenseAxisArray{JV} : variable array</li><li>cost_component::PSY.VariableCost{NTuple{2, Float64}} : container for quadratic and linear factors</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/devices_models/devices/common/cost_functions.jl#L209-L238">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations._pwlgencost_sos-Union{Tuple{JV}, Tuple{PowerSimulations.PSIContainer,JV,Array{Tuple{Float64,Float64},1}}} where JV&lt;:JuMP.AbstractVariableRef" href="#PowerSimulations._pwlgencost_sos-Union{Tuple{JV}, Tuple{PowerSimulations.PSIContainer,JV,Array{Tuple{Float64,Float64},1}}} where JV&lt;:JuMP.AbstractVariableRef"><code>PowerSimulations._pwlgencost_sos</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_pwlgencost_sos(psi_container::PSIContainer,
            variable::JuMP.Containers.DenseAxisArray{JV},
            cost_component::PSY.VariableCost{NTuple{2, Float64}}) where {JV &lt;: JuMP.AbstractVariableRef}</code></pre><p>Returns piecewise cost expression using SOS Type-2 implementation for psi_container model.</p><p><strong>Equations</strong></p><p><code>variable = sum(sos_var[i]*cost_component[2][i])</code></p><p><code>gen_cost = sum(sos_var[i]*cost_component[1][i])</code></p><p><strong>LaTeX</strong></p><p><span>$variable = (sum_{i\in I} c_{2, i} sos_i)$</span></p><p><span>$gen_cost = (sum_{i\in I} c_{1, i} sos_i)$</span></p><p>Returns <code>gen_cost</code></p><p><strong>Arguments</strong></p><ul><li>psi<em>container::PSIContainer : the psi</em>container model built in PowerSimulations</li><li>variable::JuMP.Containers.DenseAxisArray{JV} : variable array</li><li>cost_component::PSY.VariableCost{NTuple{2, Float64}} : container for quadratic and linear factors</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/devices_models/devices/common/cost_functions.jl#L150-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations._pwlparamcheck-Tuple{Any}" href="#PowerSimulations._pwlparamcheck-Tuple{Any}"><code>PowerSimulations._pwlparamcheck</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_pwlparamcheck(cost_)</code></pre><p>Returns True/False depending on compatibility of the cost data with the linear implementation method</p><p>Returns <code>flag</code></p><p><strong>Arguments</strong></p><ul><li>cost_::PSY.VariableCost{NTuple{2, Float64}} : container for quadratic and linear factors</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/devices_models/devices/common/cost_functions.jl#L121-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations._update_stage!-Tuple{Stage,Simulation}" href="#PowerSimulations._update_stage!-Tuple{Stage,Simulation}"><code>PowerSimulations._update_stage!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Required update stage function call</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/core/simulation.jl#L752">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations._write_psi_container-Tuple{PowerSimulations.PSIContainer,String}" href="#PowerSimulations._write_psi_container-Tuple{PowerSimulations.PSIContainer,String}"><code>PowerSimulations._write_psi_container</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Exports the OpModel JuMP object in MathOptFormat</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/core/psi_container.jl#L503">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.activepower_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},DeviceModel{T,#s509} where #s509&lt;:PowerSimulations.AbstractThermalDispatchFormulation,Type{#s508} where #s508&lt;:PowerModels.AbstractPowerModel,Nothing}} where T&lt;:PowerSystems.ThermalGen" href="#PowerSimulations.activepower_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},DeviceModel{T,#s509} where #s509&lt;:PowerSimulations.AbstractThermalDispatchFormulation,Type{#s508} where #s508&lt;:PowerModels.AbstractPowerModel,Nothing}} where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.activepower_constraints!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function adds the active power limits of generators when there are no CommitmentVariables</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/devices_models/devices/thermal_generation.jl#L101-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.activepower_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},DeviceModel{T,#s509} where #s509&lt;:PowerSimulations.AbstractThermalFormulation,Type{#s508} where #s508&lt;:PowerModels.AbstractPowerModel,Nothing}} where T&lt;:PowerSystems.ThermalGen" href="#PowerSimulations.activepower_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},DeviceModel{T,#s509} where #s509&lt;:PowerSimulations.AbstractThermalFormulation,Type{#s508} where #s508&lt;:PowerModels.AbstractPowerModel,Nothing}} where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.activepower_constraints!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function adds the active power limits of generators when there are CommitmentVariables</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/devices_models/devices/thermal_generation.jl#L128-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.activepower_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},DeviceModel{T,ThermalDispatchNoMin},Type{#s509} where #s509&lt;:PowerModels.AbstractPowerModel,Nothing}} where T&lt;:PowerSystems.ThermalGen" href="#PowerSimulations.activepower_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},DeviceModel{T,ThermalDispatchNoMin},Type{#s509} where #s509&lt;:PowerModels.AbstractPowerModel,Nothing}} where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.activepower_constraints!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function adds the active power limits of generators when there are     no CommitmentVariables</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/devices_models/devices/thermal_generation.jl#L156-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.activepower_variables!-Union{Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T}}} where T&lt;:PowerSystems.ThermalGen" href="#PowerSimulations.activepower_variables!-Union{Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T}}} where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.activepower_variables!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function add the variables for power generation output to the model</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/devices_models/devices/thermal_generation.jl#L12-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.activeservice_variables!-Union{Tuple{SR}, Tuple{PowerSimulations.PSIContainer,SR,Array{#s511,1} where #s511&lt;:PowerSystems.Device}} where SR&lt;:PowerSystems.Reserve" href="#PowerSimulations.activeservice_variables!-Union{Tuple{SR}, Tuple{PowerSimulations.PSIContainer,SR,Array{#s511,1} where #s511&lt;:PowerSystems.Device}} where SR&lt;:PowerSystems.Reserve"><code>PowerSimulations.activeservice_variables!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function add the variables for reserves to the model</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/services_models/reserves.jl#L4-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.add_to_cost-Union{Tuple{D}, Tuple{PowerSimulations.PSIContainer,D,Symbol,Symbol}, Tuple{PowerSimulations.PSIContainer,D,Symbol,Symbol,Float64}} where D&lt;:(InfrastructureSystems.FlattenIteratorWrapper{#s509} where #s509&lt;:PowerSystems.Device)" href="#PowerSimulations.add_to_cost-Union{Tuple{D}, Tuple{PowerSimulations.PSIContainer,D,Symbol,Symbol}, Tuple{PowerSimulations.PSIContainer,D,Symbol,Symbol,Float64}} where D&lt;:(InfrastructureSystems.FlattenIteratorWrapper{#s509} where #s509&lt;:PowerSystems.Device)"><code>PowerSimulations.add_to_cost</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_to_cost(psi_container::PSIContainer,
                 devices::D,
                 var_name::Symbol,
                 cost_symbol::Symbol,
                 sign::Float64 = 1.0) where {D&lt;:IS.FlattenIteratorWrapper{&lt;:PSY.Device}}</code></pre><p>Adds cost expression for each device using appropriate call to <code>ps_cost</code>.</p><p><strong>Expression</strong></p><p>for d in devices</p><pre><code class="language-cost_expression">                              variable[PSY.get_name(d), :],
                              getfield(PSY.get_op_cost(d), cost_symbol),
                              dt,
                              sign) ```</code></pre><p>psi<em>container.cost</em>function += cost_expression ```</p><p><strong>LaTeX</strong></p><p><span>$COST = \sum_{d\in D} cost_d$</span></p><p><strong>Arguments</strong></p><ul><li>psi<em>container::PSIContainer : the psi</em>container model built in PowerSimulations</li><li>devices::D : set of devices</li><li>var_name::Symbol : name of variable</li><li>cost_symbol::Symbol : symbol associated with costx</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/devices_models/devices/common/cost_functions.jl#L359-L389">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.add_variable-Union{Tuple{D}, Tuple{PowerSimulations.PSIContainer,D,Symbol,Bool}, Tuple{PowerSimulations.PSIContainer,D,Symbol,Bool,Union{Nothing, Symbol}}, Tuple{PowerSimulations.PSIContainer,D,Symbol,Bool,Union{Nothing, Symbol},Float64}} where D&lt;:Union{Array{#s35,1} where #s35&lt;:PowerSystems.Device, InfrastructureSystems.FlattenIteratorWrapper{#s34} where #s34&lt;:PowerSystems.Device}" href="#PowerSimulations.add_variable-Union{Tuple{D}, Tuple{PowerSimulations.PSIContainer,D,Symbol,Bool}, Tuple{PowerSimulations.PSIContainer,D,Symbol,Bool,Union{Nothing, Symbol}}, Tuple{PowerSimulations.PSIContainer,D,Symbol,Bool,Union{Nothing, Symbol},Float64}} where D&lt;:Union{Array{#s35,1} where #s35&lt;:PowerSystems.Device, InfrastructureSystems.FlattenIteratorWrapper{#s34} where #s34&lt;:PowerSystems.Device}"><code>PowerSimulations.add_variable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_variable(psi_container::PSIContainer,
                  devices::D,
                  var_name::Symbol,
                  binary::Bool,
                  expression_name::Symbol,
                  sign::Float64)</code></pre><p>Adds a variable to the optimization model and to the affine expressions contained in the psi_container model according to the specified sign. Based on the inputs, the variable can be specified as binary.</p><p><strong>Bounds</strong></p><p><code>lb_value_function &lt;= varstart[name, t] &lt;= ub_value_function</code></p><p>If binary = true:</p><p><code>varstart[name, t] in {0,1}</code></p><p><strong>LaTeX</strong></p><p><span>$lb \ge x^{device}_t \le ub \forall t$</span></p><p><span>$x^{device}_t \in {0,1} \forall t iff \text{binary = true}$</span></p><p><strong>Arguments</strong></p><ul><li>psi<em>container::PSIContainer : the psi</em>container model built in PowerSimulations</li><li>devices : Vector or Iterator with the devices</li><li>var_name::Symbol : Base Name for the variable</li><li>binary::Bool : Select if the variable is binary</li><li>expression<em>name::Symbol : Expression</em>name name stored in psi_container.expressions to add the variable</li><li>sign::Float64 : sign of the addition of the variable to the expression_name. Default Value is 1.0</li></ul><p><strong>Accepted Keyword Arguments</strong></p><ul><li>ub<em>value</em>function : Provides the function over device to obtain the value for a upper_bound</li><li>lb<em>value</em>function : Provides the function over device to obtain the value for a lower_bound. If the variable is meant to be positive define lb = x -&gt; 0.0</li><li>initial<em>value</em>function : Provides the function over device to obtain the warm start value</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/devices_models/devices/common/add_variable.jl#L1-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.build_nip-Tuple{PowerModels.AbstractPowerModel}" href="#PowerSimulations.build_nip-Tuple{PowerModels.AbstractPowerModel}"><code>PowerSimulations.build_nip</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/network_models/powermodels_interface.jl#L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.commitment_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},DeviceModel{T,D},Type{S},Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S&lt;:PowerModels.AbstractPowerModel where D&lt;:PowerSimulations.AbstractThermalFormulation where T&lt;:PowerSystems.ThermalGen" href="#PowerSimulations.commitment_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},DeviceModel{T,D},Type{S},Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S&lt;:PowerModels.AbstractPowerModel where D&lt;:PowerSimulations.AbstractThermalFormulation where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.commitment_constraints!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function adds the Commitment Status constraint when there are CommitmentVariables</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/devices_models/devices/thermal_generation.jl#L254-L256">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.commitment_variables!-Union{Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T}}} where T&lt;:PowerSystems.ThermalGen" href="#PowerSimulations.commitment_variables!-Union{Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T}}} where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.commitment_variables!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function add the variables for power generation commitment to the model</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/devices_models/devices/thermal_generation.jl#L62-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.compute_sha256-Tuple{AbstractString}" href="#PowerSimulations.compute_sha256-Tuple{AbstractString}"><code>PowerSimulations.compute_sha256</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the SHA 256 hash of a file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/utils.jl#L10-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.constraint_power_balance_ni-Tuple{PowerModels.AbstractActivePowerModel,Int64,Int64,Any,Any}" href="#PowerSimulations.constraint_power_balance_ni-Tuple{PowerModels.AbstractActivePowerModel,Int64,Int64,Any,Any}"><code>PowerSimulations.constraint_power_balance_ni</code></a> — <span class="docstring-category">Method</span></header><section><div><p>active power only models ignore reactive power flows</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/network_models/powermodels_interface.jl#L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.constraint_power_balance_ni-Tuple{PowerModels.AbstractPowerModel,Int64,Int64,Any,Any}" href="#PowerSimulations.constraint_power_balance_ni-Tuple{PowerModels.AbstractPowerModel,Int64,Int64,Any,Any}"><code>PowerSimulations.constraint_power_balance_ni</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/network_models/powermodels_interface.jl#L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.constraint_power_balance_ni-Tuple{PowerModels.AbstractPowerModel,Int64}" href="#PowerSimulations.constraint_power_balance_ni-Tuple{PowerModels.AbstractPowerModel,Int64}"><code>PowerSimulations.constraint_power_balance_ni</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/network_models/powermodels_interface.jl#L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.constraint_power_balance_ni_expr-Tuple{PowerModels.AbstractActivePowerModel,Int64,Int64,Any,Any,Any,Any}" href="#PowerSimulations.constraint_power_balance_ni_expr-Tuple{PowerModels.AbstractActivePowerModel,Int64,Int64,Any,Any,Any,Any}"><code>PowerSimulations.constraint_power_balance_ni_expr</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/network_models/powermodels_interface.jl#L258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.constraint_power_balance_ni_expr-Tuple{PowerModels.AbstractPowerModel,Int64,Int64,Any,Any,Any,Any}" href="#PowerSimulations.constraint_power_balance_ni_expr-Tuple{PowerModels.AbstractPowerModel,Int64,Int64,Any,Any,Any,Any}"><code>PowerSimulations.constraint_power_balance_ni_expr</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/network_models/powermodels_interface.jl#L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.constraint_power_balance_ni_expr-Tuple{PowerModels.AbstractPowerModel,Int64}" href="#PowerSimulations.constraint_power_balance_ni_expr-Tuple{PowerModels.AbstractPowerModel,Int64}"><code>PowerSimulations.constraint_power_balance_ni_expr</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/network_models/powermodels_interface.jl#L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.container_spec-Union{Tuple{M}, Tuple{M,Vararg{Any,N} where N}} where M&lt;:JuMP.AbstractModel" href="#PowerSimulations.container_spec-Union{Tuple{M}, Tuple{M,Vararg{Any,N} where N}} where M&lt;:JuMP.AbstractModel"><code>PowerSimulations.container_spec</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns the correct container spec for the selected type of JuMP Model</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/utils.jl#L255">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_commitment-Tuple{PowerSimulations.PSIContainer,Array{InitialCondition,1},Symbol,Tuple{Symbol,Symbol,Symbol}}" href="#PowerSimulations.device_commitment-Tuple{PowerSimulations.PSIContainer,Array{InitialCondition,1},Symbol,Tuple{Symbol,Symbol,Symbol}}"><code>PowerSimulations.device_commitment</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">device_commitment(psi_container::PSIContainer,
                    initial_conditions::Vector{InitialCondition},
                    cons_name::Symbol,
                    var_names::Tuple{Symbol, Symbol, Symbol})</code></pre><p>Constructs multi-timestep constraint from initial conditions and binary variable tuple.</p><p><strong>Constraints</strong></p><p><code>varstart + varstop &lt;= 1.0</code></p><p>If t = 1:</p><p><code>varon[name, 1] == ic.value + varstart[name, 1] - varstop[name, 1]</code></p><p>where ic in initial_condtions.</p><p>If t &gt; 1:</p><p><code>varon[name, t] == varon[name, t-1] + varstart[name, t] - varstop[name, t]</code></p><p><strong>LaTeX</strong></p><p><span>$x^{on}_t + x^{off}_t \leq 1.0 \forall t$</span></p><p><span>$x^{on}_1 = x^{on}_{init} + x^{start}_1 - x^{stop}_1, \text{ for } t = 1$</span></p><p><span>$x^{on}_t = x^{on}_{t-1} + x^{start}_t - x^{stop}_t, \forall t \geq 2$</span></p><p><strong>Arguments</strong></p><ul><li>psi<em>container::PSIContainer : the psi</em>container model built in PowerSimulations</li><li>initial_conditions::Vector{InitialCondition} : for time zero &#39;varon&#39;</li><li>cons_name::Symbol : name of the constraint</li><li>var_names::Tuple{Symbol, Symbol, Symbol} : the names of the variables</li><li>: var_names[1] : varstart</li><li>: var_names[2] : varstop</li><li>: var_names[3] : varon</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/devices_models/devices/common/commitment_constraint.jl#L1-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_duration_look_ahead-Tuple{PowerSimulations.PSIContainer,Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{InitialCondition,2},Symbol,Tuple{Symbol,Symbol,Symbol}}" href="#PowerSimulations.device_duration_look_ahead-Tuple{PowerSimulations.PSIContainer,Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{InitialCondition,2},Symbol,Tuple{Symbol,Symbol,Symbol}}"><code>PowerSimulations.device_duration_look_ahead</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">device_duration_look_ahead(psi_container::PSIContainer,
                            duration_data::Vector{UpDown},
                            initial_duration::Matrix{InitialCondition},
                            cons_name::Symbol,
                            var_names::Tuple{Symbol, Symbol, Symbol})</code></pre><p>This formulation of the duration constraints looks ahead in the time frame of the model.</p><p><strong>LaTeX</strong></p><ul><li>Minimum up-time constraint:</li></ul><p>If <span>$t \leq d_{min}^{up}$</span></p><p><span>$d_{min}^{down}x_t^{stop} - \sum_{i=t-d_{min}^{up} + 1}^t x_i^{on} - x_{init}^{up} \leq 0$</span></p><p>for i in the set of time steps. Otherwise:</p><p><span>$d_{min}^{down}x_t^{stop} - \sum_{i=t-d_{min}^{up} + 1}^t x_i^{on} \leq 0$</span></p><p>for i in the set of time steps.</p><ul><li>Minimum down-time constraint:</li></ul><p>If <span>$t \leq d_{min}^{down}$</span></p><p><span>$d_{min}^{up}x_t^{start} - \sum_{i=t-d_{min^{down} + 1}^t (1 - x_i^{on}) - x_{init}^{down} \leq 0$</span></p><p>for i in the set of time steps. Otherwise:</p><p><span>$d_{min}^{up}x_t^{start} - \sum_{i=t-d_{min^{down} + 1}^t (1 - x_i^{on}) \leq 0$</span></p><p>for i in the set of time steps.</p><p><strong>Arguments</strong></p><ul><li>psi<em>container::PSIContainer : the psi</em>container model built in PowerSimulations</li><li>duration_data::Vector{UpDown} : gives how many time steps variable needs to be up or down</li><li>initial_duration::Matrix{InitialCondition} : gives initial conditions for up (column 1) and down (column 2)</li><li>cons_name::Symbol : name of the constraint</li><li>var_names::Tuple{Symbol, Symbol, Symbol}) : names of the variables</li><li>: var_names[1] : varon</li><li>: var_names[2] : varstart</li><li>: var_names[3] : varstop</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/devices_models/devices/common/duration_constraints.jl#L102-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_duration_parameters-Tuple{PowerSimulations.PSIContainer,Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{InitialCondition,2},Symbol,Tuple{Symbol,Symbol,Symbol}}" href="#PowerSimulations.device_duration_parameters-Tuple{PowerSimulations.PSIContainer,Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{InitialCondition,2},Symbol,Tuple{Symbol,Symbol,Symbol}}"><code>PowerSimulations.device_duration_parameters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">device_duration_parameters(psi_container::PSIContainer,
                         duration_data::Vector{UpDown},
                         initial_duration_on::Vector{InitialCondition},
                         initial_duration_off::Vector{InitialCondition},
                         cons_name::Symbol,
                         var_names::Tuple{Symbol, Symbol, Symbol})</code></pre><p>This formulation of the duration constraints considers parameters.</p><p><strong>LaTeX</strong></p><ul><li>Minimum up-time constraint:</li></ul><p>If <span>$t \leq d_{min}^{up}$</span></p><p><span>$d_{min}^{down}x_t^{stop} - \sum_{i=t-d_{min}^{up} + 1}^t x_i^{on} - x_{init}^{up} \leq 0$</span></p><p>for i in the set of time steps. Otherwise:</p><p><span>$\sum_{i=t-d_{min}^{up} + 1}^t x_i^{start} - x_t^{on} \leq 0$</span></p><p>for i in the set of time steps.</p><ul><li>Minimum down-time constraint:</li></ul><p>If <span>$t \leq d_{min}^{down}$</span></p><p><span>$d_{min}^{up}x_t^{start} - \sum_{i=t-d_{min^{down} + 1}^t (1 - x_i^{on}) - x_{init}^{down} \leq 0$</span></p><p>for i in the set of time steps. Otherwise:</p><p><span>$\sum_{i=t-d_{min}^{down} + 1}^t x_i^{stop} + x_t^{on} \leq 1$</span></p><p>for i in the set of time steps.</p><p><strong>Arguments</strong></p><ul><li>psi<em>container::PSIContainer : the psi</em>container model built in PowerSimulations</li><li>duration_data::Vector{UpDown} : gives how many time steps variable needs to be up or down</li><li>initial<em>duration</em>on::Vector{InitialCondition} : gives initial number of time steps variable is up</li><li>initial<em>duration</em>off::Vector{InitialCondition} : gives initial number of time steps variable is down</li><li>cons_name::Symbol : name of the constraint</li><li>var_names::Tuple{Symbol, Symbol, Symbol}) : names of the variables</li><li>: var_names[1] : varon</li><li>: var_names[2] : varstart</li><li>: var_names[3] : varstop</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/devices_models/devices/common/duration_constraints.jl#L208-L255">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_duration_retrospective-Tuple{PowerSimulations.PSIContainer,Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{InitialCondition,2},Symbol,Tuple{Symbol,Symbol,Symbol}}" href="#PowerSimulations.device_duration_retrospective-Tuple{PowerSimulations.PSIContainer,Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{InitialCondition,2},Symbol,Tuple{Symbol,Symbol,Symbol}}"><code>PowerSimulations.device_duration_retrospective</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">device_duration_retrospective(psi_container::PSIContainer,
                                    duration_data::Vector{UpDown},
                                    initial_duration::Matrix{InitialCondition},
                                    cons_name::Symbol,
                                    var_names::Tuple{Symbol, Symbol, Symbol})</code></pre><p>This formulation of the duration constraints adds over the start times looking backwards.</p><p><strong>LaTeX</strong></p><ul><li>Minimum up-time constraint:</li></ul><p>If <span>$t \leq d_{min}^{up} - d_{init}^{up}$</span> and <span>$d_{init}^{up} &gt; 0$</span></p><p><span>$1 + \sum_{i=t-d_{min}^{up} + 1}^t x_i^{start} - x_t^{on} \leq 0$</span></p><p>for i in the set of time steps. Otherwise:</p><p><span>$\sum_{i=t-d_{min}^{up} + 1}^t x_i^{start} - x_t^{on} \leq 0$</span></p><p>for i in the set of time steps.</p><ul><li>Minimum down-time constraint:</li></ul><p>If <span>$t \leq d_{min}^{down} - d_{init}^{down}$</span> and <span>$d_{init}^{down} &gt; 0$</span></p><p><span>$1 + \sum_{i=t-d_{min}^{down} + 1}^t x_i^{stop} + x_t^{on} \leq 1$</span></p><p>for i in the set of time steps. Otherwise:</p><p><span>$\sum_{i=t-d_{min}^{down} + 1}^t x_i^{stop} + x_t^{on} \leq 1$</span></p><p>for i in the set of time steps.</p><p><strong>Arguments</strong></p><ul><li>psi<em>container::PSIContainer : the psi</em>container model built in PowerSimulations</li><li>duration_data::Vector{UpDown} : gives how many time steps variable needs to be up or down</li><li>initial_duration::Matrix{InitialCondition} : gives initial conditions for up (column 1) and down (column 2)</li><li>cons_name::Symbol : name of the constraint</li><li>var_names::Tuple{Symbol, Symbol, Symbol}) : names of the variables</li><li>: var_names[1] : varon</li><li>: var_names[2] : varstart</li><li>: var_names[3] : varstop</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/devices_models/devices/common/duration_constraints.jl#L1-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_linear_rateofchange-Tuple{PowerSimulations.PSIContainer,Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{InitialCondition,1},Symbol,Symbol}" href="#PowerSimulations.device_linear_rateofchange-Tuple{PowerSimulations.PSIContainer,Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{InitialCondition,1},Symbol,Symbol}"><code>PowerSimulations.device_linear_rateofchange</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">device_linear_rateofchange(psi_container::PSIContainer,
                                rate_data::Tuple{Vector{String}, Vector{UpDown}},
                                initial_conditions::Vector{InitialCondition},
                                cons_name::Symbol,
                                var_name::Symbol)</code></pre><p>Constructs allowed rate-of-change constraints from variables, initial condtions, and rate data.</p><p><strong>Constraints</strong></p><p>If t = 1:</p><p><code>variable[name, 1] - initial_conditions[ix].value &lt;= rate_data[1][ix].up</code></p><p><code>initial_conditions[ix].value - variable[name, 1] &lt;= rate_data[1][ix].down</code></p><p>If t &gt; 1:</p><p><code>variable[name, t] - variable[name, t-1] &lt;= rate_data[1][ix].up</code></p><p><code>variable[name, t-1] - variable[name, t] &lt;= rate_data[1][ix].down</code></p><p><strong>LaTeX</strong></p><p><span>$r^{down} \leq x_1 - x_{init} \leq r^{up}, \text{ for } t = 1$</span></p><p><span>$r^{down} \leq x_t - x_{t-1} \leq r^{up}, \forall t \geq 2$</span></p><p><strong>Arguments</strong></p><ul><li>psi<em>container::PSIContainer : the psi</em>container model built in PowerSimulations</li><li>rate_data::Tuple{Vector{String}, Vector{UpDown}} : gives name (1) and max ramp up/down rates (2)</li><li>initial_conditions::Vector{InitialCondition} : for time zero &#39;variable&#39;</li><li>cons_name::Symbol : name of the constraint</li><li>var_name::Tuple{Symbol, Symbol, Symbol} : the name of the variable</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/devices_models/devices/common/rateofchange_constraints.jl#L1-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_mixedinteger_rateofchange-Tuple{PowerSimulations.PSIContainer,Tuple{Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{NamedTuple{(:min, :max),Tuple{Float64,Float64}},1}},Array{InitialCondition,1},Symbol,Tuple{Symbol,Symbol,Symbol}}" href="#PowerSimulations.device_mixedinteger_rateofchange-Tuple{PowerSimulations.PSIContainer,Tuple{Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{NamedTuple{(:min, :max),Tuple{Float64,Float64}},1}},Array{InitialCondition,1},Symbol,Tuple{Symbol,Symbol,Symbol}}"><code>PowerSimulations.device_mixedinteger_rateofchange</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">device_mixedinteger_rateofchange(psi_container::PSIContainer,
                                      rate_data::Tuple{Vector{String}, Vector{UpDown}, Vector{MinMax}},
                                      initial_conditions::Vector{InitialCondition},
                                      cons_name::Symbol,
                                      var_names::Tuple{Symbol, Symbol, Symbol})</code></pre><p>Constructs allowed rate-of-change constraints from variables, initial condtions, start/stop status, and rate data</p><p><strong>Equations</strong></p><p>If t = 1:</p><p><code>variable[name, 1] - initial_conditions[ix].value &lt;= rate_data[1][ix].up + rate_data[2][ix].max*varstart[name, 1]</code></p><p><code>initial_conditions[ix].value - variable[name, 1] &lt;= rate_data[1][ix].down + rate_data[2][ix].min*varstop[name, 1]</code></p><p>If t &gt; 1:</p><p><code>variable[name, t] - variable[name, t-1] &lt;= rate_data[1][ix].up + rate_data[2][ix].max*varstart[name, t]</code></p><p><code>variable[name, t-1] - variable[name, t] &lt;= rate_data[1][ix].down + rate_data[2][ix].min*varstop[name, t]</code></p><p><strong>LaTeX</strong></p><p><span>$r^{down} + r^{min} x^{stop}_1 \leq x_1 - x_{init} \leq r^{up} + r^{max} x^{start}_1, \text{ for } t = 1$</span></p><p><span>$r^{down} + r^{min} x^{stop}_t \leq x_t - x_{t-1} \leq r^{up} + r^{max} x^{start}_t, \forall t \geq 2$</span></p><p><strong>Arguments</strong></p><ul><li>psi<em>container::PSIContainer : the psi</em>container model built in PowerSimulations</li><li>rate_data::Tuple{Vector{String}, Vector{UpDown}, Vector{MinMax}} : (1) gives name                                                                    (2) gives min/max ramp rates                                                                    (3) gives min/max for &#39;variable&#39;</li><li>initial_conditions::Vector{InitialCondition} : for time zero &#39;variable&#39;</li><li>cons_name::Symbol : name of the constraint</li><li>var_names::Tuple{Symbol, Symbol, Symbol} : the names of the variables</li><li>: var_names[1] : &#39;variable&#39;</li><li>: var_names[2] : &#39;varstart&#39;</li><li>: var_names[3] : &#39;varstop&#39;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/devices_models/devices/common/rateofchange_constraints.jl#L80-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_range-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceRange,1},Symbol,Symbol}" href="#PowerSimulations.device_range-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceRange,1},Symbol,Symbol}"><code>PowerSimulations.device_range</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">device_range(psi_container::PSIContainer,
             range_data::Vector{DeviceRange},
             cons_name::Symbol,
             var_name::Symbol)</code></pre><p>Constructs min/max range constraint from device variable.</p><p><strong>Constraints</strong></p><p>If min and max within an epsilon width:</p><p><code>variable[name, t] == limits.max</code></p><p>Otherwise:</p><p><code>limits.min &lt;= variable[name, t] &lt;= limits.max</code></p><p>where limits in range_data.</p><p><strong>LaTeX</strong></p><p><span>$x = limits^{max}, \text{ for } |limits^{max} - limits^{min}| &lt; \varepsilon$</span></p><p><span>$limits^{min} \leq x \leq limits^{max}, \text{ otherwise }$</span></p><p><strong>Arguments</strong></p><ul><li>psi<em>container::PSIContainer : the psi</em>container model built in PowerSimulations</li><li>range_data::Vector{DeviceRange} : contains names and vector of min/max</li><li>cons_name::Symbol : name of the constraint</li><li>var_name::Symbol : the name of the continuous variable</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/devices_models/devices/common/range_constraint.jl#L1-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_semicontinuousrange-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceRange,1},Symbol,Symbol,Symbol}" href="#PowerSimulations.device_semicontinuousrange-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceRange,1},Symbol,Symbol,Symbol}"><code>PowerSimulations.device_semicontinuousrange</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">device_semicontinuousrange(psi_container::PSIContainer,
                                range_data::Vector{DeviceRange},
                                cons_name::Symbol,
                                var_name::Symbol,
                                binvar_name::Symbol)</code></pre><p>Constructs min/max range constraint from device variable and on/off decision variable.</p><p><strong>Constraints</strong></p><p>If device min = 0:</p><p><code>varcts[name, t] &lt;= limits.max*varbin[name, t])</code></p><p><code>varcts[name, t] &gt;= 0.0</code></p><p>Otherwise:</p><p><code>varcts[name, t] &lt;= limits.max*varbin[name, t]</code></p><p><code>varcts[name, t] &gt;= limits.min*varbin[name, t]</code></p><p>where limits in range_data.</p><p><strong>LaTeX</strong></p><p><span>$0 \leq x^{cts} \leq limits^{max} x^{bin}, \text{ for } limits^{min} = 0$</span></p><p><span>$limits^{min} x^{bin} \leq x^{cts} \leq limits^{max} x^{bin}, \text{ otherwise }$</span></p><p><strong>Arguments</strong></p><ul><li>psi<em>container::PSIContainer : the psi</em>container model built in PowerSimulations</li><li>range_data::Vector{DeviceRange} : contains names and vector of min/max</li><li>cons_name::Symbol : name of the constraint</li><li>var_name::Symbol : the name of the continuous variable</li><li>binvar_name::Symbol : the name of the binary variable</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/devices_models/devices/common/range_constraint.jl#L71-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_timeseries_lb-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceTimeSeries,1},Symbol,Symbol}" href="#PowerSimulations.device_timeseries_lb-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceTimeSeries,1},Symbol,Symbol}"><code>PowerSimulations.device_timeseries_lb</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">device_timeseries_lb(psi_container::PSIContainer,
                 ts_data::Vector{DeviceTimeSeries},
                 cons_name::Symbol,
                 var_name::Symbol)</code></pre><p>Constructs lower bound for given variable subject to time series data and a multiplier.</p><p><strong>Constraint</strong></p><p><code>ts_data[name].multiplier * ts_data[name].timeseries[t] &lt;= variable[name, t]</code></p><p><strong>LaTeX</strong></p><p><span>$r^{val} r_t \leq x_t, \forall t$</span></p><p>where (name, data) in range_data.</p><p><strong>Arguments</strong></p><ul><li>psi<em>container::PSIContainer : the psi</em>container model built in PowerSimulations</li><li>ts_data::Vector{DeviceTimeSeries} : container of device time series data and scaling factors</li><li>cons_name::Symbol : name of the constraint</li><li>var_name::Symbol : the name of the variable</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/devices_models/devices/common/timeseries_constraint.jl#L71-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_timeseries_param_lb-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceTimeSeries,1},Symbol,PowerSimulations.UpdateRef,Symbol}" href="#PowerSimulations.device_timeseries_param_lb-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceTimeSeries,1},Symbol,PowerSimulations.UpdateRef,Symbol}"><code>PowerSimulations.device_timeseries_param_lb</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">device_timeseries_param_lb(psi_container::PSIContainer,
                                ts_data::Vector{DeviceTimeSeries},
                                cons_name::Symbol,
                                param_reference::UpdateRef,
                                var_name::Symbol)</code></pre><p>Constructs lower bound for given variable using a parameter. The constraint is     built with a time series data vector and a multiplier</p><p><strong>Constraint</strong></p><p><code>ts_data[name].multiplier * param[name, t] &lt;= variable[name, t]</code></p><p><strong>LaTeX</strong></p><p><span>$r^{val} x^{param}_t \leq x^{var}_t, \forall t$</span></p><p><strong>Arguments</strong></p><ul><li>psi<em>container::PSIContainer : the psi</em>container model built in PowerSimulations</li><li>ts_data::Vector{DeviceTimeSeries} : container of device time series data and scaling factors</li><li>cons_name::Symbol : name of the constraint</li><li>param_reference::UpdateRef : UpdateRef to access the parameter</li><li>var_name::Symbol : the name of the variable</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/devices_models/devices/common/timeseries_constraint.jl#L208-L232">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_timeseries_param_ub-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceTimeSeries,1},Symbol,PowerSimulations.UpdateRef,Symbol}" href="#PowerSimulations.device_timeseries_param_ub-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceTimeSeries,1},Symbol,PowerSimulations.UpdateRef,Symbol}"><code>PowerSimulations.device_timeseries_param_ub</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">device_timeseries_param_ub(psi_container::PSIContainer,
                                ts_data::Vector{DeviceTimeSeries},
                                cons_name::Symbol,
                                param_reference::UpdateRef,
                                var_name::Symbol)</code></pre><p>Constructs upper bound for given variable using a parameter. The constraint is     built with a time series data vector and a multiplier</p><p><strong>Constraint</strong></p><p><code>variable[name, t] &lt;= ts_data[name].multiplier * param[name, t]</code></p><p><strong>LaTeX</strong></p><p><span>$x^{var}_t \leq r^{val} x^{param}_t, \forall t$</span></p><p><strong>Arguments</strong></p><ul><li>psi<em>container::PSIContainer : the psi</em>container model built in PowerSimulations</li><li>ts_data::Vector{DeviceTimeSeries} : container of device time series data and scaling factors</li><li>cons_name::Symbol : name of the constraint</li><li>param_reference::UpdateRef : UpdateRef to access the parameter</li><li>var_name::Symbol : the name of the variable</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/devices_models/devices/common/timeseries_constraint.jl#L128-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_timeseries_ub-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceTimeSeries,1},Symbol,Symbol}" href="#PowerSimulations.device_timeseries_ub-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceTimeSeries,1},Symbol,Symbol}"><code>PowerSimulations.device_timeseries_ub</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">device_timeseries_ub(psi_container::PSIContainer,
                 ts_data::Vector{DeviceTimeSeries},
                 cons_name::Symbol,
                 var_name::Symbol)</code></pre><p>Constructs upper bound for given variable and time series data and a multiplier.</p><p><strong>Constraint</strong></p><p><code>variable[name, t] &lt;= ts_data[name].multiplier * ts_data[name].timeseries[t]</code></p><p><strong>LaTeX</strong></p><p><span>$x_t \leq r^{val} r_t, \forall t$</span></p><p><strong>Arguments</strong></p><ul><li>psi<em>container::PSIContainer : the psi</em>container model built in PowerSimulations</li><li>ts_data::Vector{DeviceTimeSeries} : container of device time series data and scaling factors</li><li>cons_name::Symbol : name of the constraint</li><li>var_name::Symbol : the name of the variable</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/devices_models/devices/common/timeseries_constraint.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_timeseries_ub_bigM" href="#PowerSimulations.device_timeseries_ub_bigM"><code>PowerSimulations.device_timeseries_ub_bigM</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">device_timeseries_ub_bigM(psi_container::PSIContainer,
                                ts_data::Vector{DeviceTimeSeries},
                                cons_name::Symbol,
                                var_name::Symbol,
                                param_reference::UpdateRef,
                                binvar_name::Symbol,
                                M_value::Float64 = 1e6)</code></pre><p>Constructs upper bound for variable and time series and a multiplier or confines to 0 depending on binary variable.     Uses BigM constraint type to allow for parameter since ParameterJuMP doesn&#39;t support var*parameter</p><p><strong>Constraints</strong></p><p><code>varcts[name, t] - ts_data[name].multipliers * param[name, t] &lt;= (1 - varbin[name, t]) * M_value</code></p><p><code>varcts[name, t] &lt;= varbin[name, t]*M_value</code></p><p><strong>LaTeX</strong></p><p><span>$x^{cts}_t - r^{val} x^{param}_t \leq M(1 - x^{bin}_t ), forall t$</span></p><p><span>$x^{cts}_t \leq M x^{bin}_t, \forall t$</span></p><p><strong>Arguments</strong></p><ul><li>psi<em>container::PSIContainer : the psi</em>container model built in PowerSimulations</li><li>ts_data::Vector{DeviceTimeSeries} : container of device time series data and scaling factors</li><li>cons_name::Symbol : name of the constraint</li><li>var_name::Symbol :  name of the variable</li></ul><p>param_reference::UpdateRef : UpdateRef of access the parameters</p><ul><li>binvar_name::Symbol : name of binary variable</li><li>M_value::Float64 : bigM</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/devices_models/devices/common/timeseries_constraint.jl#L338-L370">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_timeseries_ub_bin-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceTimeSeries,1},Symbol,Symbol,Symbol}" href="#PowerSimulations.device_timeseries_ub_bin-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceTimeSeries,1},Symbol,Symbol,Symbol}"><code>PowerSimulations.device_timeseries_ub_bin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">device_timeseries_ub_bin(psi_container::PSIContainer,
                                ts_data::Vector{DeviceTimeSeries},
                                var_name::Symbol,
                                binvar_name::Symbol)</code></pre><p>Constructs upper bound for variable and time series or confines to 0 depending on binary variable.     The upper bound is defined by a time series and a multiplier.</p><p><strong>Constraints</strong></p><p><code>varcts[name, t] &lt;= varbin[name, t]* ts_data[name].multiplier * ts_data[name].timeseries[t]</code></p><p>where (name, data) in range_data.</p><p><strong>LaTeX</strong></p><p><span>$x^{cts}_t \leq r^{val} r_t x^{bin}_t, \forall t$</span></p><p><strong>Arguments</strong></p><ul><li>psi<em>container::PSIContainer : the psi</em>container model built in PowerSimulations</li><li>ts_data::Vector{DeviceTimeSeries} : container of device time series data and scaling factors</li><li>cons_name::Symbol : name of the constraint</li><li>var_name::Symbol :  name of the variable</li><li>binvar_name::Symbol : name of binary variable</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/devices_models/devices/common/timeseries_constraint.jl#L273-L298">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.energy_balance-Tuple{PowerSimulations.PSIContainer,Array{InitialCondition,1},Tuple{Array{String,1},Array{NamedTuple{(:in, :out),Tuple{Float64,Float64}},1}},Symbol,Tuple{Symbol,Symbol,Symbol}}" href="#PowerSimulations.energy_balance-Tuple{PowerSimulations.PSIContainer,Array{InitialCondition,1},Tuple{Array{String,1},Array{NamedTuple{(:in, :out),Tuple{Float64,Float64}},1}},Symbol,Tuple{Symbol,Symbol,Symbol}}"><code>PowerSimulations.energy_balance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">energy_balance(psi_container::PSIContainer,
                    initial_conditions::Vector{InitialCondition},
                    efficiency_data::Tuple{Vector{String}, Vector{InOut}},
                    cons_name::Symbol,
                    var_names::Tuple{Symbol, Symbol, Symbol})</code></pre><p>Constructs multi-timestep constraint from initial condition, efficiency data, and variable tuple</p><p><strong>Constraints</strong></p><p>If t = 1:</p><p><code>varenergy[name, 1] == initial_conditions[ix].value + varin[name, 1]*eff_in*fraction_of_hour - varout[name, 1]*fraction_of_hour/eff_out</code></p><p>If t &gt; 1:</p><p><code>varenergy[name, t] == varenergy[name, t-1] + varin[name, t]*eff_in*fraction_of_hour - varout[name, t]*fraction_of_hour/eff_out</code></p><p><strong>LaTeX</strong></p><p><span>$x^{energy}_1 == x^{energy}_{init} + frhr \eta^{in} x^{in}_1 - \frac{frhr}{\eta^{out}} x^{out}_1, \text{ for } t = 1$</span></p><p><span>$x^{energy}_t == x^{energy}_{t-1} + frhr \eta^{in} x^{in}_t - \frac{frhr}{\eta^{out}} x^{out}_t, \forall t \geq 2$</span></p><p><strong>Arguments</strong></p><ul><li>psi<em>container::PSIContainer : the psi</em>container model built in PowerSimulations</li><li>initial_conditions::Vector{InitialCondition} : for time zero &#39;varenergy&#39;</li><li>efficiency_data::Tuple{Vector{String}, Vector{InOut}} :: charging/discharging efficiencies</li><li>cons_name::Symbol : name of the constraint</li><li>var_names::Tuple{Symbol, Symbol, Symbol} : the names of the variables</li><li>: var_names[1] : varin</li><li>: var_names[2] : varout</li><li>: var_names[3] : varenergy</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/devices_models/devices/common/energy_balance_constraint.jl#L1-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.export_op_model-Tuple{OperationsProblem,String}" href="#PowerSimulations.export_op_model-Tuple{OperationsProblem,String}"><code>PowerSimulations.export_op_model</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Exports the OpModel JuMP object in MathOptFormat</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/core/operations_problem.jl#L532">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.find_key_with_value-Tuple{Any,Any}" href="#PowerSimulations.find_key_with_value-Tuple{Any,Any}"><code>PowerSimulations.find_key_with_value</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the key for the given value</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/utils.jl#L19-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.initial_condition_update!-Tuple{Stage,PowerSimulations.ICKey,Array{InitialCondition,1},InterStageChronology,Simulation}" href="#PowerSimulations.initial_condition_update!-Tuple{Stage,PowerSimulations.ICKey,Array{InitialCondition,1},InterStageChronology,Simulation}"><code>PowerSimulations.initial_condition_update!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Updates the initial conditions of the stage</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/core/simulation.jl#L580">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.initial_condition_update!-Tuple{Stage,PowerSimulations.ICKey,Array{InitialCondition,1},IntraStageChronology,Simulation}" href="#PowerSimulations.initial_condition_update!-Tuple{Stage,PowerSimulations.ICKey,Array{InitialCondition,1},IntraStageChronology,Simulation}"><code>PowerSimulations.initial_condition_update!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Updates the initial conditions of the stage</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/core/simulation.jl#L549">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.instantiate_nip_expr-Tuple{PowerModels.AbstractPowerModel}" href="#PowerSimulations.instantiate_nip_expr-Tuple{PowerModels.AbstractPowerModel}"><code>PowerSimulations.instantiate_nip_expr</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/network_models/powermodels_interface.jl#L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.instantiate_nip_expr_model-Tuple{Dict{String,Any},Any}" href="#PowerSimulations.instantiate_nip_expr_model-Tuple{Dict{String,Any},Any}"><code>PowerSimulations.instantiate_nip_expr_model</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/network_models/powermodels_interface.jl#L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.instantiate_nip_model-Tuple{Dict{String,Any},Any}" href="#PowerSimulations.instantiate_nip_model-Tuple{Dict{String,Any},Any}"><code>PowerSimulations.instantiate_nip_model</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/network_models/powermodels_interface.jl#L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.integral_limit_ff-Tuple{PowerSimulations.PSIContainer,Symbol,PowerSimulations.UpdateRef,Symbol}" href="#PowerSimulations.integral_limit_ff-Tuple{PowerSimulations.PSIContainer,Symbol,PowerSimulations.UpdateRef,Symbol}"><code>PowerSimulations.integral_limit_ff</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">    integral_limit_ff(psi_container::PSIContainer,
                    cons_name::Symbol,
                    param_reference::UpdateRef,
                    var_name::Symbol)</code></pre><p>Constructs a parametrized integral limit constraint to implement feedforward from other models. The Parameters are initialized using the upper boundary values of the provided variables.</p><p><strong>Constraints</strong></p><p><code>sum(variable[var_name, t] for t in time_steps)/length(time_steps) &lt;= param_reference[var_name]</code></p><p><strong>LaTeX</strong></p><p><span>$\sum_{t} x \leq param^{max}$</span></p><p><strong>Arguments</strong></p><ul><li>psi<em>container::PSIContainer : the psi</em>container model built in PowerSimulations</li><li>cons_name::Symbol : name of the constraint</li><li>param_reference : Reference to the PJ.ParameterRef used to determine the upperbound</li><li>var_name::Symbol : the name of the continuous variable</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/core/feedforward.jl#L375-L396">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.iterate_initial_conditions-Tuple{PowerSimulations.InitialConditions}" href="#PowerSimulations.iterate_initial_conditions-Tuple{PowerSimulations.InitialConditions}"><code>PowerSimulations.iterate_initial_conditions</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Iterate over the keys and vectors of initial conditions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/core/initial_conditions.jl#L38-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.powermodels_network!-Union{Tuple{S}, Tuple{PowerSimulations.PSIContainer,Type{S},PowerSystems.System}} where S&lt;:PowerModels.AbstractActivePowerModel" href="#PowerSimulations.powermodels_network!-Union{Tuple{S}, Tuple{PowerSimulations.PSIContainer,Type{S},PowerSystems.System}} where S&lt;:PowerModels.AbstractActivePowerModel"><code>PowerSimulations.powermodels_network!</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/network_models/powermodels_interface.jl#L312">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.powermodels_network!-Union{Tuple{S}, Tuple{PowerSimulations.PSIContainer,Type{S},PowerSystems.System}} where S&lt;:PowerModels.AbstractPowerModel" href="#PowerSimulations.powermodels_network!-Union{Tuple{S}, Tuple{PowerSimulations.PSIContainer,Type{S},PowerSystems.System}} where S&lt;:PowerModels.AbstractPowerModel"><code>PowerSimulations.powermodels_network!</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/network_models/powermodels_interface.jl#L280">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.ps_cost-Union{Tuple{JV}, Tuple{PowerSimulations.PSIContainer,JuMP.Containers.DenseAxisArray{JV,N,Ax,L} where L&lt;:Tuple{Vararg{Dict,N}} where Ax where N,Float64,Float64,Float64}} where JV&lt;:JuMP.AbstractVariableRef" href="#PowerSimulations.ps_cost-Union{Tuple{JV}, Tuple{PowerSimulations.PSIContainer,JuMP.Containers.DenseAxisArray{JV,N,Ax,L} where L&lt;:Tuple{Vararg{Dict,N}} where Ax where N,Float64,Float64,Float64}} where JV&lt;:JuMP.AbstractVariableRef"><code>PowerSimulations.ps_cost</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ps_cost(psi_container::PSIContainer,
            variable::JuMP.Containers.DenseAxisArray{JV},
            cost_component::Float64,
            dt::Float64,
            sign::Float64) where {JV &lt;: JuMP.AbstractVariableRef}</code></pre><p>Returns linear cost terms for sum of variables with common factor to be used for cost expression for psi_container model.</p><p><strong>Equation</strong></p><p><code>gen_cost = sum(variable)*cost_component</code></p><p><strong>LaTeX</strong></p><p><span>$cost = dt\times sign\sum_{i\in I} c x_i$</span></p><p>Returns:</p><p><code>sign*gen_cost*dt</code></p><p><strong>Arguments</strong></p><ul><li>psi<em>container::PSIContainer : the psi</em>container model built in PowerSimulations</li><li>variable::JuMP.Containers.DenseAxisArray{JV} : variable array</li><li>cost_component::Float64 : cost to be associated with variable</li><li>dt::Float64 : fraction of hour</li><li>sign::Float64 : positive or negative sign to be associated cost term</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/devices_models/devices/common/cost_functions.jl#L1-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.ps_cost-Union{Tuple{JV}, Tuple{PowerSimulations.PSIContainer,JuMP.Containers.DenseAxisArray{JV,N,Ax,L} where L&lt;:Tuple{Vararg{Dict,N}} where Ax where N,PowerSystems.VariableCost{Array{Tuple{Float64,Float64},1}},Float64,Float64}} where JV&lt;:JuMP.AbstractVariableRef" href="#PowerSimulations.ps_cost-Union{Tuple{JV}, Tuple{PowerSimulations.PSIContainer,JuMP.Containers.DenseAxisArray{JV,N,Ax,L} where L&lt;:Tuple{Vararg{Dict,N}} where Ax where N,PowerSystems.VariableCost{Array{Tuple{Float64,Float64},1}},Float64,Float64}} where JV&lt;:JuMP.AbstractVariableRef"><code>PowerSimulations.ps_cost</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ps_cost(psi_container::PSIContainer,
             variable::JuMP.Containers.DenseAxisArray{JV},
             cost_component::PSY.VariableCost{Vector{NTuple{2, Float64}}},
             dt::Float64,
             sign::Float64) where {JV&lt;:JuMP.AbstractVariableRef}</code></pre><p>Creates piecewise linear cost function using a sum of variables and expression with sign and time step included.</p><p><strong>Expression</strong></p><p><code>JuMP.add_to_expression!(gen_cost, c)</code></p><p>Returns sign<em>gen_cost</em>dt</p><p><strong>LaTeX</strong></p><p><span>$cost = sign\times dt \sum_{v\in V} c_v$</span></p><p>where <span>$c_v$</span> is given by</p><p><span>$c_v = \sum_{i\in Ix} \frac{y_i - y_{i-1}}{x_i - x_{i-1}} v^{p.w.}_i$</span></p><p><strong>Arguments</strong></p><ul><li>psi<em>container::PSIContainer : the psi</em>container model built in PowerSimulations</li><li>variable::JuMP.Containers.DenseAxisArray{JV} : variable array</li><li>cost_component::PSY.VariableCost{Vector{NTuple{2, Float64}}}</li><li>dt::Float64 : fraction of hour</li><li>sign::Float64 : positive or negative sign to be associated cost term</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/devices_models/devices/common/cost_functions.jl#L311-L341">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.ps_cost-Union{Tuple{JV}, Tuple{PowerSimulations.PSIContainer,JuMP.Containers.DenseAxisArray{JV,N,Ax,L} where L&lt;:Tuple{Vararg{Dict,N}} where Ax where N,PowerSystems.VariableCost{Float64},Float64,Float64}} where JV&lt;:JuMP.AbstractVariableRef" href="#PowerSimulations.ps_cost-Union{Tuple{JV}, Tuple{PowerSimulations.PSIContainer,JuMP.Containers.DenseAxisArray{JV,N,Ax,L} where L&lt;:Tuple{Vararg{Dict,N}} where Ax where N,PowerSystems.VariableCost{Float64},Float64,Float64}} where JV&lt;:JuMP.AbstractVariableRef"><code>PowerSimulations.ps_cost</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ps_cost(psi_container::PSIContainer,
            variable::JuMP.Containers.DenseAxisArray{JV},
            cost_component::PSY.VariableCost{Float64},
            dt::Float64,
            sign::Float64) where {JV &lt;: JuMP.AbstractVariableRef}</code></pre><p>Returns linear cost terms for sum of variables with common factor to be used for cost expression for psi<em>container model. Does this by calling ```ps</em>cost``` that has Float64 cost component input.</p><p>Returns:</p><p><code>ps_cost(psi_container, variable, PSY.get_cost(cost_component), dt, sign)</code></p><p><strong>Arguments</strong></p><ul><li>psi<em>container::PSIContainer : the psi</em>container model built in PowerSimulations</li><li>variable::JuMP.Containers.DenseAxisArray{JV} : variable array</li><li>cost_component::PSY.VariableCost{Float64} : container for cost to be associated with variable</li><li>dt::Float64 : fraction of hour</li><li>sign::Float64 : positive or negative sign to be associated cost term</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/devices_models/devices/common/cost_functions.jl#L43-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.ps_cost-Union{Tuple{JV}, Tuple{PowerSimulations.PSIContainer,JuMP.Containers.DenseAxisArray{JV,N,Ax,L} where L&lt;:Tuple{Vararg{Dict,N}} where Ax where N,PowerSystems.VariableCost{Tuple{Float64,Float64}},Float64,Float64}} where JV&lt;:JuMP.AbstractVariableRef" href="#PowerSimulations.ps_cost-Union{Tuple{JV}, Tuple{PowerSimulations.PSIContainer,JuMP.Containers.DenseAxisArray{JV,N,Ax,L} where L&lt;:Tuple{Vararg{Dict,N}} where Ax where N,PowerSystems.VariableCost{Tuple{Float64,Float64}},Float64,Float64}} where JV&lt;:JuMP.AbstractVariableRef"><code>PowerSimulations.ps_cost</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ps_cost(psi_container::PSIContainer,
            variable::JuMP.Containers.DenseAxisArray{JV},
            cost_component::PSY.VariableCost{NTuple{2, Float64}}
            dt::Float64,
            sign::Float64) where {JV &lt;: JuMP.AbstractVariableRef}</code></pre><p>Returns quadratic cost terms for sum of variables with common factor to be used for cost expression for psi_container model.</p><p><strong>Equation</strong></p><p><code>gen_cost = dt*sign*(sum(variable.^2)*cost_component[1] + sum(variable)*cost_component[2])</code></p><p><strong>LaTeX</strong></p><p><span>$cost = dt\times sign (sum_{i\in I} c_1 v_i^2 + sum_{i\in I} c_2 v_i )$</span></p><p>for quadratic factor large enough. Otherwise</p><p><code>return ps_cost(psi_container, variable, cost_component[2], dt, 1.0)</code></p><p>Returns <code>gen_cost</code></p><p><strong>Arguments</strong></p><ul><li>psi<em>container::PSIContainer : the psi</em>container model built in PowerSimulations</li><li>variable::JuMP.Containers.DenseAxisArray{JV} : variable array</li><li>cost_component::PSY.VariableCost{NTuple{2, Float64}} : container for quadratic and linear factors</li><li>sign::Float64 : positive or negative sign to be associated cost term</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/devices_models/devices/common/cost_functions.jl#L75-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.ramp_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},DeviceModel{T,D},Type{S},Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S&lt;:PowerModels.AbstractPowerModel where D&lt;:PowerSimulations.AbstractThermalFormulation where T&lt;:PowerSystems.ThermalGen" href="#PowerSimulations.ramp_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},DeviceModel{T,D},Type{S},Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S&lt;:PowerModels.AbstractPowerModel where D&lt;:PowerSimulations.AbstractThermalFormulation where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.ramp_constraints!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function adds the ramping limits of generators when there are CommitmentVariables</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/devices_models/devices/thermal_generation.jl#L354-L356">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.range_ff-Tuple{PowerSimulations.PSIContainer,Symbol,Tuple{PowerSimulations.UpdateRef,PowerSimulations.UpdateRef},Symbol}" href="#PowerSimulations.range_ff-Tuple{PowerSimulations.PSIContainer,Symbol,Tuple{PowerSimulations.UpdateRef,PowerSimulations.UpdateRef},Symbol}"><code>PowerSimulations.range_ff</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">    range_ff(psi_container::PSIContainer,
                    cons_name::Symbol,
                    param_reference::NTuple{2, UpdateRef},
                    var_name::Symbol)</code></pre><p>Constructs min/max range parametrized constraint from device variable to include feedforward.</p><p><strong>Constraints</strong></p><p><code>param_reference[1][var_name] &lt;= variable[var_name, t]</code> <code>variable[var_name, t] &lt;= param_reference[2][var_name]</code></p><p>where r in range_data.</p><p><strong>LaTeX</strong></p><p><span>$param^{min} \leq x$</span> <span>$x \leq param^{max}$</span></p><p><strong>Arguments</strong></p><ul><li>psi<em>container::PSIContainer : the psi</em>container model built in PowerSimulations</li><li>param_reference::NTuple{2, UpdateRef} : Tuple with the lower bound and upper bound parameter reference</li><li>cons_name::Symbol : name of the constraint</li><li>var_name::Symbol : the name of the continuous variable</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/core/feedforward.jl#L224-L249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.rating_constraint!-Tuple{PowerSimulations.PSIContainer,Array{Tuple{String,Float64},1},Symbol,Tuple{Symbol,Symbol}}" href="#PowerSimulations.rating_constraint!-Tuple{PowerSimulations.PSIContainer,Array{Tuple{String,Float64},1},Symbol,Tuple{Symbol,Symbol}}"><code>PowerSimulations.rating_constraint!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rating_constraint!(psi_container::PSIContainer,
                        rating_data::Vector{Tuple{String, Float64}},
                        cons_name::Symbol,
                        var_names::Tuple{Symbol, Symbol})</code></pre><p>Constructs constraint from rating data and related variable tuple.</p><p><strong>Constraint</strong></p><p><code>var1[r[1], t]^2 + var2[r[1], t]^2 &lt;= r[2]^2</code></p><p>where r in rating data and t in time steps.</p><p><strong>LaTeX</strong></p><p><span>$x_1^2 + x_2^2 \leq r^2$</span></p><p><strong>Arguments</strong></p><ul><li>psi<em>container::PSIContainer : the psi</em>container model built in PowerSimulations</li><li>rating_data::Vector{Tuple{String, Float64}} : rating data name (1) and value (2)</li><li>cons_name::Symbol : name of the constraint</li><li>var_names::Tuple{Symbol, Symbol} : the names of the variables</li><li>: var_names[1] : var1</li><li>: var_names[2] : var2</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/devices_models/devices/common/rating_constraints.jl#L1-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.reactive_power_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{St}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{St},DeviceModel{St,D},Type{S},Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S&lt;:PowerModels.AbstractPowerModel where D&lt;:PowerSimulations.AbstractStorageFormulation where St&lt;:PowerSystems.Storage" href="#PowerSimulations.reactive_power_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{St}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{St},DeviceModel{St,D},Type{S},Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where S&lt;:PowerModels.AbstractPowerModel where D&lt;:PowerSimulations.AbstractStorageFormulation where St&lt;:PowerSystems.Storage"><code>PowerSimulations.reactive_power_constraints!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function adds the reactive  power limits of generators when there are CommitmentVariables</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/devices_models/devices/storage.jl#L136-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.reactivepower_constraints!-Union{Tuple{L}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{L},DeviceModel{L,#s508} where #s508&lt;:PowerSimulations.AbstractControllablePowerLoadFormulation,Type{#s507} where #s507&lt;:PowerModels.AbstractPowerModel,Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where L&lt;:PowerSystems.ElectricLoad" href="#PowerSimulations.reactivepower_constraints!-Union{Tuple{L}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{L},DeviceModel{L,#s508} where #s508&lt;:PowerSimulations.AbstractControllablePowerLoadFormulation,Type{#s507} where #s507&lt;:PowerModels.AbstractPowerModel,Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where L&lt;:PowerSystems.ElectricLoad"><code>PowerSimulations.reactivepower_constraints!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Reactive Power Constraints on Loads Assume Constant PowerFactor</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/devices_models/devices/electric_loads.jl#L54-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.reactivepower_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},DeviceModel{T,#s509} where #s509&lt;:PowerSimulations.AbstractThermalDispatchFormulation,Type{#s508} where #s508&lt;:PowerModels.AbstractPowerModel,Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where T&lt;:PowerSystems.ThermalGen" href="#PowerSimulations.reactivepower_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},DeviceModel{T,#s509} where #s509&lt;:PowerSimulations.AbstractThermalDispatchFormulation,Type{#s508} where #s508&lt;:PowerModels.AbstractPowerModel,Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.reactivepower_constraints!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function adds the reactive  power limits of generators when there are CommitmentVariables</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/devices_models/devices/thermal_generation.jl#L194-L196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.reactivepower_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},DeviceModel{T,#s509} where #s509&lt;:PowerSimulations.AbstractThermalFormulation,Type{#s508} where #s508&lt;:PowerModels.AbstractPowerModel,Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where T&lt;:PowerSystems.ThermalGen" href="#PowerSimulations.reactivepower_constraints!-Union{Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T},DeviceModel{T,#s509} where #s509&lt;:PowerSimulations.AbstractThermalFormulation,Type{#s508} where #s508&lt;:PowerModels.AbstractPowerModel,Union{Nothing, PowerSimulations.AbstractAffectFeedForward}}} where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.reactivepower_constraints!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function adds the reactive power limits of generators when there CommitmentVariables</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/devices_models/devices/thermal_generation.jl#L223-L225">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.reactivepower_variables!-Union{Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T}}} where T&lt;:PowerSystems.ThermalGen" href="#PowerSimulations.reactivepower_variables!-Union{Tuple{T}, Tuple{PowerSimulations.PSIContainer,InfrastructureSystems.FlattenIteratorWrapper{T}}} where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.reactivepower_variables!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function add the variables for power generation output to the model</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/devices_models/devices/thermal_generation.jl#L37-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.read_json-Tuple{AbstractString}" href="#PowerSimulations.read_json-Tuple{AbstractString}"><code>PowerSimulations.read_json</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return a decoded JSON file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/utils.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.remove_chars-Tuple{String,String}" href="#PowerSimulations.remove_chars-Tuple{String,String}"><code>PowerSimulations.remove_chars</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Removes the string <code>char</code> from the original string</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/utils.jl#L270">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.replace_chars-Tuple{String,String,String}" href="#PowerSimulations.replace_chars-Tuple{String,String,String}"><code>PowerSimulations.replace_chars</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Replaces the string in <code>char</code> with the string<code>replacement</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/utils.jl#L265">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.reserve_device_semicontinuousrange-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceRange,1},Symbol,Symbol,Symbol}" href="#PowerSimulations.reserve_device_semicontinuousrange-Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceRange,1},Symbol,Symbol,Symbol}"><code>PowerSimulations.reserve_device_semicontinuousrange</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">reserve_device_semicontinuousrange(psi_container::PSIContainer,
                                range_data::Vector{DeviceRange},
                                cons_name::Symbol,
                                var_name::Symbol,
                                binvar_name::Symbol)</code></pre><p>Constructs min/max range constraint from device variable and on/off decision variable.</p><p><strong>Constraints</strong></p><p>If device min = 0:</p><p><code>varcts[name, t] &lt;= limits.max * (1 - varbin[name, t])</code></p><p><code>varcts[name, t] &gt;= 0.0</code></p><p>Otherwise:</p><p><code>varcts[name, t] &lt;= limits.max * (1 - varbin[name, t])</code></p><p><code>varcts[name, t] &gt;= limits.min * (1 - varbin[name, t])</code></p><p>where limits in range_data.</p><p><strong>LaTeX</strong></p><p><span>$0 \leq x^{cts} \leq limits^{max} (1 - x^{bin} ), \text{ for } limits^{min} = 0$</span></p><p><span>$limits^{min} (1 - x^{bin} ) \leq x^{cts} \leq limits^{max} (1 - x^{bin} ), \text{ otherwise }$</span></p><p><strong>Arguments</strong></p><ul><li>psi<em>container::PSIContainer : the psi</em>container model built in PowerSimulations</li><li>range_data::Vector{DeviceRange} : contains names and vector of min/max</li><li>cons_name::Symbol : name of the constraint</li><li>var_name::Symbol : the name of the continuous variable</li><li>binvar_name::Symbol : the name of the binary variable</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/devices_models/devices/common/range_constraint.jl#L158-L194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.reservoir_energy_balance-Tuple{PowerSimulations.PSIContainer,Array{InitialCondition,1},Array{PowerSimulations.DeviceTimeSeries,1},Symbol,Tuple{Symbol,Symbol,Symbol}}" href="#PowerSimulations.reservoir_energy_balance-Tuple{PowerSimulations.PSIContainer,Array{InitialCondition,1},Array{PowerSimulations.DeviceTimeSeries,1},Symbol,Tuple{Symbol,Symbol,Symbol}}"><code>PowerSimulations.reservoir_energy_balance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">reservoir_energy_balance(psi_container::PSIContainer,
                    initial_conditions::Vector{InitialCondition},
                    efficiency_data::Tuple{Vector{String}, Vector{InOut}},
                    cons_name::Symbol,
                    var_names::Tuple{Symbol, Symbol, Symbol})</code></pre><p>Constructs multi-timestep constraint from initial condition, efficiency data, and variable tuple</p><p><strong>Constraints</strong></p><p>If t = 1: <code>varenergy[name, 1] == initial_conditions[ix].value + (paraminflow[name, t] - varspill[name, 1] - varout[name, 1])*fraction_of_hour</code> If t &gt; 1: <code>varenergy[name, t] == varenergy[name, t-1] + (paraminflow[name, t] - varspill[name, t] - varout[name, t])*fraction_of_hour</code></p><p><strong>LaTeX</strong></p><p><span>$x^{energy}_1 == x^{energy}_{init} + frhr  (x^{in}_1 - x^{spillage}_1 -  x^{out}_1), \text{ for } t = 1$</span> <span>$x^{energy}_t == x^{energy}_{t-1} + frhr (x^{in}_t - x^{spillage}_t - x^{out}_t), \forall t \geq 2$</span></p><p><strong>Arguments</strong></p><ul><li>psi<em>container::PSIContainer : the psi</em>container model built in PowerSimulations</li><li>initial_conditions::Vector{InitialCondition} : for time zero &#39;varenergy&#39;</li><li>inflow_data::TVector{DeviceTimeSeries} :: Inflow energy forecast information</li><li>cons_name::Symbol : name of the constraint</li><li>var_names::Tuple{Symbol, Symbol, Symbol} : the names of the variables</li><li>: var_names[1] : varspill</li><li>: var_names[2] : varout</li><li>: var_names[3] : varenergy</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/devices_models/devices/common/energy_balance_constraint.jl#L158-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.reservoir_energy_balance_param-Tuple{PowerSimulations.PSIContainer,Array{InitialCondition,1},Array{PowerSimulations.DeviceTimeSeries,1},Symbol,Tuple{Symbol,Symbol,Symbol},PowerSimulations.UpdateRef}" href="#PowerSimulations.reservoir_energy_balance_param-Tuple{PowerSimulations.PSIContainer,Array{InitialCondition,1},Array{PowerSimulations.DeviceTimeSeries,1},Symbol,Tuple{Symbol,Symbol,Symbol},PowerSimulations.UpdateRef}"><code>PowerSimulations.reservoir_energy_balance_param</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">reservoir_energy_balance(psi_container::PSIContainer,
                    initial_conditions::Vector{InitialCondition},
                    efficiency_data::Tuple{Vector{String}, Vector{InOut}},
                    cons_name::Symbol,
                    var_names::Tuple{Symbol, Symbol, Symbol})</code></pre><p>Constructs multi-timestep constraint from initial condition, efficiency data, and variable tuple</p><p><strong>Constraints</strong></p><p>If t = 1: <code>varenergy[name, 1] == initial_conditions[ix].value + (paraminflow[name, t] - varspill[name, 1] - varout[name, 1])*fraction_of_hour</code> If t &gt; 1: <code>varenergy[name, t] == varenergy[name, t-1] + (paraminflow[name, t] - varspill[name, t] - varout[name, t])*fraction_of_hour</code></p><p><strong>LaTeX</strong></p><p><span>$x^{energy}_1 == x^{energy}_{init} + frhr  (x^{in}_1 - x^{spillage}_1 -  x^{out}_1), \text{ for } t = 1$</span> <span>$x^{energy}_t == x^{energy}_{t-1} + frhr (x^{in}_t - x^{spillage}_t - x^{out}_t), \forall t \geq 2$</span></p><p><strong>Arguments</strong></p><ul><li>psi<em>container::PSIContainer : the psi</em>container model built in PowerSimulations</li><li>initial_conditions::Vector{InitialCondition} : for time zero &#39;varenergy&#39;</li><li>inflow_data::Vector{DeviceTimeSeries} :: Inflow energy forecast information</li><li>cons_name::Symbol : name of the constraint</li><li>var_names::Tuple{Symbol, Symbol, Symbol} : the names of the variables</li><li>: var_names[1] : varspill</li><li>: var_names[2] : varout</li><li>: var_names[3] : varenergy</li><li>param_reference::UpdateRef : UpdateRef to access the inflow parameter</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/devices_models/devices/common/energy_balance_constraint.jl#L83-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.semicontinuousrange_ff-Tuple{PowerSimulations.PSIContainer,Symbol,PowerSimulations.UpdateRef,Symbol}" href="#PowerSimulations.semicontinuousrange_ff-Tuple{PowerSimulations.PSIContainer,Symbol,PowerSimulations.UpdateRef,Symbol}"><code>PowerSimulations.semicontinuousrange_ff</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">        semicontinuousrange_ff(psi_container::PSIContainer,
                                cons_name::Symbol,
                                var_name::Symbol,
                                param_reference::UpdateRef)</code></pre><p>Constructs min/max range constraint from device variable with parameter setting.</p><p><strong>Constraints</strong></p><p>If device min = 0:</p><p><code>variable[var_name, t] &lt;= r[2].max*param_reference[var_name]</code></p><p>Otherwise:</p><p><code>variable[var_name, t] &lt;= r[2].max*param_reference[var_name]</code></p><p><code>variable[var_name, t] &gt;= r[2].min*param_reference[var_name]</code></p><p>where r in range_data.</p><p><strong>LaTeX</strong></p><p><span>$0.0 \leq x^{var} \leq r^{max} x^{param}, \text{ for } r^{min} = 0$</span></p><p><span>$r^{min} x^{param} \leq x^{var} \leq r^{min} x^{param}, \text{ otherwise }$</span></p><p><strong>Arguments</strong></p><ul><li>psi<em>container::PSIContainer : the psi</em>container model built in PowerSimulations</li><li>cons_name::Symbol : name of the constraint</li><li>var_name::Symbol : the name of the continuous variable</li><li>param_reference::UpdateRef : UpdateRef of the parameter</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/core/feedforward.jl#L295-L327">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.serialize-Tuple{Simulation}" href="#PowerSimulations.serialize-Tuple{Simulation}"><code>PowerSimulations.serialize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">serialize(simulation::Simulation, path = &quot;.&quot;)</code></pre><p>Serialize the simulation to a directory in path.</p><p>Return the serialized simulation directory name that is created.</p><p><strong>Arguments</strong></p><ul><li><code>simulation::Simulation</code>: simulation to serialize</li><li><code>path = &quot;.&quot;</code>: path in which to create the serialzed directory</li><li><code>force = false</code>: If true, delete the directory if it already exists. Otherwise, it will  throw an exception.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/core/simulation.jl#L894-L906">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.set_variable_bounds!-Union{Tuple{T}, Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceRange,1},AbstractString,Type{T}}} where T&lt;:PowerSystems.Device" href="#PowerSimulations.set_variable_bounds!-Union{Tuple{T}, Tuple{PowerSimulations.PSIContainer,Array{PowerSimulations.DeviceRange,1},AbstractString,Type{T}}} where T&lt;:PowerSystems.Device"><code>PowerSimulations.set_variable_bounds!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_variable_bounds!(
    psi_container::PSIContainer,
    bounds::DeviceRange,
    var_type::AbstractString,
    device_type::Type{PSY.Device},
)</code></pre><p>Adds a bounds to a variable in the optimization model.</p><p><strong>Bounds</strong></p><p><code>bounds.min &lt;= varstart[name, t] &lt;= bounds.max</code></p><p><strong>LaTeX</strong></p><p><span>$x^{device}_t &gt;= bound^{min;} \forall t$</span></p><p><span>$x^{device}_t &lt;= bound^{max} \forall t$</span></p><p><strong>Arguments</strong></p><ul><li>psi<em>container::PSIContainer : the psi</em>container model built in PowerSimulations</li><li>bounds::DeviceRange : contains names and vector of min / max</li><li>var_type::AbstractString : type of the variable</li><li>T: type of the device</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/devices_models/devices/common/add_variable.jl#L90-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.status_init-Union{Tuple{T}, Tuple{PowerSimulations.InitialConditions,InfrastructureSystems.FlattenIteratorWrapper{T}}} where T&lt;:PowerSystems.ThermalGen" href="#PowerSimulations.status_init-Union{Tuple{T}, Tuple{PowerSimulations.InitialConditions,InfrastructureSystems.FlattenIteratorWrapper{T}}} where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.status_init</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Status Init is always calculated based on the Power Output of the device This is to make it easier to calculate when the previous model doesn&#39;t contain binaries. For instance, looking back on an ED model to find the IC of the UC model</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/core/update_initial_conditions.jl#L83-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.ub_ff-Tuple{PowerSimulations.PSIContainer,Symbol,PowerSimulations.UpdateRef,Symbol}" href="#PowerSimulations.ub_ff-Tuple{PowerSimulations.PSIContainer,Symbol,PowerSimulations.UpdateRef,Symbol}"><code>PowerSimulations.ub_ff</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">    ub_ff(psi_container::PSIContainer,
          cons_name::Symbol,
          param_reference::UpdateRef,
          var_name::Symbol)</code></pre><p>Constructs a parametrized upper bound constraint to implement feedforward from other models. The Parameters are initialized using the uppper boundary values of the provided variables.</p><p><strong>Constraints</strong></p><p><code>variable[var_name, t] &lt;= param_reference[var_name]</code></p><p><strong>LaTeX</strong></p><p><span>$x \leq param^{max}$</span></p><p><strong>Arguments</strong></p><ul><li>psi<em>container::PSIContainer : the psi</em>container model built in PowerSimulations</li><li>cons_name::Symbol : name of the constraint</li><li>param_reference : Reference to the PJ.ParameterRef used to determine the upperbound</li><li>var_name::Symbol : the name of the continuous variable</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/core/feedforward.jl#L170-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.update_parameter!-Tuple{PowerSimulations.UpdateRef{JuMP.VariableRef},PowerSimulations.ParameterContainer,Stage,Simulation}" href="#PowerSimulations.update_parameter!-Tuple{PowerSimulations.UpdateRef{JuMP.VariableRef},PowerSimulations.ParameterContainer,Stage,Simulation}"><code>PowerSimulations.update_parameter!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Updates the forecast parameter value</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/core/simulation.jl#L712">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.update_stage!-Union{Tuple{M}, Tuple{Stage{M},Simulation}} where M&lt;:PowerSimulations.AbstractOperationsProblem" href="#PowerSimulations.update_stage!-Union{Tuple{M}, Tuple{Stage{M},Simulation}} where M&lt;:PowerSimulations.AbstractOperationsProblem"><code>PowerSimulations.update_stage!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Generic Stage update function for most problems with no customization</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/core/simulation.jl#L761">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.variable_active_net_injection-Tuple{PowerModels.AbstractPowerModel}" href="#PowerSimulations.variable_active_net_injection-Tuple{PowerModels.AbstractPowerModel}"><code>PowerSimulations.variable_active_net_injection</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/network_models/powermodels_interface.jl#L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.variable_net_injection-Tuple{PowerModels.AbstractPowerModel}" href="#PowerSimulations.variable_net_injection-Tuple{PowerModels.AbstractPowerModel}"><code>PowerSimulations.variable_net_injection</code></a> — <span class="docstring-category">Method</span></header><section><div><p>generates variables for both <code>active</code> and <code>reactive</code> net injection</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/network_models/powermodels_interface.jl#L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.variable_reactive_net_injection-Tuple{PowerModels.AbstractActivePowerModel}" href="#PowerSimulations.variable_reactive_net_injection-Tuple{PowerModels.AbstractActivePowerModel}"><code>PowerSimulations.variable_reactive_net_injection</code></a> — <span class="docstring-category">Method</span></header><section><div><p>active power only models ignore reactive power variables</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/network_models/powermodels_interface.jl#L232">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.variable_reactive_net_injection-Tuple{PowerModels.AbstractPowerModel}" href="#PowerSimulations.variable_reactive_net_injection-Tuple{PowerModels.AbstractPowerModel}"><code>PowerSimulations.variable_reactive_net_injection</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSimulations.jl/blob/48765c4ef2324cb635f18b494aece31151a62f6c/src/network_models/powermodels_interface.jl#L119">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../man/simulation_recorder/">« Simulation Recorder</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 23 April 2020 21:28">Thursday 23 April 2020</span>. Using Julia version 1.3.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
