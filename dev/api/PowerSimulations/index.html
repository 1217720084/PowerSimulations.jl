<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>PowerSimulations · PowerSimulations.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="PowerSimulations.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">PowerSimulations.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../../man/op_problem/">Operation Model</a></li><li><span class="tocitem">API</span><ul><li class="is-active"><a class="tocitem" href>PowerSimulations</a><ul class="internal"><li><a class="tocitem" href="#Index-1"><span>Index</span></a></li><li><a class="tocitem" href="#Exported-1"><span>Exported</span></a></li><li><a class="tocitem" href="#Internal-1"><span>Internal</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>PowerSimulations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>PowerSimulations</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/NREL/PowerSimulations.jl/blob/master/docs/src/api/PowerSimulations.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="PowerSimulations-1"><a class="docs-heading-anchor" href="#PowerSimulations-1">PowerSimulations</a><a class="docs-heading-anchor-permalink" href="#PowerSimulations-1" title="Permalink"></a></h1><p>API documentation</p><ul><li><a href="#PowerSimulations-1">PowerSimulations</a></li><ul><li><a href="#Index-1">Index</a></li><li><a href="#Exported-1">Exported</a></li><li><a href="#Internal-1">Internal</a></li></ul></ul><h2 id="Index-1"><a class="docs-heading-anchor" href="#Index-1">Index</a><a class="docs-heading-anchor-permalink" href="#Index-1" title="Permalink"></a></h2><ul><li><a href="#PowerSimulations.DeviceModel-Union{Tuple{B}, Tuple{D}, Tuple{Type{D},Type{B}}} where B&lt;:PowerSimulations.AbstractDeviceFormulation where D&lt;:PowerSystems.Device"><code>PowerSimulations.DeviceModel</code></a></li><li><a href="#PowerSimulations.OperationsProblem-Union{Tuple{M}, Tuple{Type{M},OperationsTemplate,PowerSystems.System}} where M&lt;:PowerSimulations.AbstractOperationsProblem"><code>PowerSimulations.OperationsProblem</code></a></li><li><a href="#PowerSimulations.OperationsProblem-Union{Tuple{T}, Tuple{Type{T},PowerSystems.System}} where T&lt;:PowerModels.AbstractPowerModel"><code>PowerSimulations.OperationsProblem</code></a></li><li><a href="#PowerSimulations.OperationsProblem-Union{Tuple{T}, Tuple{M}, Tuple{Type{M},Type{T},PowerSystems.System}} where T&lt;:PowerModels.AbstractPowerModel where M&lt;:PowerSimulations.AbstractOperationsProblem"><code>PowerSimulations.OperationsProblem</code></a></li><li><a href="#PowerSimulations.OperationsTemplate-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:PowerModels.AbstractPowerModel"><code>PowerSimulations.OperationsTemplate</code></a></li><li><a href="#PowerSimulations.TimeStatusChange"><code>PowerSimulations.TimeStatusChange</code></a></li><li><a href="#PowerSimulations.UpdateRef"><code>PowerSimulations.UpdateRef</code></a></li><li><a href="#Base.show-Tuple{IO,MIME{Symbol(&quot;text/plain&quot;)},OperationsProblem}"><code>Base.show</code></a></li><li><a href="#PowerSimulations._container_spec-Union{Tuple{M}, Tuple{M,Vararg{Any,N} where N}} where M&lt;:JuMP.AbstractModel"><code>PowerSimulations._container_spec</code></a></li><li><a href="#PowerSimulations._get_data_for_rocc-Tuple{Array{InitialCondition,1},Dates.Period}"><code>PowerSimulations._get_data_for_rocc</code></a></li><li><a href="#PowerSimulations._get_data_for_tdc-Tuple{Array{InitialCondition,1},Array{InitialCondition,1},Dates.Period}"><code>PowerSimulations._get_data_for_tdc</code></a></li><li><a href="#PowerSimulations._pwl_cost-Union{Tuple{JV}, Tuple{PowerSimulations.Canonical,JV,Array{Tuple{Float64,Float64},1}}} where JV&lt;:JuMP.AbstractVariableRef"><code>PowerSimulations._pwl_cost</code></a></li><li><a href="#PowerSimulations._pwlgencost_linear-Union{Tuple{JV}, Tuple{PowerSimulations.Canonical,JV,Array{Tuple{Float64,Float64},1}}} where JV&lt;:JuMP.AbstractVariableRef"><code>PowerSimulations._pwlgencost_linear</code></a></li><li><a href="#PowerSimulations._pwlgencost_sos-Union{Tuple{JV}, Tuple{PowerSimulations.Canonical,JV,Array{Tuple{Float64,Float64},1}}} where JV&lt;:JuMP.AbstractVariableRef"><code>PowerSimulations._pwlgencost_sos</code></a></li><li><a href="#PowerSimulations._pwlparamcheck-Tuple{Any}"><code>PowerSimulations._pwlparamcheck</code></a></li><li><a href="#PowerSimulations._retrieve_forecasts-Union{Tuple{C}, Tuple{PowerSystems.System,Type{C}}} where C&lt;:PowerSystems.Component"><code>PowerSimulations._retrieve_forecasts</code></a></li><li><a href="#PowerSimulations._write_canonical-Tuple{PowerSimulations.Canonical,String}"><code>PowerSimulations._write_canonical</code></a></li><li><a href="#PowerSimulations.activepower_constraints!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.Canonical,InfrastructureSystems.FlattenIteratorWrapper{T},Type{ThermalDispatchNoMin},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.activepower_constraints!</code></a></li><li><a href="#PowerSimulations.activepower_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.Canonical,InfrastructureSystems.FlattenIteratorWrapper{T},Type{D},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where D&lt;:PowerSimulations.AbstractThermalDispatchFormulation where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.activepower_constraints!</code></a></li><li><a href="#PowerSimulations.activepower_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.Canonical,InfrastructureSystems.FlattenIteratorWrapper{T},Type{D},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where D&lt;:PowerSimulations.AbstractThermalFormulation where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.activepower_constraints!</code></a></li><li><a href="#PowerSimulations.activepower_variables!-Union{Tuple{T}, Tuple{PowerSimulations.Canonical,InfrastructureSystems.FlattenIteratorWrapper{T}}} where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.activepower_variables!</code></a></li><li><a href="#PowerSimulations.activeservice_variables!-Union{Tuple{SR}, Tuple{PowerSimulations.Canonical,SR,Array{#s255,1} where #s255&lt;:PowerSystems.Device}} where SR&lt;:PowerSystems.Reserve"><code>PowerSimulations.activeservice_variables!</code></a></li><li><a href="#PowerSimulations.add_to_cost-Union{Tuple{D}, Tuple{PowerSimulations.Canonical,D,Symbol,Symbol}, Tuple{PowerSimulations.Canonical,D,Symbol,Symbol,Float64}} where D&lt;:(InfrastructureSystems.FlattenIteratorWrapper{#s54} where #s54&lt;:PowerSystems.Device)"><code>PowerSimulations.add_to_cost</code></a></li><li><a href="#PowerSimulations.add_variable-Union{Tuple{D}, Tuple{PowerSimulations.Canonical,D,Symbol,Bool}, Tuple{PowerSimulations.Canonical,D,Symbol,Bool,Union{Nothing, Symbol}}, Tuple{PowerSimulations.Canonical,D,Symbol,Bool,Union{Nothing, Symbol},Float64}} where D&lt;:Union{Array{#s255,1} where #s255&lt;:PowerSystems.Device, InfrastructureSystems.FlattenIteratorWrapper{#s256} where #s256&lt;:PowerSystems.Device}"><code>PowerSimulations.add_variable</code></a></li><li><a href="#PowerSimulations.build_nip_expr_model-Tuple{Dict{String,Any},Any}"><code>PowerSimulations.build_nip_expr_model</code></a></li><li><a href="#PowerSimulations.build_nip_model-Tuple{Dict{String,Any},Any}"><code>PowerSimulations.build_nip_model</code></a></li><li><a href="#PowerSimulations.columnsum-Tuple{DataFrames.DataFrame}"><code>PowerSimulations.columnsum</code></a></li><li><a href="#PowerSimulations.commitment_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.Canonical,InfrastructureSystems.FlattenIteratorWrapper{T},Type{D},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where D&lt;:PowerSimulations.AbstractThermalFormulation where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.commitment_constraints!</code></a></li><li><a href="#PowerSimulations.commitment_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{H}, Tuple{PowerSimulations.Canonical,InfrastructureSystems.FlattenIteratorWrapper{H},Type{D},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where D&lt;:PowerSimulations.AbstractHydroUnitCommitment where H&lt;:PowerSystems.HydroGen"><code>PowerSimulations.commitment_constraints!</code></a></li><li><a href="#PowerSimulations.commitment_variables!-Union{Tuple{T}, Tuple{PowerSimulations.Canonical,InfrastructureSystems.FlattenIteratorWrapper{T}}} where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.commitment_variables!</code></a></li><li><a href="#PowerSimulations.commitment_variables!-Union{Tuple{H}, Tuple{PowerSimulations.Canonical,InfrastructureSystems.FlattenIteratorWrapper{H}}} where H&lt;:PowerSystems.HydroGen"><code>PowerSimulations.commitment_variables!</code></a></li><li><a href="#PowerSimulations.constraint_power_balance_ni-Tuple{PowerModels.AbstractActivePowerModel,Int64,Int64,Int64,Any,Any}"><code>PowerSimulations.constraint_power_balance_ni</code></a></li><li><a href="#PowerSimulations.constraint_power_balance_ni-Tuple{PowerModels.AbstractPowerModel,Int64}"><code>PowerSimulations.constraint_power_balance_ni</code></a></li><li><a href="#PowerSimulations.constraint_power_balance_ni-Tuple{PowerModels.AbstractPowerModel,Int64,Int64,Int64,Any,Any}"><code>PowerSimulations.constraint_power_balance_ni</code></a></li><li><a href="#PowerSimulations.constraint_power_balance_ni_expr-Tuple{PowerModels.AbstractPowerModel,Int64,Int64,Int64,Any,Any,Any,Any}"><code>PowerSimulations.constraint_power_balance_ni_expr</code></a></li><li><a href="#PowerSimulations.constraint_power_balance_ni_expr-Tuple{PowerModels.AbstractActivePowerModel,Int64,Int64,Int64,Any,Any,Any,Any}"><code>PowerSimulations.constraint_power_balance_ni_expr</code></a></li><li><a href="#PowerSimulations.constraint_power_balance_ni_expr-Tuple{PowerModels.AbstractPowerModel,Int64}"><code>PowerSimulations.constraint_power_balance_ni_expr</code></a></li><li><a href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.Canonical,PowerSystems.System,DeviceModel{T,ThermalBasicUnitCommitment},Type{S}}} where S&lt;:PowerModels.AbstractActivePowerModel where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.construct_device!</code></a></li><li><a href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.Canonical,PowerSystems.System,DeviceModel{T,D},Type{S}}} where S&lt;:PowerModels.AbstractActivePowerModel where D&lt;:PowerSimulations.AbstractThermalFormulation where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.construct_device!</code></a></li><li><a href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.Canonical,PowerSystems.System,DeviceModel{T,ThermalRampLimited},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.construct_device!</code></a></li><li><a href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.Canonical,PowerSystems.System,DeviceModel{T,ThermalRampLimited},Type{S}}} where S&lt;:PowerModels.AbstractActivePowerModel where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.construct_device!</code></a></li><li><a href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.Canonical,PowerSystems.System,DeviceModel{T,D},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where D&lt;:PowerSimulations.AbstractThermalFormulation where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.construct_device!</code></a></li><li><a href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.Canonical,PowerSystems.System,DeviceModel{T,ThermalBasicUnitCommitment},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.construct_device!</code></a></li><li><a href="#PowerSimulations.device_commitment-Tuple{PowerSimulations.Canonical,Array{InitialCondition,1},Symbol,Tuple{Symbol,Symbol,Symbol}}"><code>PowerSimulations.device_commitment</code></a></li><li><a href="#PowerSimulations.device_duration_look_ahead-Tuple{PowerSimulations.Canonical,Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{InitialCondition,2},Symbol,Tuple{Symbol,Symbol,Symbol}}"><code>PowerSimulations.device_duration_look_ahead</code></a></li><li><a href="#PowerSimulations.device_duration_parameters-Tuple{PowerSimulations.Canonical,Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{InitialCondition,2},Symbol,Tuple{Symbol,Symbol,Symbol}}"><code>PowerSimulations.device_duration_parameters</code></a></li><li><a href="#PowerSimulations.device_duration_retrospective-Tuple{PowerSimulations.Canonical,Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{InitialCondition,2},Symbol,Tuple{Symbol,Symbol,Symbol}}"><code>PowerSimulations.device_duration_retrospective</code></a></li><li><a href="#PowerSimulations.device_linear_rateofchange-Tuple{PowerSimulations.Canonical,Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{InitialCondition,1},Symbol,Symbol}"><code>PowerSimulations.device_linear_rateofchange</code></a></li><li><a href="#PowerSimulations.device_mixedinteger_rateofchange-Tuple{PowerSimulations.Canonical,Tuple{Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{NamedTuple{(:min, :max),Tuple{Float64,Float64}},1}},Array{InitialCondition,1},Symbol,Tuple{Symbol,Symbol,Symbol}}"><code>PowerSimulations.device_mixedinteger_rateofchange</code></a></li><li><a href="#PowerSimulations.device_range-Tuple{PowerSimulations.Canonical,Array{Tuple{String,NamedTuple{(:min, :max),Tuple{Float64,Float64}}},1},Symbol,Symbol}"><code>PowerSimulations.device_range</code></a></li><li><a href="#PowerSimulations.device_semicontinuousrange-Tuple{PowerSimulations.Canonical,Array{Tuple{String,NamedTuple{(:min, :max),Tuple{Float64,Float64}}},1},Symbol,Symbol,Symbol}"><code>PowerSimulations.device_semicontinuousrange</code></a></li><li><a href="#PowerSimulations.device_timeseries_lb-Tuple{PowerSimulations.Canonical,Array{Tuple{String,Int64,Float64,Array{Float64,1}},1},Symbol,Symbol}"><code>PowerSimulations.device_timeseries_lb</code></a></li><li><a href="#PowerSimulations.device_timeseries_param_lb-Tuple{PowerSimulations.Canonical,Array{Tuple{String,Int64,Float64,Array{Float64,1}},1},Symbol,PowerSimulations.UpdateRef,Symbol}"><code>PowerSimulations.device_timeseries_param_lb</code></a></li><li><a href="#PowerSimulations.device_timeseries_param_ub-Tuple{PowerSimulations.Canonical,Array{Tuple{String,Int64,Float64,Array{Float64,1}},1},Symbol,PowerSimulations.UpdateRef,Symbol}"><code>PowerSimulations.device_timeseries_param_ub</code></a></li><li><a href="#PowerSimulations.device_timeseries_ub-Tuple{PowerSimulations.Canonical,Array{Tuple{String,Int64,Float64,Array{Float64,1}},1},Symbol,Symbol}"><code>PowerSimulations.device_timeseries_ub</code></a></li><li><a href="#PowerSimulations.device_timeseries_ub_bigM"><code>PowerSimulations.device_timeseries_ub_bigM</code></a></li><li><a href="#PowerSimulations.device_timeseries_ub_bin-Tuple{PowerSimulations.Canonical,Array{Tuple{String,Int64,Float64,Array{Float64,1}},1},Symbol,Symbol,Symbol}"><code>PowerSimulations.device_timeseries_ub_bin</code></a></li><li><a href="#PowerSimulations.energy_balance-Tuple{PowerSimulations.Canonical,Array{InitialCondition,1},Tuple{Array{String,1},Array{NamedTuple{(:in, :out),Tuple{Float64,Float64}},1}},Symbol,Tuple{Symbol,Symbol,Symbol}}"><code>PowerSimulations.energy_balance</code></a></li><li><a href="#PowerSimulations.get_all_constraint_index-Tuple{OperationsProblem}"><code>PowerSimulations.get_all_constraint_index</code></a></li><li><a href="#PowerSimulations.get_all_var_index-Tuple{OperationsProblem}"><code>PowerSimulations.get_all_var_index</code></a></li><li><a href="#PowerSimulations.load_operation_results-Tuple{AbstractString}"><code>PowerSimulations.load_operation_results</code></a></li><li><a href="#PowerSimulations.load_simulation_results-Tuple{String,Array,Array,Dict{Any,Any}}"><code>PowerSimulations.load_simulation_results</code></a></li><li><a href="#PowerSimulations.make_references-Tuple{Simulation,String}"><code>PowerSimulations.make_references</code></a></li><li><a href="#PowerSimulations.parameter_update!-Tuple{PowerSimulations.UpdateRef{JuMP.VariableRef},JuMP.Containers.DenseAxisArray{ParameterJuMP.ParameterRef,N,Ax,L} where L&lt;:Tuple{Vararg{Dict,N}} where Ax where N,Int64,Simulation}"><code>PowerSimulations.parameter_update!</code></a></li><li><a href="#PowerSimulations.post_nip-Tuple{PowerModels.AbstractPowerModel}"><code>PowerSimulations.post_nip</code></a></li><li><a href="#PowerSimulations.post_nip_expr-Tuple{PowerModels.AbstractPowerModel}"><code>PowerSimulations.post_nip_expr</code></a></li><li><a href="#PowerSimulations.powermodels_network!-Union{Tuple{S}, Tuple{PowerSimulations.Canonical,Type{S},PowerSystems.System}} where S&lt;:PowerModels.AbstractActivePowerModel"><code>PowerSimulations.powermodels_network!</code></a></li><li><a href="#PowerSimulations.powermodels_network!-Union{Tuple{S}, Tuple{PowerSimulations.Canonical,Type{S},PowerSystems.System}} where S&lt;:PowerModels.AbstractPowerModel"><code>PowerSimulations.powermodels_network!</code></a></li><li><a href="#PowerSimulations.ps_cost-Union{Tuple{JV}, Tuple{PowerSimulations.Canonical,JuMP.Containers.DenseAxisArray{JV,N,Ax,L} where L&lt;:Tuple{Vararg{Dict,N}} where Ax where N,PowerSystems.VariableCost{Array{Tuple{Float64,Float64},1}},Float64,Float64}} where JV&lt;:JuMP.AbstractVariableRef"><code>PowerSimulations.ps_cost</code></a></li><li><a href="#PowerSimulations.ps_cost-Union{Tuple{JV}, Tuple{PowerSimulations.Canonical,JuMP.Containers.DenseAxisArray{JV,N,Ax,L} where L&lt;:Tuple{Vararg{Dict,N}} where Ax where N,PowerSystems.VariableCost{Tuple{Float64,Float64}},Float64,Float64}} where JV&lt;:JuMP.AbstractVariableRef"><code>PowerSimulations.ps_cost</code></a></li><li><a href="#PowerSimulations.ps_cost-Union{Tuple{JV}, Tuple{PowerSimulations.Canonical,JuMP.Containers.DenseAxisArray{JV,N,Ax,L} where L&lt;:Tuple{Vararg{Dict,N}} where Ax where N,PowerSystems.VariableCost{Float64},Float64,Float64}} where JV&lt;:JuMP.AbstractVariableRef"><code>PowerSimulations.ps_cost</code></a></li><li><a href="#PowerSimulations.ps_cost-Union{Tuple{JV}, Tuple{PowerSimulations.Canonical,JuMP.Containers.DenseAxisArray{JV,N,Ax,L} where L&lt;:Tuple{Vararg{Dict,N}} where Ax where N,Float64,Float64,Float64}} where JV&lt;:JuMP.AbstractVariableRef"><code>PowerSimulations.ps_cost</code></a></li><li><a href="#PowerSimulations.ramp_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.Canonical,InfrastructureSystems.FlattenIteratorWrapper{T},Type{D},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where D&lt;:PowerSimulations.AbstractThermalFormulation where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.ramp_constraints!</code></a></li><li><a href="#PowerSimulations.range_ff-Tuple{PowerSimulations.Canonical,Symbol,Tuple{PowerSimulations.UpdateRef,PowerSimulations.UpdateRef},Symbol}"><code>PowerSimulations.range_ff</code></a></li><li><a href="#PowerSimulations.rating_constraint!-Tuple{PowerSimulations.Canonical,Array{Tuple{String,Float64},1},Symbol,Tuple{Symbol,Symbol}}"><code>PowerSimulations.rating_constraint!</code></a></li><li><a href="#PowerSimulations.reactive_power_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{St}, Tuple{PowerSimulations.Canonical,InfrastructureSystems.FlattenIteratorWrapper{St},Type{D},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where D&lt;:PowerSimulations.AbstractStorageFormulation where St&lt;:PowerSystems.Storage"><code>PowerSimulations.reactive_power_constraints!</code></a></li><li><a href="#PowerSimulations.reactivepower_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.Canonical,InfrastructureSystems.FlattenIteratorWrapper{T},Type{D},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where D&lt;:PowerSimulations.AbstractThermalDispatchFormulation where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.reactivepower_constraints!</code></a></li><li><a href="#PowerSimulations.reactivepower_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.Canonical,InfrastructureSystems.FlattenIteratorWrapper{T},Type{D},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where D&lt;:PowerSimulations.AbstractThermalFormulation where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.reactivepower_constraints!</code></a></li><li><a href="#PowerSimulations.reactivepower_constraints!-Union{Tuple{L}, Tuple{PowerSimulations.Canonical,InfrastructureSystems.FlattenIteratorWrapper{L},Type{#s252} where #s252&lt;:PowerSimulations.AbstractControllablePowerLoadFormulation,Type{#s251} where #s251&lt;:PowerModels.AbstractPowerModel}} where L&lt;:PowerSystems.ElectricLoad"><code>PowerSimulations.reactivepower_constraints!</code></a></li><li><a href="#PowerSimulations.reactivepower_variables!-Union{Tuple{T}, Tuple{PowerSimulations.Canonical,InfrastructureSystems.FlattenIteratorWrapper{T}}} where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.reactivepower_variables!</code></a></li><li><a href="#PowerSimulations.remove_chars-Tuple{String,String}"><code>PowerSimulations.remove_chars</code></a></li><li><a href="#PowerSimulations.replace_chars-Tuple{String,String,String}"><code>PowerSimulations.replace_chars</code></a></li><li><a href="#PowerSimulations.reserve_device_semicontinuousrange-Tuple{PowerSimulations.Canonical,Array{Tuple{String,NamedTuple{(:min, :max),Tuple{Float64,Float64}}},1},Symbol,Symbol,Symbol}"><code>PowerSimulations.reserve_device_semicontinuousrange</code></a></li><li><a href="#PowerSimulations.rowsum-Tuple{DataFrames.DataFrame,String}"><code>PowerSimulations.rowsum</code></a></li><li><a href="#PowerSimulations.semicontinuousrange_ff-Tuple{PowerSimulations.Canonical,Symbol,PowerSimulations.UpdateRef,Symbol}"><code>PowerSimulations.semicontinuousrange_ff</code></a></li><li><a href="#PowerSimulations.set_variable_bounds-Tuple{PowerSimulations.Canonical,Array{Tuple{String,NamedTuple{(:min, :max),Tuple{Float64,Float64}}},1},Symbol}"><code>PowerSimulations.set_variable_bounds</code></a></li><li><a href="#PowerSimulations.solve_op_problem!-Tuple{OperationsProblem}"><code>PowerSimulations.solve_op_problem!</code></a></li><li><a href="#PowerSimulations.sort_data-Tuple{PowerSimulations.OperationsProblemResults}"><code>PowerSimulations.sort_data</code></a></li><li><a href="#PowerSimulations.status_init-Union{Tuple{PSD}, Tuple{PowerSimulations.Canonical,InfrastructureSystems.FlattenIteratorWrapper{PSD}}} where PSD&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.status_init</code></a></li><li><a href="#PowerSimulations.ub_ff-Tuple{PowerSimulations.Canonical,Symbol,PowerSimulations.UpdateRef,Symbol}"><code>PowerSimulations.ub_ff</code></a></li><li><a href="#PowerSimulations.variable_active_net_injection-Tuple{PowerModels.AbstractPowerModel}"><code>PowerSimulations.variable_active_net_injection</code></a></li><li><a href="#PowerSimulations.variable_net_injection-Tuple{PowerModels.AbstractPowerModel}"><code>PowerSimulations.variable_net_injection</code></a></li><li><a href="#PowerSimulations.variable_reactive_net_injection-Tuple{PowerModels.AbstractActivePowerModel}"><code>PowerSimulations.variable_reactive_net_injection</code></a></li><li><a href="#PowerSimulations.variable_reactive_net_injection-Tuple{PowerModels.AbstractPowerModel}"><code>PowerSimulations.variable_reactive_net_injection</code></a></li><li><a href="#PowerSimulations.write_model_results-Tuple{PowerSimulations.Results,String}"><code>PowerSimulations.write_model_results</code></a></li><li><a href="#PowerSimulations.write_model_results-Tuple{PowerSimulations.Results,String,String}"><code>PowerSimulations.write_model_results</code></a></li><li><a href="#PowerSimulations.write_op_problem-Tuple{OperationsProblem,String}"><code>PowerSimulations.write_op_problem</code></a></li></ul><h2 id="Exported-1"><a class="docs-heading-anchor" href="#Exported-1">Exported</a><a class="docs-heading-anchor-permalink" href="#Exported-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.DeviceModel-Union{Tuple{B}, Tuple{D}, Tuple{Type{D},Type{B}}} where B&lt;:PowerSimulations.AbstractDeviceFormulation where D&lt;:PowerSystems.Device" href="#PowerSimulations.DeviceModel-Union{Tuple{B}, Tuple{D}, Tuple{Type{D},Type{B}}} where B&lt;:PowerSimulations.AbstractDeviceFormulation where D&lt;:PowerSystems.Device"><code>PowerSimulations.DeviceModel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">DeviceModel(::Type{D}, ::Type{B}) where {D&lt;:PSY.Device,
                                   B&lt;:AbstractDeviceFormulation}</code></pre><p>This validates the device formulation for the Power System Device and the abstract device formulation and returns  Power System Device and the abstract device formulation if the power system device is a concrete type.</p><p><strong>Arguments</strong></p><p>-<code>::Type{D}</code>: Power System Device -<code>::Type{B}</code>: Abstract Device Formulation</p><p><strong>Outputs</strong></p><p><code>DeviceModel(D, B, nothing)</code>: D::PSY.Device, B::AbstractDeviceFormulation</p><p><strong>Example</strong></p><pre><code class="language-julia">branches = Dict{Symbol, DeviceModel}
    (:L =&gt; DeviceModel(PSY.Line, StaticLine),
    :T =&gt; DeviceModel(PSY.Transformer2W, StaticTransformer),
    :TT =&gt; DeviceModel(PSY.TapTransformer , StaticTransformer),
    :dc_line =&gt; DeviceModel(PSY.HVDCLine, HVDCDispatch))</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.OperationsProblem-Union{Tuple{M}, Tuple{Type{M},OperationsTemplate,PowerSystems.System}} where M&lt;:PowerSimulations.AbstractOperationsProblem" href="#PowerSimulations.OperationsProblem-Union{Tuple{M}, Tuple{Type{M},OperationsTemplate,PowerSystems.System}} where M&lt;:PowerSimulations.AbstractOperationsProblem"><code>PowerSimulations.OperationsProblem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">OperationsProblem(::Type{M},
template::OperationsTemplate,
sys::PSY.System;
optimizer::Union{Nothing, JuMP.OptimizerFactory}=nothing,
kwargs...) where {M&lt;:AbstractOperationsProblem,
                  T&lt;:PM.AbstractPowerFormulation}</code></pre><p>This builds the optimization model and populates the operation model</p><p><strong>Arguments</strong></p><p>-<code>::Type{M} where {M&lt;:AbstractOperationsProblem, T&lt;:PM.AbstractPowerFormulation} = TestOpProblem</code>: The abstract operation model type -<code>template::OperationsTemplate</code>: The model reference made up of transmission, devices,                                           branches, and services. -<code>sys::PSY.System</code>: the system created using Power Systems</p><p><strong>Output</strong></p><p>-<code>op_problem::OperationsProblem</code>: The operation model contains the model type, model, Power Systems system, and optimization model.</p><p><strong>Example</strong></p><pre><code class="language-julia">template= OperationsTemplate(CopperPlatePowerModel, devices, branches, services)
OpModel = OperationsProblem(TestOpProblem, template, c_sys5_re; PTDF = PTDF5, optimizer = GLPK_optimizer)</code></pre><p><strong>Accepted Key Words</strong></p><p>-<code>verbose::Bool = true</code>: verbose default is true -<code>PTDF::PTDF = PTDF</code>: Passes the PTDF matrix into the optimization model -<code>optimizer::union{Nothing,JuMP.OptimizerFactory} = GLPK_optimizer</code>: The optimizer gets passed into the optimization model the default is nothing. -<code>initial_conditions::DICKDA = DICKDA()</code>: default of Dict{ICKey, Array{InitialCondition}} -<code>parameters::Bool = false</code>: enable JuMP parameters -<code>use_forecast_data::Bool = true</code>: if true, forecast collects the time steps in Power Systems, if false it runs for one time step -<code>initial_time::Dates.DateTime = PSY.get_forecasts_initial_time(sys)</code>: initial time of forecast</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.OperationsProblem-Union{Tuple{T}, Tuple{M}, Tuple{Type{M},Type{T},PowerSystems.System}} where T&lt;:PowerModels.AbstractPowerModel where M&lt;:PowerSimulations.AbstractOperationsProblem" href="#PowerSimulations.OperationsProblem-Union{Tuple{T}, Tuple{M}, Tuple{Type{M},Type{T},PowerSystems.System}} where T&lt;:PowerModels.AbstractPowerModel where M&lt;:PowerSimulations.AbstractOperationsProblem"><code>PowerSimulations.OperationsProblem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">OperationsProblem(op_problem::Type{M},
                ::Type{T},
                sys::PSY.System;
                kwargs...) where {M&lt;:AbstractOperationsProblem,
                                T&lt;:PM.AbstractPowerFormulation}</code></pre><p>This uses the Abstract Power Formulation to build the model reference and the optimization model and populates the operation model struct.</p><p><strong>Arguments</strong></p><p>-<code>op_problem::Type{M} = where {M&lt;:AbstractOperationsProblem</code>: Defines the type of the operation model -<code>::Type{T} where T&lt;:PM.AbstractPowerFormulation</code>: The power formulation used for model ref &amp; optimization model -<code>sys::PSY.System = c_sys5</code>: the system created in Power Systems</p><p><strong>Output</strong></p><p>-<code>op_problem::OperationsProblem</code>: The operation model contains the model type, model, Power Systems system, and optimization model.</p><p><strong>Example</strong></p><pre><code class="language-julia">template= OperationsTemplate(CopperPlatePowerModel, devices, branches, services)
OpModel = OperationsProblem(TestOpProblem, template, c_sys5_re; PTDF = PTDF5, optimizer = GLPK_optimizer)</code></pre><p><strong>Accepted Key Words</strong></p><p>-<code>verbose::Bool = true</code>: verbose default is true -<code>PTDF::PTDF = PTDF</code>: Passes the PTDF matrix into the optimization model -<code>optimizer::union{Nothing,JuMP.OptimizerFactory}</code>: The optimizer gets passed into the optimization model the default is nothing. -<code>initial_conditions::DICKDA = DICKDA()</code>: default of Dict{ICKey, Array{InitialCondition}} -<code>parameters::Bool = false</code>: enable JuMP parameters -<code>use_forecast_data::Bool = true</code>: if true, forecast collects the time steps in Power Systems, if false it runs for one time step -<code>initial_time::Dates.DateTime = PSY.get_forecasts_initial_time(sys)</code>: initial time of forecast</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.OperationsProblem-Union{Tuple{T}, Tuple{Type{T},PowerSystems.System}} where T&lt;:PowerModels.AbstractPowerModel" href="#PowerSimulations.OperationsProblem-Union{Tuple{T}, Tuple{Type{T},PowerSystems.System}} where T&lt;:PowerModels.AbstractPowerModel"><code>PowerSimulations.OperationsProblem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">OperationsProblem(::Type{T},
                sys::PSY.System;
                kwargs...) where {M&lt;:AbstractOperationsProblem,
                                T&lt;:PM.AbstractPowerFormulation}</code></pre><p>This uses the Abstract Power Formulation to build the model reference and the optimization model and populates the operation model struct.</p><p>***Note:*** the abstract operation model is set to the default operation model</p><p><strong>Arguments</strong></p><p>-<code>op_problem::Type{M}</code>: Defines the type of the operation model -<code>::Type{T} where T&lt;:PM.AbstractPowerFormulation</code>: The power formulation used for model ref &amp; optimization model -<code>sys::PSY.System</code>: the system created in Power Systems</p><p><strong>Output</strong></p><p>-<code>op_problem::OperationsProblem</code>: The operation model contains the model type, model, Power Systems system, and optimization model.</p><p><strong>Example</strong></p><pre><code class="language-julia">template= OperationsTemplate(CopperPlatePowerModel, devices, branches, services)
OpModel = OperationsProblem(TestOpProblem, template, c_sys5_re; PTDF = PTDF5, optimizer = GLPK_optimizer)</code></pre><p><strong>Accepted Key Words</strong></p><p>-<code>verbose::Bool = true</code>: verbose default is true -<code>PTDF::PTDF = PTDF</code>: Passes the PTDF matrix into the optimization model -<code>optimizer::union{Nothing,JuMP.OptimizerFactory}</code>: The optimizer gets passed into the optimization model the default is nothing. -<code>initial_conditions::DICKDA = DICKDA()</code>: default of Dict{ICKey, Array{InitialCondition}} -<code>parameters::Bool = false</code>: enable JuMP parameters -<code>use_forecast_data::Bool = true</code>: if true, forecast collects the time steps in Power Systems, if false it runs for one time step -<code>initial_time::Dates.DateTime</code>: initial time of forecast</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.OperationsTemplate-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:PowerModels.AbstractPowerModel" href="#PowerSimulations.OperationsTemplate-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:PowerModels.AbstractPowerModel"><code>PowerSimulations.OperationsTemplate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">OperationsTemplate(::Type{T}) where {T&lt;:PM.AbstractPowerFormulation}</code></pre><p>Creates a model reference of the Power Formulation, devices, branches, and services.</p><p><strong>Arguments</strong></p><p>-<code>model::Type{T&lt;:PM.AbstractPowerFormulation}</code>: -<code>devices::Dict{Symbol, DeviceModel}</code>: device dictionary -<code>branches::Dict{Symbol, BranchModel}</code>: branch dictionary -<code>services::Dict{Symbol, ServiceModel}</code>: service dictionary</p><p><strong>Example</strong></p><pre><code class="language-julia">template= OperationsTemplate(CopperPlatePowerModel, devices, branches, services)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.TimeStatusChange" href="#PowerSimulations.TimeStatusChange"><code>PowerSimulations.TimeStatusChange</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Tracks the last time status of a device changed in a simulation</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.Canonical,PowerSystems.System,DeviceModel{T,D},Type{S}}} where S&lt;:PowerModels.AbstractActivePowerModel where D&lt;:PowerSimulations.AbstractThermalFormulation where T&lt;:PowerSystems.ThermalGen" href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.Canonical,PowerSystems.System,DeviceModel{T,D},Type{S}}} where S&lt;:PowerModels.AbstractActivePowerModel where D&lt;:PowerSimulations.AbstractThermalFormulation where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function creates the model for a full themal dispatch formulation depending on combination of devices, device<em>formulation and system</em>formulation</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.Canonical,PowerSystems.System,DeviceModel{T,D},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where D&lt;:PowerSimulations.AbstractThermalFormulation where T&lt;:PowerSystems.ThermalGen" href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.Canonical,PowerSystems.System,DeviceModel{T,D},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where D&lt;:PowerSimulations.AbstractThermalFormulation where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function creates the model for a full themal dispatch formulation depending on combination of devices, device<em>formulation and system</em>formulation</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.Canonical,PowerSystems.System,DeviceModel{T,ThermalBasicUnitCommitment},Type{S}}} where S&lt;:PowerModels.AbstractActivePowerModel where T&lt;:PowerSystems.ThermalGen" href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.Canonical,PowerSystems.System,DeviceModel{T,ThermalBasicUnitCommitment},Type{S}}} where S&lt;:PowerModels.AbstractActivePowerModel where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function creates the model for a full themal dispatch formulation depending on combination of devices, device<em>formulation and system</em>formulation</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.Canonical,PowerSystems.System,DeviceModel{T,ThermalBasicUnitCommitment},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where T&lt;:PowerSystems.ThermalGen" href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.Canonical,PowerSystems.System,DeviceModel{T,ThermalBasicUnitCommitment},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function creates the model for a full themal dispatch formulation depending on combination of devices, device<em>formulation and system</em>formulation</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.Canonical,PowerSystems.System,DeviceModel{T,ThermalRampLimited},Type{S}}} where S&lt;:PowerModels.AbstractActivePowerModel where T&lt;:PowerSystems.ThermalGen" href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.Canonical,PowerSystems.System,DeviceModel{T,ThermalRampLimited},Type{S}}} where S&lt;:PowerModels.AbstractActivePowerModel where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function creates the model for a full themal dispatch formulation depending on combination of devices, device<em>formulation and system</em>formulation</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.Canonical,PowerSystems.System,DeviceModel{T,ThermalRampLimited},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where T&lt;:PowerSystems.ThermalGen" href="#PowerSimulations.construct_device!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.Canonical,PowerSystems.System,DeviceModel{T,ThermalRampLimited},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.construct_device!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function creates the model for a full themal dispatch formulation depending on combination of devices, device<em>formulation and system</em>formulation</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.get_all_constraint_index-Tuple{OperationsProblem}" href="#PowerSimulations.get_all_constraint_index-Tuple{OperationsProblem}"><code>PowerSimulations.get_all_constraint_index</code></a> — <span class="docstring-category">Method</span></header><section><div><p>&quot;Each Tuple corresponds to (con<em>name, internal</em>index, moi_index)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.get_all_var_index-Tuple{OperationsProblem}" href="#PowerSimulations.get_all_var_index-Tuple{OperationsProblem}"><code>PowerSimulations.get_all_var_index</code></a> — <span class="docstring-category">Method</span></header><section><div><p>&quot;Each Tuple corresponds to (con<em>name, internal</em>index, moi_index)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.load_operation_results-Tuple{AbstractString}" href="#PowerSimulations.load_operation_results-Tuple{AbstractString}"><code>PowerSimulations.load_operation_results</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">results = load_operation_results(path)</code></pre><p>This function can be used to load results from a folder of results from a single-step problem, or for a single foulder within a simulation.</p><p><strong>Arguments</strong></p><p>-<code>path::AbstractString = folder path</code> -<code>directory::AbstractString = &quot;2019-10-03T09-18-00&quot;</code>: the foulder name that contains feather files of the results.</p><p><strong>Example</strong></p><pre><code class="language-julia">results = load_operation_results(&quot;/Users/test/2019-10-03T09-18-00&quot;)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.load_simulation_results-Tuple{String,Array,Array,Dict{Any,Any}}" href="#PowerSimulations.load_simulation_results-Tuple{String,Array,Array,Dict{Any,Any}}"><code>PowerSimulations.load_simulation_results</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">load_simulation_results(stage, step,variable,references)</code></pre><p>This function goes through the reference table of file paths and aggregates the results over time into a struct of type OperationsProblemResults for the desired step range and variables</p><p><strong>Arguments</strong></p><p>-<code>stage::String = &quot;stage-1&quot;</code><code>: The stage of the results getting parsed, stage-1 or stage-2 -</code>step::Array{String} = [&quot;step-1&quot;, &quot;step-2&quot;, &quot;step-3&quot;]<code>: the steps of the results getting parsed -</code>variable::Array{Symbol} = [:P<em>ThermalStandard, :P</em>RenewableDispatch]<code>: the variables to be parsed -</code>references::Dict = ref`: the reference dictionary created in execute! or with make_references</p><p><strong>Example</strong></p><pre><code class="language-julia">stage = &quot;stage-1&quot;
step = [&quot;step-1&quot;,&quot;step-2&quot;, &quot;step-3&quot;] # has to match the date range
variable = [:P_ThermalStandard, :P_RenewableDispatch]
results = load_simulation_results(stage,step, variable, references)</code></pre><p><strong>Accepted Key Words</strong></p><p>-<code>write::Bool</code>: if true, the aggregated results get written back to the results file in the folder structure</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.solve_op_problem!-Tuple{OperationsProblem}" href="#PowerSimulations.solve_op_problem!-Tuple{OperationsProblem}"><code>PowerSimulations.solve_op_problem!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">solve_op_problem!(op_problem::OperationsProblem; kwargs...)</code></pre><p>This solves the operational model for a single instance and outputs results of type OperationsProblemResult: objective value, time log, a dictionary of variables and their dataframe of results, and a time stamp.</p><p><strong>Arguments</strong></p><p>-<code>op_problem::OperationModel = op_problem</code>: operation model</p><p><strong>Examples</strong></p><pre><code class="language-julia">results = solve_op_problem!(OpModel)</code></pre><p><strong>Accepted Key Words</strong></p><p>-<code>save_path::String</code>: If a file path is provided the results automatically get written to feather files -<code>optimizer::OptimizerFactory</code>: The optimizer that is used to solve the model</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.sort_data-Tuple{PowerSimulations.OperationsProblemResults}" href="#PowerSimulations.sort_data-Tuple{PowerSimulations.OperationsProblemResults}"><code>PowerSimulations.sort_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sort_data(results::OperationsProblemResults)</code></pre><p>This function takes in struct OperationsProblemResults, sorts the generators in each variable, and outputs the sorted results. The generic function sorts the generators alphabetically.</p><p><strong>Arguments</strong></p><p>-<code>results::OperationsProblemResults</code>: the results of the simulation</p><p><strong>Accepted Key Words</strong></p><p>-<code>Variables</code> to choose which variables to be sorted.</p><p>#Examples</p><pre><code class="language-julia">new_results = sort_data(results)</code></pre><p>***Note:*** only the generators included in &#39;my_order&#39; will be in the results, and consequently, only these will be plotted. This can be a nice feature for variables with more than 5 generators.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.write_op_problem-Tuple{OperationsProblem,String}" href="#PowerSimulations.write_op_problem-Tuple{OperationsProblem,String}"><code>PowerSimulations.write_op_problem</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Exports the OpModel JuMP object in MathOptFormat</p></div></section></article><h2 id="Internal-1"><a class="docs-heading-anchor" href="#Internal-1">Internal</a><a class="docs-heading-anchor-permalink" href="#Internal-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.UpdateRef" href="#PowerSimulations.UpdateRef"><code>PowerSimulations.UpdateRef</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Reference for parameters update when present</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.show-Tuple{IO,MIME{Symbol(&quot;text/plain&quot;)},OperationsProblem}" href="#Base.show-Tuple{IO,MIME{Symbol(&quot;text/plain&quot;)},OperationsProblem}"><code>Base.show</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.show(io::IO, ::MIME&quot;text/plain&quot;, op_problem::OperationsProblem)</code></pre><p>This function goes through the fields in OperationsProblem and then in OperationsTemplate, if the field contains a Device model dictionary, it calls organize<em>device</em>model() &amp; prints the data by field, key, value. If the field is not a Device model dictionary, and a value exists for that field it prints the value.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations._container_spec-Union{Tuple{M}, Tuple{M,Vararg{Any,N} where N}} where M&lt;:JuMP.AbstractModel" href="#PowerSimulations._container_spec-Union{Tuple{M}, Tuple{M,Vararg{Any,N} where N}} where M&lt;:JuMP.AbstractModel"><code>PowerSimulations._container_spec</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns the correct container spec for the selected type of JuMP Model</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations._get_data_for_rocc-Tuple{Array{InitialCondition,1},Dates.Period}" href="#PowerSimulations._get_data_for_rocc-Tuple{Array{InitialCondition,1},Dates.Period}"><code>PowerSimulations._get_data_for_rocc</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function gets the data for the generators</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations._get_data_for_tdc-Tuple{Array{InitialCondition,1},Array{InitialCondition,1},Dates.Period}" href="#PowerSimulations._get_data_for_tdc-Tuple{Array{InitialCondition,1},Array{InitialCondition,1},Dates.Period}"><code>PowerSimulations._get_data_for_tdc</code></a> — <span class="docstring-category">Method</span></header><section><div><p>If the fraction of hours that a generator has a duration constraint is less than the fraction of hours that a single time_step represents then it is not binding.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations._pwl_cost-Union{Tuple{JV}, Tuple{PowerSimulations.Canonical,JV,Array{Tuple{Float64,Float64},1}}} where JV&lt;:JuMP.AbstractVariableRef" href="#PowerSimulations._pwl_cost-Union{Tuple{JV}, Tuple{PowerSimulations.Canonical,JV,Array{Tuple{Float64,Float64},1}}} where JV&lt;:JuMP.AbstractVariableRef"><code>PowerSimulations._pwl_cost</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_gen_cost(cost_)</code></pre><p>Returns JuMP expression for a piecewise linear cost function depending on the data compatibility.</p><p>Returns <code>gen_cost</code></p><p><strong>Arguments</strong></p><ul><li>canonical::Canonical : the canonical model built in PowerSimulations</li><li>variable::JuMP.Containers.DenseAxisArray{JV} : variable array</li><li>cost_component::PSY.VariableCost{NTuple{2, Float64}} : container for quadratic and linear factors</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations._pwlgencost_linear-Union{Tuple{JV}, Tuple{PowerSimulations.Canonical,JV,Array{Tuple{Float64,Float64},1}}} where JV&lt;:JuMP.AbstractVariableRef" href="#PowerSimulations._pwlgencost_linear-Union{Tuple{JV}, Tuple{PowerSimulations.Canonical,JV,Array{Tuple{Float64,Float64},1}}} where JV&lt;:JuMP.AbstractVariableRef"><code>PowerSimulations._pwlgencost_linear</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_pwlgencost_sos(canonical::Canonical,
            variable::JuMP.Containers.DenseAxisArray{JV},
            cost_component::PSY.VariableCost{NTuple{2, Float64}}) where {JV &lt;: JuMP.AbstractVariableRef}</code></pre><p>Returns piecewise cost expression using linear implementation for canonical model.</p><p><strong>Equations</strong></p><p><code>0 &lt;= pwl_var[i] &lt;= (cost_component[2][i] - cost_component[2][i-1])</code></p><p><code>variable = sum(pwl_var[i])</code></p><p><code>gen_cost = sum(pwl_var[i]*cost_component[1][i]/cost_component[2][i])</code></p><p><strong>LaTeX</strong></p><p><span>$0 &lt;= pwl_i &lt;= (c_{2, i} - c_{2, i-1})$</span></p><p><span>$variable = (sum_{i\in I} pwl_i)$</span></p><p><span>$gen_cost = (sum_{i\in I}  pwl_i) c_{1, i}/c_{2, i}$</span></p><p>Returns <code>gen_cost</code></p><p><strong>Arguments</strong></p><ul><li>canonical::Canonical : the canonical model built in PowerSimulations</li><li>variable::JuMP.Containers.DenseAxisArray{JV} : variable array</li><li>cost_component::PSY.VariableCost{NTuple{2, Float64}} : container for quadratic and linear factors</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations._pwlgencost_sos-Union{Tuple{JV}, Tuple{PowerSimulations.Canonical,JV,Array{Tuple{Float64,Float64},1}}} where JV&lt;:JuMP.AbstractVariableRef" href="#PowerSimulations._pwlgencost_sos-Union{Tuple{JV}, Tuple{PowerSimulations.Canonical,JV,Array{Tuple{Float64,Float64},1}}} where JV&lt;:JuMP.AbstractVariableRef"><code>PowerSimulations._pwlgencost_sos</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_pwlgencost_sos(canonical::Canonical,
            variable::JuMP.Containers.DenseAxisArray{JV},
            cost_component::PSY.VariableCost{NTuple{2, Float64}}) where {JV &lt;: JuMP.AbstractVariableRef}</code></pre><p>Returns piecewise cost expression using SOS Type-2 implementation for canonical model.</p><p><strong>Equations</strong></p><p><code>variable = sum(sos_var[i]*cost_component[2][i])</code></p><p><code>gen_cost = sum(sos_var[i]*cost_component[1][i])</code></p><p><strong>LaTeX</strong></p><p><span>$variable = (sum_{i\in I} c_{2, i} sos_i)$</span></p><p><span>$gen_cost = (sum_{i\in I} c_{1, i} sos_i)$</span></p><p>Returns <code>gen_cost</code></p><p><strong>Arguments</strong></p><ul><li>canonical::Canonical : the canonical model built in PowerSimulations</li><li>variable::JuMP.Containers.DenseAxisArray{JV} : variable array</li><li>cost_component::PSY.VariableCost{NTuple{2, Float64}} : container for quadratic and linear factors</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations._pwlparamcheck-Tuple{Any}" href="#PowerSimulations._pwlparamcheck-Tuple{Any}"><code>PowerSimulations._pwlparamcheck</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_pwlparamcheck(cost_)</code></pre><p>Returns True/False depending on compatibility of the cost data with the linear implementation method</p><p>Returns <code>flag</code></p><p><strong>Arguments</strong></p><ul><li>cost_::PSY.VariableCost{NTuple{2, Float64}} : container for quadratic and linear factors</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations._retrieve_forecasts-Union{Tuple{C}, Tuple{PowerSystems.System,Type{C}}} where C&lt;:PowerSystems.Component" href="#PowerSimulations._retrieve_forecasts-Union{Tuple{C}, Tuple{PowerSystems.System,Type{C}}} where C&lt;:PowerSystems.Component"><code>PowerSimulations._retrieve_forecasts</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Only used when building the model</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations._write_canonical-Tuple{PowerSimulations.Canonical,String}" href="#PowerSimulations._write_canonical-Tuple{PowerSimulations.Canonical,String}"><code>PowerSimulations._write_canonical</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Exports the OpModel JuMP object in MathOptFormat</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.activepower_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.Canonical,InfrastructureSystems.FlattenIteratorWrapper{T},Type{D},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where D&lt;:PowerSimulations.AbstractThermalDispatchFormulation where T&lt;:PowerSystems.ThermalGen" href="#PowerSimulations.activepower_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.Canonical,InfrastructureSystems.FlattenIteratorWrapper{T},Type{D},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where D&lt;:PowerSimulations.AbstractThermalDispatchFormulation where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.activepower_constraints!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function adds the active power limits of generators when there are no CommitmentVariables</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.activepower_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.Canonical,InfrastructureSystems.FlattenIteratorWrapper{T},Type{D},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where D&lt;:PowerSimulations.AbstractThermalFormulation where T&lt;:PowerSystems.ThermalGen" href="#PowerSimulations.activepower_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.Canonical,InfrastructureSystems.FlattenIteratorWrapper{T},Type{D},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where D&lt;:PowerSimulations.AbstractThermalFormulation where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.activepower_constraints!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function adds the active power limits of generators when there are CommitmentVariables</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.activepower_constraints!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.Canonical,InfrastructureSystems.FlattenIteratorWrapper{T},Type{ThermalDispatchNoMin},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where T&lt;:PowerSystems.ThermalGen" href="#PowerSimulations.activepower_constraints!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.Canonical,InfrastructureSystems.FlattenIteratorWrapper{T},Type{ThermalDispatchNoMin},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.activepower_constraints!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function adds the active power limits of generators when there are     no CommitmentVariables</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.activepower_variables!-Union{Tuple{T}, Tuple{PowerSimulations.Canonical,InfrastructureSystems.FlattenIteratorWrapper{T}}} where T&lt;:PowerSystems.ThermalGen" href="#PowerSimulations.activepower_variables!-Union{Tuple{T}, Tuple{PowerSimulations.Canonical,InfrastructureSystems.FlattenIteratorWrapper{T}}} where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.activepower_variables!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function add the variables for power generation output to the model</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.activeservice_variables!-Union{Tuple{SR}, Tuple{PowerSimulations.Canonical,SR,Array{#s255,1} where #s255&lt;:PowerSystems.Device}} where SR&lt;:PowerSystems.Reserve" href="#PowerSimulations.activeservice_variables!-Union{Tuple{SR}, Tuple{PowerSimulations.Canonical,SR,Array{#s255,1} where #s255&lt;:PowerSystems.Device}} where SR&lt;:PowerSystems.Reserve"><code>PowerSimulations.activeservice_variables!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function add the variables for reserves to the model</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.add_to_cost-Union{Tuple{D}, Tuple{PowerSimulations.Canonical,D,Symbol,Symbol}, Tuple{PowerSimulations.Canonical,D,Symbol,Symbol,Float64}} where D&lt;:(InfrastructureSystems.FlattenIteratorWrapper{#s54} where #s54&lt;:PowerSystems.Device)" href="#PowerSimulations.add_to_cost-Union{Tuple{D}, Tuple{PowerSimulations.Canonical,D,Symbol,Symbol}, Tuple{PowerSimulations.Canonical,D,Symbol,Symbol,Float64}} where D&lt;:(InfrastructureSystems.FlattenIteratorWrapper{#s54} where #s54&lt;:PowerSystems.Device)"><code>PowerSimulations.add_to_cost</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_to_cost(canonical::Canonical,
                 devices::D,
                 var_name::Symbol,
                 cost_symbol::Symbol,
                 sign::Float64 = 1.0) where {D&lt;:IS.FlattenIteratorWrapper{&lt;:PSY.Device}}</code></pre><p>Adds cost expression for each device using appropriate call to <code>ps_cost</code>.</p><p><strong>Expression</strong></p><p>for d in devices</p><pre><code class="language-cost_expression">                              variable[PSY.get_name(d), :],
                              getfield(PSY.get_op_cost(d), cost_symbol),
                              dt,
                              sign) ```</code></pre><p>canonical.cost<em>function += cost</em>expression ```</p><p><strong>LaTeX</strong></p><p><span>$COST = \sum_{d\in D} cost_d$</span></p><p><strong>Arguments</strong></p><ul><li>canonical::Canonical : the canonical model built in PowerSimulations</li><li>devices::D : set of devices</li><li>var_name::Symbol : name of variable</li><li>cost_symbol::Symbol : symbol associated with costx</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.add_variable-Union{Tuple{D}, Tuple{PowerSimulations.Canonical,D,Symbol,Bool}, Tuple{PowerSimulations.Canonical,D,Symbol,Bool,Union{Nothing, Symbol}}, Tuple{PowerSimulations.Canonical,D,Symbol,Bool,Union{Nothing, Symbol},Float64}} where D&lt;:Union{Array{#s255,1} where #s255&lt;:PowerSystems.Device, InfrastructureSystems.FlattenIteratorWrapper{#s256} where #s256&lt;:PowerSystems.Device}" href="#PowerSimulations.add_variable-Union{Tuple{D}, Tuple{PowerSimulations.Canonical,D,Symbol,Bool}, Tuple{PowerSimulations.Canonical,D,Symbol,Bool,Union{Nothing, Symbol}}, Tuple{PowerSimulations.Canonical,D,Symbol,Bool,Union{Nothing, Symbol},Float64}} where D&lt;:Union{Array{#s255,1} where #s255&lt;:PowerSystems.Device, InfrastructureSystems.FlattenIteratorWrapper{#s256} where #s256&lt;:PowerSystems.Device}"><code>PowerSimulations.add_variable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_variable(canonical::Canonical,
                  devices::D,
                  var_name::Symbol,
                  binary::Bool,
                  expression_name::Symbol,
                  sign::Float64)</code></pre><p>Adds a variable to the optimization model and to the affine expressions contained in the canonical model according to the specified sign. Based on the inputs, the variable can be specified as binary.</p><p><strong>Bounds</strong></p><p><code>lb_value_function &lt;= varstart[name, t] &lt;= ub_value_function</code></p><p>If binary = true:</p><p><code>varstart[name, t] in {0,1}</code></p><p><strong>LaTeX</strong></p><p><span>$lb \ge x^{device}_t \le ub \forall t$</span></p><p><span>$x^{device}_t \in {0,1} \forall t iff \text{binary = true}$</span></p><p><strong>Arguments</strong></p><ul><li>canonical::Canonical : the canonical model built in PowerSimulations</li><li>devices : Vector or Iterator with the devices</li><li>var_name::Symbol : Base Name for the variable</li><li>binary::Bool : Select if the variable is binary</li><li>expression<em>name::Symbol : Expression</em>name name stored in canonical.expressions to add the variable</li><li>sign::Float64 : sign of the addition of the variable to the expression_name. Default Value is 1.0</li></ul><p><strong>Accepted Keyword Arguments</strong></p><ul><li>ub<em>value</em>function : Provides the function over device to obtain the value for a upper_bound</li><li>lb<em>value</em>function : Provides the function over device to obtain the value for a lower_bound. If the variable is meant to be positive define lb = x -&gt; 0.0</li><li>initial<em>value</em>function : Provides the function over device to obtain the warm start value</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.build_nip_expr_model-Tuple{Dict{String,Any},Any}" href="#PowerSimulations.build_nip_expr_model-Tuple{Dict{String,Any},Any}"><code>PowerSimulations.build_nip_expr_model</code></a> — <span class="docstring-category">Method</span></header><section><div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.build_nip_model-Tuple{Dict{String,Any},Any}" href="#PowerSimulations.build_nip_model-Tuple{Dict{String,Any},Any}"><code>PowerSimulations.build_nip_model</code></a> — <span class="docstring-category">Method</span></header><section><div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.columnsum-Tuple{DataFrames.DataFrame}" href="#PowerSimulations.columnsum-Tuple{DataFrames.DataFrame}"><code>PowerSimulations.columnsum</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This sums each column in a result dataframe </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.commitment_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{H}, Tuple{PowerSimulations.Canonical,InfrastructureSystems.FlattenIteratorWrapper{H},Type{D},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where D&lt;:PowerSimulations.AbstractHydroUnitCommitment where H&lt;:PowerSystems.HydroGen" href="#PowerSimulations.commitment_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{H}, Tuple{PowerSimulations.Canonical,InfrastructureSystems.FlattenIteratorWrapper{H},Type{D},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where D&lt;:PowerSimulations.AbstractHydroUnitCommitment where H&lt;:PowerSystems.HydroGen"><code>PowerSimulations.commitment_constraints!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function adds the Commitment Status constraint when there are CommitmentVariables</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.commitment_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.Canonical,InfrastructureSystems.FlattenIteratorWrapper{T},Type{D},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where D&lt;:PowerSimulations.AbstractThermalFormulation where T&lt;:PowerSystems.ThermalGen" href="#PowerSimulations.commitment_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.Canonical,InfrastructureSystems.FlattenIteratorWrapper{T},Type{D},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where D&lt;:PowerSimulations.AbstractThermalFormulation where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.commitment_constraints!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function adds the Commitment Status constraint when there are CommitmentVariables</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.commitment_variables!-Union{Tuple{H}, Tuple{PowerSimulations.Canonical,InfrastructureSystems.FlattenIteratorWrapper{H}}} where H&lt;:PowerSystems.HydroGen" href="#PowerSimulations.commitment_variables!-Union{Tuple{H}, Tuple{PowerSimulations.Canonical,InfrastructureSystems.FlattenIteratorWrapper{H}}} where H&lt;:PowerSystems.HydroGen"><code>PowerSimulations.commitment_variables!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function add the variables for power generation commitment to the model</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.commitment_variables!-Union{Tuple{T}, Tuple{PowerSimulations.Canonical,InfrastructureSystems.FlattenIteratorWrapper{T}}} where T&lt;:PowerSystems.ThermalGen" href="#PowerSimulations.commitment_variables!-Union{Tuple{T}, Tuple{PowerSimulations.Canonical,InfrastructureSystems.FlattenIteratorWrapper{T}}} where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.commitment_variables!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function add the variables for power generation commitment to the model</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.constraint_power_balance_ni-Tuple{PowerModels.AbstractActivePowerModel,Int64,Int64,Int64,Any,Any}" href="#PowerSimulations.constraint_power_balance_ni-Tuple{PowerModels.AbstractActivePowerModel,Int64,Int64,Int64,Any,Any}"><code>PowerSimulations.constraint_power_balance_ni</code></a> — <span class="docstring-category">Method</span></header><section><div><p>active power only models ignore reactive power flows</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.constraint_power_balance_ni-Tuple{PowerModels.AbstractPowerModel,Int64,Int64,Int64,Any,Any}" href="#PowerSimulations.constraint_power_balance_ni-Tuple{PowerModels.AbstractPowerModel,Int64,Int64,Int64,Any,Any}"><code>PowerSimulations.constraint_power_balance_ni</code></a> — <span class="docstring-category">Method</span></header><section><div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.constraint_power_balance_ni-Tuple{PowerModels.AbstractPowerModel,Int64}" href="#PowerSimulations.constraint_power_balance_ni-Tuple{PowerModels.AbstractPowerModel,Int64}"><code>PowerSimulations.constraint_power_balance_ni</code></a> — <span class="docstring-category">Method</span></header><section><div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.constraint_power_balance_ni_expr-Tuple{PowerModels.AbstractActivePowerModel,Int64,Int64,Int64,Any,Any,Any,Any}" href="#PowerSimulations.constraint_power_balance_ni_expr-Tuple{PowerModels.AbstractActivePowerModel,Int64,Int64,Int64,Any,Any,Any,Any}"><code>PowerSimulations.constraint_power_balance_ni_expr</code></a> — <span class="docstring-category">Method</span></header><section><div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.constraint_power_balance_ni_expr-Tuple{PowerModels.AbstractPowerModel,Int64,Int64,Int64,Any,Any,Any,Any}" href="#PowerSimulations.constraint_power_balance_ni_expr-Tuple{PowerModels.AbstractPowerModel,Int64,Int64,Int64,Any,Any,Any,Any}"><code>PowerSimulations.constraint_power_balance_ni_expr</code></a> — <span class="docstring-category">Method</span></header><section><div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.constraint_power_balance_ni_expr-Tuple{PowerModels.AbstractPowerModel,Int64}" href="#PowerSimulations.constraint_power_balance_ni_expr-Tuple{PowerModels.AbstractPowerModel,Int64}"><code>PowerSimulations.constraint_power_balance_ni_expr</code></a> — <span class="docstring-category">Method</span></header><section><div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_commitment-Tuple{PowerSimulations.Canonical,Array{InitialCondition,1},Symbol,Tuple{Symbol,Symbol,Symbol}}" href="#PowerSimulations.device_commitment-Tuple{PowerSimulations.Canonical,Array{InitialCondition,1},Symbol,Tuple{Symbol,Symbol,Symbol}}"><code>PowerSimulations.device_commitment</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">device_commitment(canonical::Canonical,
                    initial_conditions::Vector{InitialCondition},
                    cons_name::Symbol,
                    var_names::Tuple{Symbol, Symbol, Symbol})</code></pre><p>Constructs multi-timestep constraint from initial conditions and binary variable tuple.</p><p><strong>Constraints</strong></p><p><code>varstart + varstop &lt;= 1.0</code></p><p>If t = 1:</p><p><code>varon[name, 1] == ic.value + varstart[name, 1] - varstop[name, 1]</code></p><p>where ic in initial_condtions.</p><p>If t &gt; 1:</p><p><code>varon[name, t] == varon[name, t-1] + varstart[name, t] - varstop[name, t]</code></p><p><strong>LaTeX</strong></p><p><span>$x^{on}_t + x^{off}_t \leq 1.0 \forall t$</span></p><p><span>$x^{on}_1 = x^{on}_{init} + x^{start}_1 - x^{stop}_1, \text{ for } t = 1$</span></p><p><span>$x^{on}_t = x^{on}_{t-1} + x^{start}_t - x^{stop}_t, \forall t \geq 2$</span></p><p><strong>Arguments</strong></p><ul><li>canonical::Canonical : the canonical model built in PowerSimulations</li><li>initial_conditions::Vector{InitialCondition} : for time zero &#39;varon&#39;</li><li>cons_name::Symbol : name of the constraint</li><li>var_names::Tuple{Symbol, Symbol, Symbol} : the names of the variables</li><li>: var_names[1] : varstart</li><li>: var_names[2] : varstop</li><li>: var_names[3] : varon</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_duration_look_ahead-Tuple{PowerSimulations.Canonical,Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{InitialCondition,2},Symbol,Tuple{Symbol,Symbol,Symbol}}" href="#PowerSimulations.device_duration_look_ahead-Tuple{PowerSimulations.Canonical,Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{InitialCondition,2},Symbol,Tuple{Symbol,Symbol,Symbol}}"><code>PowerSimulations.device_duration_look_ahead</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">device_duration_look_ahead(canonical::Canonical,
                            duration_data::Vector{UpDown},
                            initial_duration::Matrix{InitialCondition},
                            cons_name::Symbol,
                            var_names::Tuple{Symbol, Symbol, Symbol})</code></pre><p>This formulation of the duration constraints looks ahead in the time frame of the model.</p><p><strong>LaTeX</strong></p><ul><li>Minimum up-time constraint:</li></ul><p>If <span>$t \leq d_{min}^{up}$</span></p><p><span>$d_{min}^{down}x_t^{stop} - \sum_{i=t-d_{min}^{up} + 1}^t x_i^{on} - x_{init}^{up} \leq 0$</span></p><p>for i in the set of time steps. Otherwise:</p><p><span>$d_{min}^{down}x_t^{stop} - \sum_{i=t-d_{min}^{up} + 1}^t x_i^{on} \leq 0$</span></p><p>for i in the set of time steps.</p><ul><li>Minimum down-time constraint:</li></ul><p>If <span>$t \leq d_{min}^{down}$</span></p><p><span>$d_{min}^{up}x_t^{start} - \sum_{i=t-d_{min^{down} + 1}^t (1 - x_i^{on}) - x_{init}^{down} \leq 0$</span></p><p>for i in the set of time steps. Otherwise:</p><p><span>$d_{min}^{up}x_t^{start} - \sum_{i=t-d_{min^{down} + 1}^t (1 - x_i^{on}) \leq 0$</span></p><p>for i in the set of time steps.</p><p><strong>Arguments</strong></p><ul><li>canonical::Canonical : the canonical model built in PowerSimulations</li><li>duration_data::Vector{UpDown} : gives how many time steps variable needs to be up or down</li><li>initial_duration::Matrix{InitialCondition} : gives initial conditions for up (column 1) and down (column 2)</li><li>cons_name::Symbol : name of the constraint</li><li>var_names::Tuple{Symbol, Symbol, Symbol}) : names of the variables</li><li>: var_names[1] : varon</li><li>: var_names[2] : varstart</li><li>: var_names[3] : varstop</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_duration_parameters-Tuple{PowerSimulations.Canonical,Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{InitialCondition,2},Symbol,Tuple{Symbol,Symbol,Symbol}}" href="#PowerSimulations.device_duration_parameters-Tuple{PowerSimulations.Canonical,Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{InitialCondition,2},Symbol,Tuple{Symbol,Symbol,Symbol}}"><code>PowerSimulations.device_duration_parameters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">device_duration_parameters(canonical::Canonical,
                         duration_data::Vector{UpDown},
                         initial_duration_on::Vector{InitialCondition},
                         initial_duration_off::Vector{InitialCondition},
                         cons_name::Symbol,
                         var_names::Tuple{Symbol, Symbol, Symbol})</code></pre><p>This formulation of the duration constraints considers parameters.</p><p><strong>LaTeX</strong></p><ul><li>Minimum up-time constraint:</li></ul><p>If <span>$t \leq d_{min}^{up}$</span></p><p><span>$d_{min}^{down}x_t^{stop} - \sum_{i=t-d_{min}^{up} + 1}^t x_i^{on} - x_{init}^{up} \leq 0$</span></p><p>for i in the set of time steps. Otherwise:</p><p><span>$\sum_{i=t-d_{min}^{up} + 1}^t x_i^{start} - x_t^{on} \leq 0$</span></p><p>for i in the set of time steps.</p><ul><li>Minimum down-time constraint:</li></ul><p>If <span>$t \leq d_{min}^{down}$</span></p><p><span>$d_{min}^{up}x_t^{start} - \sum_{i=t-d_{min^{down} + 1}^t (1 - x_i^{on}) - x_{init}^{down} \leq 0$</span></p><p>for i in the set of time steps. Otherwise:</p><p><span>$\sum_{i=t-d_{min}^{down} + 1}^t x_i^{stop} + x_t^{on} \leq 1$</span></p><p>for i in the set of time steps.</p><p><strong>Arguments</strong></p><ul><li>canonical::Canonical : the canonical model built in PowerSimulations</li><li>duration_data::Vector{UpDown} : gives how many time steps variable needs to be up or down</li><li>initial<em>duration</em>on::Vector{InitialCondition} : gives initial number of time steps variable is up</li><li>initial<em>duration</em>off::Vector{InitialCondition} : gives initial number of time steps variable is down</li><li>cons_name::Symbol : name of the constraint</li><li>var_names::Tuple{Symbol, Symbol, Symbol}) : names of the variables</li><li>: var_names[1] : varon</li><li>: var_names[2] : varstart</li><li>: var_names[3] : varstop</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_duration_retrospective-Tuple{PowerSimulations.Canonical,Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{InitialCondition,2},Symbol,Tuple{Symbol,Symbol,Symbol}}" href="#PowerSimulations.device_duration_retrospective-Tuple{PowerSimulations.Canonical,Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{InitialCondition,2},Symbol,Tuple{Symbol,Symbol,Symbol}}"><code>PowerSimulations.device_duration_retrospective</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">device_duration_retrospective(canonical::Canonical,
                                    duration_data::Vector{UpDown},
                                    initial_duration::Matrix{InitialCondition},
                                    cons_name::Symbol,
                                    var_names::Tuple{Symbol, Symbol, Symbol})</code></pre><p>This formulation of the duration constraints adds over the start times looking backwards.</p><p><strong>LaTeX</strong></p><ul><li>Minimum up-time constraint:</li></ul><p>If <span>$t \leq d_{min}^{up} - d_{init}^{up}$</span> and <span>$d_{init}^{up} &gt; 0$</span></p><p><span>$1 + \sum_{i=t-d_{min}^{up} + 1}^t x_i^{start} - x_t^{on} \leq 0$</span></p><p>for i in the set of time steps. Otherwise:</p><p><span>$\sum_{i=t-d_{min}^{up} + 1}^t x_i^{start} - x_t^{on} \leq 0$</span></p><p>for i in the set of time steps.</p><ul><li>Minimum down-time constraint:</li></ul><p>If <span>$t \leq d_{min}^{down} - d_{init}^{down}$</span> and <span>$d_{init}^{down} &gt; 0$</span></p><p><span>$1 + \sum_{i=t-d_{min}^{down} + 1}^t x_i^{stop} + x_t^{on} \leq 1$</span></p><p>for i in the set of time steps. Otherwise:</p><p><span>$\sum_{i=t-d_{min}^{down} + 1}^t x_i^{stop} + x_t^{on} \leq 1$</span></p><p>for i in the set of time steps.</p><p><strong>Arguments</strong></p><ul><li>canonical::Canonical : the canonical model built in PowerSimulations</li><li>duration_data::Vector{UpDown} : gives how many time steps variable needs to be up or down</li><li>initial_duration::Matrix{InitialCondition} : gives initial conditions for up (column 1) and down (column 2)</li><li>cons_name::Symbol : name of the constraint</li><li>var_names::Tuple{Symbol, Symbol, Symbol}) : names of the variables</li><li>: var_names[1] : varon</li><li>: var_names[2] : varstart</li><li>: var_names[3] : varstop</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_linear_rateofchange-Tuple{PowerSimulations.Canonical,Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{InitialCondition,1},Symbol,Symbol}" href="#PowerSimulations.device_linear_rateofchange-Tuple{PowerSimulations.Canonical,Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{InitialCondition,1},Symbol,Symbol}"><code>PowerSimulations.device_linear_rateofchange</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">device_linear_rateofchange(canonical::Canonical,
                                rate_data::Tuple{Vector{String}, Vector{UpDown}},
                                initial_conditions::Vector{InitialCondition},
                                cons_name::Symbol,
                                var_name::Symbol)</code></pre><p>Constructs allowed rate-of-change constraints from variables, initial condtions, and rate data.</p><p><strong>Constraints</strong></p><p>If t = 1:</p><p><code>variable[name, 1] - initial_conditions[ix].value &lt;= rate_data[1][ix].up</code></p><p><code>initial_conditions[ix].value - variable[name, 1] &lt;= rate_data[1][ix].down</code></p><p>If t &gt; 1:</p><p><code>variable[name, t] - variable[name, t-1] &lt;= rate_data[1][ix].up</code></p><p><code>variable[name, t-1] - variable[name, t] &lt;= rate_data[1][ix].down</code></p><p><strong>LaTeX</strong></p><p><span>$r^{down} \leq x_1 - x_{init} \leq r^{up}, \text{ for } t = 1$</span></p><p><span>$r^{down} \leq x_t - x_{t-1} \leq r^{up}, \forall t \geq 2$</span></p><p><strong>Arguments</strong></p><ul><li>canonical::Canonical : the canonical model built in PowerSimulations</li><li>rate_data::Tuple{Vector{String}, Vector{UpDown}} : gives name (1) and max ramp up/down rates (2)</li><li>initial_conditions::Vector{InitialCondition} : for time zero &#39;variable&#39;</li><li>cons_name::Symbol : name of the constraint</li><li>var_name::Tuple{Symbol, Symbol, Symbol} : the name of the variable</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_mixedinteger_rateofchange-Tuple{PowerSimulations.Canonical,Tuple{Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{NamedTuple{(:min, :max),Tuple{Float64,Float64}},1}},Array{InitialCondition,1},Symbol,Tuple{Symbol,Symbol,Symbol}}" href="#PowerSimulations.device_mixedinteger_rateofchange-Tuple{PowerSimulations.Canonical,Tuple{Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{NamedTuple{(:min, :max),Tuple{Float64,Float64}},1}},Array{InitialCondition,1},Symbol,Tuple{Symbol,Symbol,Symbol}}"><code>PowerSimulations.device_mixedinteger_rateofchange</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">device_mixedinteger_rateofchange(canonical::Canonical,
                                      rate_data::Tuple{Vector{String}, Vector{UpDown}, Vector{MinMax}},
                                      initial_conditions::Vector{InitialCondition},
                                      cons_name::Symbol,
                                      var_names::Tuple{Symbol, Symbol, Symbol})</code></pre><p>Constructs allowed rate-of-change constraints from variables, initial condtions, start/stop status, and rate data</p><p><strong>Equations</strong></p><p>If t = 1:</p><p><code>variable[name, 1] - initial_conditions[ix].value &lt;= rate_data[1][ix].up + rate_data[2][ix].max*varstart[name, 1]</code></p><p><code>initial_conditions[ix].value - variable[name, 1] &lt;= rate_data[1][ix].down + rate_data[2][ix].min*varstop[name, 1]</code></p><p>If t &gt; 1:</p><p><code>variable[name, t] - variable[name, t-1] &lt;= rate_data[1][ix].up + rate_data[2][ix].max*varstart[name, t]</code></p><p><code>variable[name, t-1] - variable[name, t] &lt;= rate_data[1][ix].down + rate_data[2][ix].min*varstop[name, t]</code></p><p><strong>LaTeX</strong></p><p><span>$r^{down} + r^{min} x^{stop}_1 \leq x_1 - x_{init} \leq r^{up} + r^{max} x^{start}_1, \text{ for } t = 1$</span></p><p><span>$r^{down} + r^{min} x^{stop}_t \leq x_t - x_{t-1} \leq r^{up} + r^{max} x^{start}_t, \forall t \geq 2$</span></p><p><strong>Arguments</strong></p><ul><li>canonical::Canonical : the canonical model built in PowerSimulations</li><li>rate_data::Tuple{Vector{String}, Vector{UpDown}, Vector{MinMax}} : (1) gives name                                                                    (2) gives min/max ramp rates                                                                    (3) gives min/max for &#39;variable&#39;</li><li>initial_conditions::Vector{InitialCondition} : for time zero &#39;variable&#39;</li><li>cons_name::Symbol : name of the constraint</li><li>var_names::Tuple{Symbol, Symbol, Symbol} : the names of the variables</li><li>: var_names[1] : &#39;variable&#39;</li><li>: var_names[2] : &#39;varstart&#39;</li><li>: var_names[3] : &#39;varstop&#39;</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_range-Tuple{PowerSimulations.Canonical,Array{Tuple{String,NamedTuple{(:min, :max),Tuple{Float64,Float64}}},1},Symbol,Symbol}" href="#PowerSimulations.device_range-Tuple{PowerSimulations.Canonical,Array{Tuple{String,NamedTuple{(:min, :max),Tuple{Float64,Float64}}},1},Symbol,Symbol}"><code>PowerSimulations.device_range</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">device_range(canonical::Canonical,
                    range_data::Vector{NamedMinMax},
                    cons_name::Symbol,
                    var_name::Symbol)</code></pre><p>Constructs min/max range constraint from device variable.</p><p><strong>Constraints</strong></p><p>If min and max within an epsilon width:</p><p><code>variable[r[1], t] == r[2].max</code></p><p>Otherwise:</p><p><code>r[2].min &lt;= variable[r[1], t] &lt;= r[2].max</code></p><p>where r in range_data.</p><p><strong>LaTeX</strong></p><p><span>$x = r^{max}, \text{ for } |r^{max} - r^{min}| &lt; \varepsilon$</span></p><p><span>$r^{min} \leq x \leq r^{max}, \text{ otherwise }$</span></p><p><strong>Arguments</strong></p><ul><li>canonical::Canonical : the canonical model built in PowerSimulations</li><li>range_data::Vector{NamedMinMax} : contains name of device (1) and its min/max (2)</li><li>cons_name::Symbol : name of the constraint</li><li>var_name::Symbol : the name of the continuous variable</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_semicontinuousrange-Tuple{PowerSimulations.Canonical,Array{Tuple{String,NamedTuple{(:min, :max),Tuple{Float64,Float64}}},1},Symbol,Symbol,Symbol}" href="#PowerSimulations.device_semicontinuousrange-Tuple{PowerSimulations.Canonical,Array{Tuple{String,NamedTuple{(:min, :max),Tuple{Float64,Float64}}},1},Symbol,Symbol,Symbol}"><code>PowerSimulations.device_semicontinuousrange</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">device_semicontinuousrange(canonical::Canonical,
                                scrange_data::Vector{NamedMinMax},
                                cons_name::Symbol,
                                var_name::Symbol,
                                binvar_name::Symbol)</code></pre><p>Constructs min/max range constraint from device variable and on/off decision variable.</p><p><strong>Constraints</strong></p><p>If device min = 0:</p><p><code>varcts[r[1], t] &lt;= r[2].max*varbin[r[1], t])</code></p><p><code>varcts[r[1], t] &gt;= 0.0</code></p><p>Otherwise:</p><p><code>varcts[r[1], t] &lt;= r[2].max*varbin[r[1], t]</code></p><p><code>varcts[r[1], t] &gt;= r[2].min*varbin[r[1], t]</code></p><p>where r in range_data.</p><p><strong>LaTeX</strong></p><p><span>$0 \leq x^{cts} \leq r^{max} x^{bin}, \text{ for } r^{min} = 0$</span></p><p><span>$r^{min} x^{bin} \leq x^{cts} \leq r^{max} x^{bin}, \text{ otherwise }$</span></p><p><strong>Arguments</strong></p><ul><li>canonical::Canonical : the canonical model built in PowerSimulations</li><li>scrange_data::Vector{NamedMinMax} : contains name of device (1) and its min/max (2)</li><li>cons_name::Symbol : name of the constraint</li><li>var_name::Symbol : the name of the continuous variable</li><li>binvar_name::Symbol : the name of the binary variable</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_timeseries_lb-Tuple{PowerSimulations.Canonical,Array{Tuple{String,Int64,Float64,Array{Float64,1}},1},Symbol,Symbol}" href="#PowerSimulations.device_timeseries_lb-Tuple{PowerSimulations.Canonical,Array{Tuple{String,Int64,Float64,Array{Float64,1}},1},Symbol,Symbol}"><code>PowerSimulations.device_timeseries_lb</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">device_timeseries_lb(canonical::Canonical,
                 ts_data::Vector{Tuple{String, Int64, Float64, Vector{Float64}}}
                 cons_name::Symbol,
                 var_name::Symbol)</code></pre><p>Constructs lower bound for given variable subject to time series data and a multiplier.</p><p><strong>Constraint</strong></p><p><code>ts_data[2][ix]*ts_data[3][ix][t] &lt;= variable[name, t]</code></p><p><strong>LaTeX</strong></p><p><span>$r^{val} r_t \leq x_t, \forall t$</span></p><p>where (ix, name) in enumerate(ts_data[1]).</p><p><strong>Arguments</strong></p><ul><li>canonical::Canonical : the canonical model built in PowerSimulations</li><li>ts_data::Vector{Tuple{String, Int64, Float64, Vector{Float64}}}: timeseries data name (1), multiplier (2) and values (3)</li><li>cons_name::Symbol : name of the constraint</li><li>var_name::Symbol : the name of the variable</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_timeseries_param_lb-Tuple{PowerSimulations.Canonical,Array{Tuple{String,Int64,Float64,Array{Float64,1}},1},Symbol,PowerSimulations.UpdateRef,Symbol}" href="#PowerSimulations.device_timeseries_param_lb-Tuple{PowerSimulations.Canonical,Array{Tuple{String,Int64,Float64,Array{Float64,1}},1},Symbol,PowerSimulations.UpdateRef,Symbol}"><code>PowerSimulations.device_timeseries_param_lb</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">device_timeseries_param_lb(canonical::Canonical,
                                ts_data::Vector{Tuple{String, Int64, Float64, Vector{Float64}}}
                                cons_name::Symbol,
                                param_reference::UpdateRef,
                                var_name::Symbol)</code></pre><p>Constructs lower bound for given variable using a parameter. The constraint is     built with a time series data vector and a multiplier</p><p><strong>Constraint</strong></p><p><code>ts_data[2][ix] * param[name, t] &lt;= variable[name, t]</code></p><p><strong>LaTeX</strong></p><p><span>$r^{val} x^{param}_t \leq x^{var}_t, \forall t$</span></p><p><strong>Arguments</strong></p><ul><li>canonical::Canonical : the canonical model built in PowerSimulations</li><li>ts_data::Tuple{Vector{String}, Vector{Vector{Float64}}} : timeseries data name (1) and values (2)</li><li>cons_name::Symbol : name of the constraint</li><li>param_reference::UpdateRef : UpdateRef to access the parameter</li><li>var_name::Symbol : the name of the variable</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_timeseries_param_ub-Tuple{PowerSimulations.Canonical,Array{Tuple{String,Int64,Float64,Array{Float64,1}},1},Symbol,PowerSimulations.UpdateRef,Symbol}" href="#PowerSimulations.device_timeseries_param_ub-Tuple{PowerSimulations.Canonical,Array{Tuple{String,Int64,Float64,Array{Float64,1}},1},Symbol,PowerSimulations.UpdateRef,Symbol}"><code>PowerSimulations.device_timeseries_param_ub</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">device_timeseries_param_ub(canonical::Canonical,
                                ts_data::Vector{Tuple{String, Int64, Float64, Vector{Float64}}}
                                cons_name::Symbol,
                                param_reference::UpdateRef,
                                var_name::Symbol)</code></pre><p>Constructs upper bound for given variable using a parameter. The constraint is     built with a time series data vector and a multiplier</p><p><strong>Constraint</strong></p><p><code>variable[name, t] &lt;= ts_data[2][ix]*param[name, t]</code></p><p><strong>LaTeX</strong></p><p><span>$x^{var}_t \leq r^{val} x^{param}_t, \forall t$</span></p><p><strong>Arguments</strong></p><ul><li>canonical::Canonical : the canonical model built in PowerSimulations</li><li>ts_data::Vector{Tuple{String, Int64, Float64, Vector{Float64}}}: timeseries data name (1), multiplier (2) and values (3)</li><li>cons_name::Symbol : name of the constraint</li><li>param_reference::UpdateRef : UpdateRef to access the parameter</li><li>var_name::Symbol : the name of the variable</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_timeseries_ub-Tuple{PowerSimulations.Canonical,Array{Tuple{String,Int64,Float64,Array{Float64,1}},1},Symbol,Symbol}" href="#PowerSimulations.device_timeseries_ub-Tuple{PowerSimulations.Canonical,Array{Tuple{String,Int64,Float64,Array{Float64,1}},1},Symbol,Symbol}"><code>PowerSimulations.device_timeseries_ub</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">device_timeseries_ub(canonical::Canonical,
                 ts_data::Vector{Tuple{String, Int64, Float64, Vector{Float64}}}
                 cons_name::Symbol,
                 var_name::Symbol)</code></pre><p>Constructs upper bound for given variable and time series data and a multiplier.</p><p><strong>Constraint</strong></p><p><code>variable[name, t] &lt;= ts_data[2][ix]*ts_data[3][ix][t]</code></p><p><strong>LaTeX</strong></p><p><span>$x_t \leq r^{val} r_t, \forall t$</span></p><p><strong>Arguments</strong></p><ul><li>canonical::Canonical : the canonical model built in PowerSimulations</li><li>ts_data::Vector{Tuple{String, Int64, Float64, Vector{Float64}}}: timeseries data name (1), multiplier (2) and values (3)</li><li>cons_name::Symbol : name of the constraint</li><li>var_name::Symbol : the name of the variable</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_timeseries_ub_bigM" href="#PowerSimulations.device_timeseries_ub_bigM"><code>PowerSimulations.device_timeseries_ub_bigM</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">device_timeseries_ub_bigM(canonical::Canonical,
                                ts_data::Vector{Tuple{String, Int64, Float64, Vector{Float64}}}
                                cons_name::Symbol,
                                var_name::Symbol,
                                param_reference::UpdateRef,
                                binvar_name::Symbol,
                                M_value::Float64 = 1e6)</code></pre><p>Constructs upper bound for variable and time series and a multiplier or confines to 0 depending on binary variable.     Uses BigM constraint type to allow for parameter since ParameterJuMP doesn&#39;t support var*parameter</p><p><strong>Constraints</strong></p><p><code>varcts[name, t] - ts_data[2][ix] * param[name, t] &lt;= (1 - varbin[name, t])*M_value</code></p><p><code>varcts[name, t] &lt;= varbin[name, t]*M_value</code></p><p><strong>LaTeX</strong></p><p><span>$x^{cts}_t - r^{val} x^{param}_t \leq M(1 - x^{bin}_t ), forall t$</span></p><p><span>$x^{cts}_t \leq M x^{bin}_t, \forall t$</span></p><p><strong>Arguments</strong></p><ul><li>canonical::Canonical : the canonical model built in PowerSimulations</li><li>ts_data::Tuple{Vector{String}, Vector{Vector{Float64}}} : timeseries data name (1) and values (2)</li><li>cons_name::Symbol : name of the constraint</li><li>var_name::Symbol :  name of the variable</li></ul><p>param_reference::UpdateRef : UpdateRef of access the parameters</p><ul><li>binvar_name::Symbol : name of binary variable</li><li>M_value::Float64 : bigM</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.device_timeseries_ub_bin-Tuple{PowerSimulations.Canonical,Array{Tuple{String,Int64,Float64,Array{Float64,1}},1},Symbol,Symbol,Symbol}" href="#PowerSimulations.device_timeseries_ub_bin-Tuple{PowerSimulations.Canonical,Array{Tuple{String,Int64,Float64,Array{Float64,1}},1},Symbol,Symbol,Symbol}"><code>PowerSimulations.device_timeseries_ub_bin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">device_timeseries_ub_bin(canonical::Canonical,
                                ts_data::Vector{Tuple{String, Int64, Float64, Vector{Float64}}}
                                cons_name::Symbol,
                                var_name::Symbol,
                                binvar_name::Symbol)</code></pre><p>Constructs upper bound for variable and time series or confines to 0 depending on binary variable.     The upper bound is defined by a time series and a multiplier.</p><p><strong>Constraints</strong></p><p><code>varcts[name, t] &lt;= varbin[name, t]* ts_data[2][ix] * ts_data[3][ix][t]</code></p><p>where (ix, name) in enumerate(ts_data[1]).</p><p><strong>LaTeX</strong></p><p><span>$x^{cts}_t \leq r^{val} r_t x^{bin}_t, \forall t$</span></p><p><strong>Arguments</strong></p><ul><li>canonical::Canonical : the canonical model built in PowerSimulations</li><li>ts_data::Tuple{Vector{String}, Vector{Vector{Float64}}} : timeseries data name (1) and values (2)</li><li>cons_name::Symbol : name of the constraint</li><li>var_name::Symbol :  name of the variable</li><li>binvar_name::Symbol : name of binary variable</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.energy_balance-Tuple{PowerSimulations.Canonical,Array{InitialCondition,1},Tuple{Array{String,1},Array{NamedTuple{(:in, :out),Tuple{Float64,Float64}},1}},Symbol,Tuple{Symbol,Symbol,Symbol}}" href="#PowerSimulations.energy_balance-Tuple{PowerSimulations.Canonical,Array{InitialCondition,1},Tuple{Array{String,1},Array{NamedTuple{(:in, :out),Tuple{Float64,Float64}},1}},Symbol,Tuple{Symbol,Symbol,Symbol}}"><code>PowerSimulations.energy_balance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">energy_balance(canonical::Canonical,
                    initial_conditions::Vector{InitialCondition},
                    efficiency_data::Tuple{Vector{String}, Vector{InOut}},
                    cons_name::Symbol,
                    var_names::Tuple{Symbol, Symbol, Symbol})</code></pre><p>Constructs multi-timestep constraint from initial condition, efficiency data, and variable tuple</p><p><strong>Constraints</strong></p><p>If t = 1:</p><p><code>varenergy[name, 1] == initial_conditions[ix].value + varin[name, 1]*eff_in*fraction_of_hour - varout[name, 1]*fraction_of_hour/eff_out</code></p><p>If t &gt; 1:</p><p><code>varenergy[name, t] == varenergy[name, t-1] + varin[name, t]*eff_in*fraction_of_hour - varout[name, t]*fraction_of_hour/eff_out</code></p><p><strong>LaTeX</strong></p><p><span>$x^{energy}_1 == x^{energy}_{init} + frhr \eta^{in} x^{in}_1 - \frac{frhr}{\eta^{out}} x^{out}_1, \text{ for } t = 1$</span></p><p><span>$x^{energy}_t == x^{energy}_{t-1} + frhr \eta^{in} x^{in}_t - \frac{frhr}{\eta^{out}} x^{out}_t, \forall t \geq 2$</span></p><p><strong>Arguments</strong></p><ul><li>canonical::Canonical : the canonical model built in PowerSimulations</li><li>initial_conditions::Vector{InitialCondition} : for time zero &#39;varenergy&#39;</li><li>efficiency_data::Tuple{Vector{String}, Vector{InOut}} :: charging/discharging efficiencies</li><li>cons_name::Symbol : name of the constraint</li><li>var_names::Tuple{Symbol, Symbol, Symbol} : the names of the variables</li><li>: var_names[1] : varin</li><li>: var_names[2] : varout</li><li>: var_names[3] : varenergy</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.make_references-Tuple{Simulation,String}" href="#PowerSimulations.make_references-Tuple{Simulation,String}"><code>PowerSimulations.make_references</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">make_references(sim::Simulation, date_run::String)</code></pre><p>Creates a dictionary of variables with a dictionary of stages that contains dataframes of date/step/and desired file path so that the results can be parsed sequentially by variable and stage type.</p><p><strong>Note:</strong> make<em>references can only be run after run</em>sim_model or else, the folder structure will not yet be populated with results</p><p><strong>Arguments</strong></p><p>-<code>sim::Simulation = sim</code>: simulation object created by Simulation() -<code>date_run::String = &quot;2019-10-03T09-18-00&quot;</code>`: the name of the file created that contains the specific simulation run of the date run and &quot;-test&quot;</p><p><strong>Example</strong></p><pre><code class="language-julia">sim = Simulation(&quot;test&quot;, 7, stages, &quot;/Users/yourusername/Desktop/&quot;;
verbose = true, system_to_file = false)
execute!(sim::Simulation; verbose::Bool = false, kwargs...)
references = make_references(sim, &quot;2019-10-03T09-18-00-test&quot;)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.parameter_update!-Tuple{PowerSimulations.UpdateRef{JuMP.VariableRef},JuMP.Containers.DenseAxisArray{ParameterJuMP.ParameterRef,N,Ax,L} where L&lt;:Tuple{Vararg{Dict,N}} where Ax where N,Int64,Simulation}" href="#PowerSimulations.parameter_update!-Tuple{PowerSimulations.UpdateRef{JuMP.VariableRef},JuMP.Containers.DenseAxisArray{ParameterJuMP.ParameterRef,N,Ax,L} where L&lt;:Tuple{Vararg{Dict,N}} where Ax where N,Int64,Simulation}"><code>PowerSimulations.parameter_update!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Updates the forecast parameter value</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.post_nip-Tuple{PowerModels.AbstractPowerModel}" href="#PowerSimulations.post_nip-Tuple{PowerModels.AbstractPowerModel}"><code>PowerSimulations.post_nip</code></a> — <span class="docstring-category">Method</span></header><section><div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.post_nip_expr-Tuple{PowerModels.AbstractPowerModel}" href="#PowerSimulations.post_nip_expr-Tuple{PowerModels.AbstractPowerModel}"><code>PowerSimulations.post_nip_expr</code></a> — <span class="docstring-category">Method</span></header><section><div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.powermodels_network!-Union{Tuple{S}, Tuple{PowerSimulations.Canonical,Type{S},PowerSystems.System}} where S&lt;:PowerModels.AbstractActivePowerModel" href="#PowerSimulations.powermodels_network!-Union{Tuple{S}, Tuple{PowerSimulations.Canonical,Type{S},PowerSystems.System}} where S&lt;:PowerModels.AbstractActivePowerModel"><code>PowerSimulations.powermodels_network!</code></a> — <span class="docstring-category">Method</span></header><section><div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.powermodels_network!-Union{Tuple{S}, Tuple{PowerSimulations.Canonical,Type{S},PowerSystems.System}} where S&lt;:PowerModels.AbstractPowerModel" href="#PowerSimulations.powermodels_network!-Union{Tuple{S}, Tuple{PowerSimulations.Canonical,Type{S},PowerSystems.System}} where S&lt;:PowerModels.AbstractPowerModel"><code>PowerSimulations.powermodels_network!</code></a> — <span class="docstring-category">Method</span></header><section><div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.ps_cost-Union{Tuple{JV}, Tuple{PowerSimulations.Canonical,JuMP.Containers.DenseAxisArray{JV,N,Ax,L} where L&lt;:Tuple{Vararg{Dict,N}} where Ax where N,Float64,Float64,Float64}} where JV&lt;:JuMP.AbstractVariableRef" href="#PowerSimulations.ps_cost-Union{Tuple{JV}, Tuple{PowerSimulations.Canonical,JuMP.Containers.DenseAxisArray{JV,N,Ax,L} where L&lt;:Tuple{Vararg{Dict,N}} where Ax where N,Float64,Float64,Float64}} where JV&lt;:JuMP.AbstractVariableRef"><code>PowerSimulations.ps_cost</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ps_cost(canonical::Canonical,
            variable::JuMP.Containers.DenseAxisArray{JV},
            cost_component::Float64,
            dt::Float64,
            sign::Float64) where {JV &lt;: JuMP.AbstractVariableRef}</code></pre><p>Returns linear cost terms for sum of variables with common factor to be used for cost expression for canonical model.</p><p><strong>Equation</strong></p><p><code>gen_cost = sum(variable)*cost_component</code></p><p><strong>LaTeX</strong></p><p><span>$cost = dt\times sign\sum_{i\in I} c x_i$</span></p><p>Returns:</p><p><code>sign*gen_cost*dt</code></p><p><strong>Arguments</strong></p><ul><li>canonical::Canonical : the canonical model built in PowerSimulations</li><li>variable::JuMP.Containers.DenseAxisArray{JV} : variable array</li><li>cost_component::Float64 : cost to be associated with variable</li><li>dt::Float64 : fraction of hour</li><li>sign::Float64 : positive or negative sign to be associated cost term</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.ps_cost-Union{Tuple{JV}, Tuple{PowerSimulations.Canonical,JuMP.Containers.DenseAxisArray{JV,N,Ax,L} where L&lt;:Tuple{Vararg{Dict,N}} where Ax where N,PowerSystems.VariableCost{Array{Tuple{Float64,Float64},1}},Float64,Float64}} where JV&lt;:JuMP.AbstractVariableRef" href="#PowerSimulations.ps_cost-Union{Tuple{JV}, Tuple{PowerSimulations.Canonical,JuMP.Containers.DenseAxisArray{JV,N,Ax,L} where L&lt;:Tuple{Vararg{Dict,N}} where Ax where N,PowerSystems.VariableCost{Array{Tuple{Float64,Float64},1}},Float64,Float64}} where JV&lt;:JuMP.AbstractVariableRef"><code>PowerSimulations.ps_cost</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ps_cost(canonical::Canonical,
             variable::JuMP.Containers.DenseAxisArray{JV},
             cost_component::PSY.VariableCost{Vector{NTuple{2, Float64}}},
             dt::Float64,
             sign::Float64) where {JV&lt;:JuMP.AbstractVariableRef}</code></pre><p>Creates piecewise linear cost function using a sum of variables and expression with sign and time step included.</p><p><strong>Expression</strong></p><p><code>JuMP.add_to_expression!(gen_cost, c)</code></p><p>Returns sign<em>gen_cost</em>dt</p><p><strong>LaTeX</strong></p><p><span>$cost = sign\times dt \sum_{v\in V} c_v$</span></p><p>where <span>$c_v$</span> is given by</p><p><span>$c_v = \sum_{i\in Ix} \frac{y_i - y_{i-1}}{x_i - x_{i-1}} v^{p.w.}_i$</span></p><p><strong>Arguments</strong></p><ul><li>canonical::Canonical : the canonical model built in PowerSimulations</li><li>variable::JuMP.Containers.DenseAxisArray{JV} : variable array</li><li>cost_component::PSY.VariableCost{Vector{NTuple{2, Float64}}}</li><li>dt::Float64 : fraction of hour</li><li>sign::Float64 : positive or negative sign to be associated cost term</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.ps_cost-Union{Tuple{JV}, Tuple{PowerSimulations.Canonical,JuMP.Containers.DenseAxisArray{JV,N,Ax,L} where L&lt;:Tuple{Vararg{Dict,N}} where Ax where N,PowerSystems.VariableCost{Float64},Float64,Float64}} where JV&lt;:JuMP.AbstractVariableRef" href="#PowerSimulations.ps_cost-Union{Tuple{JV}, Tuple{PowerSimulations.Canonical,JuMP.Containers.DenseAxisArray{JV,N,Ax,L} where L&lt;:Tuple{Vararg{Dict,N}} where Ax where N,PowerSystems.VariableCost{Float64},Float64,Float64}} where JV&lt;:JuMP.AbstractVariableRef"><code>PowerSimulations.ps_cost</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ps_cost(canonical::Canonical,
            variable::JuMP.Containers.DenseAxisArray{JV},
            cost_component::PSY.VariableCost{Float64},
            dt::Float64,
            sign::Float64) where {JV &lt;: JuMP.AbstractVariableRef}</code></pre><p>Returns linear cost terms for sum of variables with common factor to be used for cost expression for canonical model. Does this by calling <code>ps_cost</code> that has Float64 cost component input.</p><p>Returns:</p><p><code>ps_cost(canonical, variable, PSY.get_cost(cost_component), dt, sign)</code></p><p><strong>Arguments</strong></p><ul><li>canonical::Canonical : the canonical model built in PowerSimulations</li><li>variable::JuMP.Containers.DenseAxisArray{JV} : variable array</li><li>cost_component::PSY.VariableCost{Float64} : container for cost to be associated with variable</li><li>dt::Float64 : fraction of hour</li><li>sign::Float64 : positive or negative sign to be associated cost term</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.ps_cost-Union{Tuple{JV}, Tuple{PowerSimulations.Canonical,JuMP.Containers.DenseAxisArray{JV,N,Ax,L} where L&lt;:Tuple{Vararg{Dict,N}} where Ax where N,PowerSystems.VariableCost{Tuple{Float64,Float64}},Float64,Float64}} where JV&lt;:JuMP.AbstractVariableRef" href="#PowerSimulations.ps_cost-Union{Tuple{JV}, Tuple{PowerSimulations.Canonical,JuMP.Containers.DenseAxisArray{JV,N,Ax,L} where L&lt;:Tuple{Vararg{Dict,N}} where Ax where N,PowerSystems.VariableCost{Tuple{Float64,Float64}},Float64,Float64}} where JV&lt;:JuMP.AbstractVariableRef"><code>PowerSimulations.ps_cost</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ps_cost(canonical::Canonical,
            variable::JuMP.Containers.DenseAxisArray{JV},
            cost_component::PSY.VariableCost{NTuple{2, Float64}}
            dt::Float64,
            sign::Float64) where {JV &lt;: JuMP.AbstractVariableRef}</code></pre><p>Returns quadratic cost terms for sum of variables with common factor to be used for cost expression for canonical model.</p><p><strong>Equation</strong></p><p><code>gen_cost = dt*sign*(sum(variable.^2)*cost_component[1] + sum(variable)*cost_component[2])</code></p><p><strong>LaTeX</strong></p><p><span>$cost = dt\times sign (sum_{i\in I} c_1 v_i^2 + sum_{i\in I} c_2 v_i )$</span></p><p>for quadratic factor large enough. Otherwise</p><p><code>return ps_cost(canonical, variable, cost_component[2], dt, 1.0)</code></p><p>Returns <code>gen_cost</code></p><p><strong>Arguments</strong></p><ul><li>canonical::Canonical : the canonical model built in PowerSimulations</li><li>variable::JuMP.Containers.DenseAxisArray{JV} : variable array</li><li>cost_component::PSY.VariableCost{NTuple{2, Float64}} : container for quadratic and linear factors</li><li>sign::Float64 : positive or negative sign to be associated cost term</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.ramp_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.Canonical,InfrastructureSystems.FlattenIteratorWrapper{T},Type{D},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where D&lt;:PowerSimulations.AbstractThermalFormulation where T&lt;:PowerSystems.ThermalGen" href="#PowerSimulations.ramp_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.Canonical,InfrastructureSystems.FlattenIteratorWrapper{T},Type{D},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where D&lt;:PowerSimulations.AbstractThermalFormulation where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.ramp_constraints!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function adds the ramping limits of generators when there are CommitmentVariables</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.range_ff-Tuple{PowerSimulations.Canonical,Symbol,Tuple{PowerSimulations.UpdateRef,PowerSimulations.UpdateRef},Symbol}" href="#PowerSimulations.range_ff-Tuple{PowerSimulations.Canonical,Symbol,Tuple{PowerSimulations.UpdateRef,PowerSimulations.UpdateRef},Symbol}"><code>PowerSimulations.range_ff</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">    range_ff(canonical::Canonical,
                    cons_name::Symbol,
                    param_reference::NTuple{2, UpdateRef},
                    var_name::Symbol)</code></pre><p>Constructs min/max range parametrized constraint from device variable to include feedforward.</p><p><strong>Constraints</strong></p><p><code>param_reference[1][var_name] &lt;= variable[var_name, t]</code> <code>variable[var_name, t] &lt;= param_reference[2][var_name]</code></p><p>where r in range_data.</p><p><strong>LaTeX</strong></p><p><span>$param^{min} \leq x$</span> <span>$x \leq param^{max}$</span></p><p><strong>Arguments</strong></p><ul><li>canonical::Canonical : the canonical model built in PowerSimulations</li><li>param_reference::NTuple{2, UpdateRef} : Tuple with the lower bound and upper bound parameter reference</li><li>cons_name::Symbol : name of the constraint</li><li>var_name::Symbol : the name of the continuous variable</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.rating_constraint!-Tuple{PowerSimulations.Canonical,Array{Tuple{String,Float64},1},Symbol,Tuple{Symbol,Symbol}}" href="#PowerSimulations.rating_constraint!-Tuple{PowerSimulations.Canonical,Array{Tuple{String,Float64},1},Symbol,Tuple{Symbol,Symbol}}"><code>PowerSimulations.rating_constraint!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rating_constraint!(canonical::Canonical,
                        rating_data::Vector{Tuple{String, Float64}},
                        cons_name::Symbol,
                        var_names::Tuple{Symbol, Symbol})</code></pre><p>Constructs constraint from rating data and related variable tuple.</p><p><strong>Constraint</strong></p><p><code>var1[r[1], t]^2 + var2[r[1], t]^2 &lt;= r[2]^2</code></p><p>where r in rating data and t in time steps.</p><p><strong>LaTeX</strong></p><p><span>$x_1^2 + x_2^2 \leq r^2$</span></p><p><strong>Arguments</strong></p><ul><li>canonical::Canonical : the canonical model built in PowerSimulations</li><li>rating_data::Vector{Tuple{String, Float64}} : rating data name (1) and value (2)</li><li>cons_name::Symbol : name of the constraint</li><li>var_names::Tuple{Symbol, Symbol} : the names of the variables</li><li>: var_names[1] : var1</li><li>: var_names[2] : var2</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.reactive_power_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{St}, Tuple{PowerSimulations.Canonical,InfrastructureSystems.FlattenIteratorWrapper{St},Type{D},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where D&lt;:PowerSimulations.AbstractStorageFormulation where St&lt;:PowerSystems.Storage" href="#PowerSimulations.reactive_power_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{St}, Tuple{PowerSimulations.Canonical,InfrastructureSystems.FlattenIteratorWrapper{St},Type{D},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where D&lt;:PowerSimulations.AbstractStorageFormulation where St&lt;:PowerSystems.Storage"><code>PowerSimulations.reactive_power_constraints!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function adds the reactive  power limits of generators when there are CommitmentVariables</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.reactivepower_constraints!-Union{Tuple{L}, Tuple{PowerSimulations.Canonical,InfrastructureSystems.FlattenIteratorWrapper{L},Type{#s252} where #s252&lt;:PowerSimulations.AbstractControllablePowerLoadFormulation,Type{#s251} where #s251&lt;:PowerModels.AbstractPowerModel}} where L&lt;:PowerSystems.ElectricLoad" href="#PowerSimulations.reactivepower_constraints!-Union{Tuple{L}, Tuple{PowerSimulations.Canonical,InfrastructureSystems.FlattenIteratorWrapper{L},Type{#s252} where #s252&lt;:PowerSimulations.AbstractControllablePowerLoadFormulation,Type{#s251} where #s251&lt;:PowerModels.AbstractPowerModel}} where L&lt;:PowerSystems.ElectricLoad"><code>PowerSimulations.reactivepower_constraints!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Reactive Power Constraints on Loads Assume Constant PowerFactor</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.reactivepower_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.Canonical,InfrastructureSystems.FlattenIteratorWrapper{T},Type{D},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where D&lt;:PowerSimulations.AbstractThermalDispatchFormulation where T&lt;:PowerSystems.ThermalGen" href="#PowerSimulations.reactivepower_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.Canonical,InfrastructureSystems.FlattenIteratorWrapper{T},Type{D},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where D&lt;:PowerSimulations.AbstractThermalDispatchFormulation where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.reactivepower_constraints!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function adds the reactive  power limits of generators when there are CommitmentVariables</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.reactivepower_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.Canonical,InfrastructureSystems.FlattenIteratorWrapper{T},Type{D},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where D&lt;:PowerSimulations.AbstractThermalFormulation where T&lt;:PowerSystems.ThermalGen" href="#PowerSimulations.reactivepower_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.Canonical,InfrastructureSystems.FlattenIteratorWrapper{T},Type{D},Type{S}}} where S&lt;:PowerModels.AbstractPowerModel where D&lt;:PowerSimulations.AbstractThermalFormulation where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.reactivepower_constraints!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function adds the reactive power limits of generators when there CommitmentVariables</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.reactivepower_variables!-Union{Tuple{T}, Tuple{PowerSimulations.Canonical,InfrastructureSystems.FlattenIteratorWrapper{T}}} where T&lt;:PowerSystems.ThermalGen" href="#PowerSimulations.reactivepower_variables!-Union{Tuple{T}, Tuple{PowerSimulations.Canonical,InfrastructureSystems.FlattenIteratorWrapper{T}}} where T&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.reactivepower_variables!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function add the variables for power generation output to the model</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.remove_chars-Tuple{String,String}" href="#PowerSimulations.remove_chars-Tuple{String,String}"><code>PowerSimulations.remove_chars</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Removes the string <code>char</code> from the original string</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.replace_chars-Tuple{String,String,String}" href="#PowerSimulations.replace_chars-Tuple{String,String,String}"><code>PowerSimulations.replace_chars</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Replaces the string in <code>char</code> with the string<code>replacement</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.reserve_device_semicontinuousrange-Tuple{PowerSimulations.Canonical,Array{Tuple{String,NamedTuple{(:min, :max),Tuple{Float64,Float64}}},1},Symbol,Symbol,Symbol}" href="#PowerSimulations.reserve_device_semicontinuousrange-Tuple{PowerSimulations.Canonical,Array{Tuple{String,NamedTuple{(:min, :max),Tuple{Float64,Float64}}},1},Symbol,Symbol,Symbol}"><code>PowerSimulations.reserve_device_semicontinuousrange</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">reserve_device_semicontinuousrange(canonical::Canonical,
                                scrange_data::Vector{NamedMinMax},
                                cons_name::Symbol,
                                var_name::Symbol,
                                binvar_name::Symbol)</code></pre><p>Constructs min/max range constraint from device variable and on/off decision variable.</p><p><strong>Constraints</strong></p><p>If device min = 0:</p><p><code>varcts[r[1], t] &lt;= r[2].max*(1-varbin[r[1], t])</code></p><p><code>varcts[r[1], t] &gt;= 0.0</code></p><p>Otherwise:</p><p><code>varcts[r[1], t] &lt;= r[2].max*(1-varbin[r[1], t])</code></p><p><code>varcts[r[1], t] &gt;= r[2].min*(1-varbin[r[1], t])</code></p><p>where r in range_data.</p><p><strong>LaTeX</strong></p><p><span>$0 \leq x^{cts} \leq r^{max} (1 - x^{bin} ), \text{ for } r^{min} = 0$</span></p><p><span>$r^{min} (1 - x^{bin} ) \leq x^{cts} \leq r^{max} (1 - x^{bin} ), \text{ otherwise }$</span></p><p><strong>Arguments</strong></p><ul><li>canonical::Canonical : the canonical model built in PowerSimulations</li><li>scrange_data::Vector{NamedMinMax} : contains name of device (1) and its min/max (2)</li><li>cons_name::Symbol : name of the constraint</li><li>var_name::Symbol : the name of the continuous variable</li><li>binvar_name::Symbol : the name of the binary variable</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.rowsum-Tuple{DataFrames.DataFrame,String}" href="#PowerSimulations.rowsum-Tuple{DataFrames.DataFrame,String}"><code>PowerSimulations.rowsum</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This sums all of the rows in a result dataframe </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.semicontinuousrange_ff-Tuple{PowerSimulations.Canonical,Symbol,PowerSimulations.UpdateRef,Symbol}" href="#PowerSimulations.semicontinuousrange_ff-Tuple{PowerSimulations.Canonical,Symbol,PowerSimulations.UpdateRef,Symbol}"><code>PowerSimulations.semicontinuousrange_ff</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">        semicontinuousrange_ff(canonical::Canonical,
                                cons_name::Symbol,
                                var_name::Symbol,
                                param_reference::UpdateRef)</code></pre><p>Constructs min/max range constraint from device variable with parameter setting.</p><p><strong>Constraints</strong></p><p>If device min = 0:</p><p><code>variable[var_name, t] &lt;= r[2].max*param_reference[var_name]</code></p><p>Otherwise:</p><p><code>variable[var_name, t] &lt;= r[2].max*param_reference[var_name]</code></p><p><code>variable[var_name, t] &gt;= r[2].min*param_reference[var_name]</code></p><p>where r in range_data.</p><p><strong>LaTeX</strong></p><p><span>$0.0 \leq x^{var} \leq r^{max} x^{param}, \text{ for } r^{min} = 0$</span></p><p><span>$r^{min} x^{param} \leq x^{var} \leq r^{min} x^{param}, \text{ otherwise }$</span></p><p><strong>Arguments</strong></p><ul><li>canonical::Canonical : the canonical model built in PowerSimulations</li><li>cons_name::Symbol : name of the constraint</li><li>var_name::Symbol : the name of the continuous variable</li><li>param_reference::UpdateRef : UpdateRef of the parameter</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.set_variable_bounds-Tuple{PowerSimulations.Canonical,Array{Tuple{String,NamedTuple{(:min, :max),Tuple{Float64,Float64}}},1},Symbol}" href="#PowerSimulations.set_variable_bounds-Tuple{PowerSimulations.Canonical,Array{Tuple{String,NamedTuple{(:min, :max),Tuple{Float64,Float64}}},1},Symbol}"><code>PowerSimulations.set_variable_bounds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_variable_bounds(canonical::Canonical,
                        bounds::Vector{NamedMinMax},
                        var_name::Symbol)</code></pre><p>Adds a bounds to a variable in the optimization model.</p><p><strong>Bounds</strong></p><p><code>bounds.min &lt;= varstart[name, t] &lt;= bounds.max</code></p><p><strong>LaTeX</strong></p><p><span>$x^{device}_t &gt;= bound^{min} \forall t$</span></p><p><span>$x^{device}_t &lt;= bound^{max} \forall t$</span></p><p><strong>Arguments</strong></p><ul><li>canonical::Canonical : the canonical model built in PowerSimulations</li><li>bounds::Vector{NamedMinMax} : contains name of device (1) and its min/max (2)</li><li>var_name::Symbol : Base Name for the variable</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.status_init-Union{Tuple{PSD}, Tuple{PowerSimulations.Canonical,InfrastructureSystems.FlattenIteratorWrapper{PSD}}} where PSD&lt;:PowerSystems.ThermalGen" href="#PowerSimulations.status_init-Union{Tuple{PSD}, Tuple{PowerSimulations.Canonical,InfrastructureSystems.FlattenIteratorWrapper{PSD}}} where PSD&lt;:PowerSystems.ThermalGen"><code>PowerSimulations.status_init</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Status Initis is always calculated based on the Power Output of the device This is to make it easier to calculate when the previous model doesn&#39;t contain binaries. For instance, looking back on an ED model to find the IC of the UC model</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.ub_ff-Tuple{PowerSimulations.Canonical,Symbol,PowerSimulations.UpdateRef,Symbol}" href="#PowerSimulations.ub_ff-Tuple{PowerSimulations.Canonical,Symbol,PowerSimulations.UpdateRef,Symbol}"><code>PowerSimulations.ub_ff</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">    ub_ff(canonical::Canonical,
          cons_name::Symbol,
          param_reference::UpdateRef,
          var_name::Symbol)</code></pre><p>Constructs a parametrized upper bound constraint to implement feedforward from other models. The Parameters are initialized using the uppper boundary values of the provided variables.</p><p><strong>Constraints</strong></p><p><code>variable[var_name, t] &lt;= param_reference[var_name]</code></p><p><strong>LaTeX</strong></p><p><span>$x \leq param^{max}$</span></p><p><strong>Arguments</strong></p><ul><li>canonical::Canonical : the canonical model built in PowerSimulations</li><li>cons_name::Symbol : name of the constraint</li><li>param_reference : Reference to the PJ.ParameterRef used to determine the upperbound</li><li>var_name::Symbol : the name of the continuous variable</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.variable_active_net_injection-Tuple{PowerModels.AbstractPowerModel}" href="#PowerSimulations.variable_active_net_injection-Tuple{PowerModels.AbstractPowerModel}"><code>PowerSimulations.variable_active_net_injection</code></a> — <span class="docstring-category">Method</span></header><section><div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.variable_net_injection-Tuple{PowerModels.AbstractPowerModel}" href="#PowerSimulations.variable_net_injection-Tuple{PowerModels.AbstractPowerModel}"><code>PowerSimulations.variable_net_injection</code></a> — <span class="docstring-category">Method</span></header><section><div><p>generates variables for both <code>active</code> and <code>reactive</code> net injection</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.variable_reactive_net_injection-Tuple{PowerModels.AbstractActivePowerModel}" href="#PowerSimulations.variable_reactive_net_injection-Tuple{PowerModels.AbstractActivePowerModel}"><code>PowerSimulations.variable_reactive_net_injection</code></a> — <span class="docstring-category">Method</span></header><section><div><p>active power only models ignore reactive power variables</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.variable_reactive_net_injection-Tuple{PowerModels.AbstractPowerModel}" href="#PowerSimulations.variable_reactive_net_injection-Tuple{PowerModels.AbstractPowerModel}"><code>PowerSimulations.variable_reactive_net_injection</code></a> — <span class="docstring-category">Method</span></header><section><div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.write_model_results-Tuple{PowerSimulations.Results,String,String}" href="#PowerSimulations.write_model_results-Tuple{PowerSimulations.Results,String,String}"><code>PowerSimulations.write_model_results</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Exports Simulation Model Results to a path</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSimulations.write_model_results-Tuple{PowerSimulations.Results,String}" href="#PowerSimulations.write_model_results-Tuple{PowerSimulations.Results,String}"><code>PowerSimulations.write_model_results</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Exports Operational Model Results to a path</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../man/op_problem/">« Operation Model</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 23 November 2019 01:06">Saturday 23 November 2019</span>. Using Julia version 1.2.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
