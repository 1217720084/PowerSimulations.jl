var documenterSearchIndex = {"docs":
[{"location":"api/PowerSimulations/#PowerSimulations-1","page":"PowerSimulations","title":"PowerSimulations","text":"","category":"section"},{"location":"api/PowerSimulations/#","page":"PowerSimulations","title":"PowerSimulations","text":"CurrentModule = PowerSimulations\nDocTestSetup  = quote\n    using PowerSimulations\nend","category":"page"},{"location":"api/PowerSimulations/#","page":"PowerSimulations","title":"PowerSimulations","text":"API documentation","category":"page"},{"location":"api/PowerSimulations/#","page":"PowerSimulations","title":"PowerSimulations","text":"Pages = [\"PowerSimulations.md\"]","category":"page"},{"location":"api/PowerSimulations/#Index-1","page":"PowerSimulations","title":"Index","text":"","category":"section"},{"location":"api/PowerSimulations/#","page":"PowerSimulations","title":"PowerSimulations","text":"Pages = [\"PowerSimulations.md\"]","category":"page"},{"location":"api/PowerSimulations/#Exported-1","page":"PowerSimulations","title":"Exported","text":"","category":"section"},{"location":"api/PowerSimulations/#","page":"PowerSimulations","title":"PowerSimulations","text":"Modules = [PowerSimulations]\nPrivate = false","category":"page"},{"location":"api/PowerSimulations/#PowerSimulations.TimeStatusChange","page":"PowerSimulations","title":"PowerSimulations.TimeStatusChange","text":"Tracks the last time status of a device changed in a simulation\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#PowerSimulations.get_all_constraint_index-Tuple{OperationModel}","page":"PowerSimulations","title":"PowerSimulations.get_all_constraint_index","text":"\"Each Tuple corresponds to (conname, internalindex, moi_index)\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.get_all_var_index-Tuple{OperationModel}","page":"PowerSimulations","title":"PowerSimulations.get_all_var_index","text":"\"Each Tuple corresponds to (conname, internalindex, moi_index)\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.run_sim_model!-Tuple{Simulation}","page":"PowerSimulations","title":"PowerSimulations.run_sim_model!","text":"Runs Simulations\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.sort_data-Tuple{PowerSimulations.OperationModelResults}","page":"PowerSimulations","title":"PowerSimulations.sort_data","text":"sort_data(results::OperationModelResults)\n\nThis function takes in struct OperationModelResults, sorts the generators in each variable, and outputs the sorted results. The generic function sorts the generators alphabetically.\n\nkwargs: 'Variables' to choose which variables to be sorted.\n\neach variable has a kwarg, so that a specific order can be generated, such that when plotted, the first generator is on the bottom. if a list of generator names has fewer generators than the variable, only the generators on the list will be outputted.\n\n#Examples\n\nexample 1: sortedresults = sortdata(res)\n\nsortedresults.variables[PRenewableDispatch] will be in the order\n\n[:WindBusA :WindBusB :WindBusC] (alphabetical)\n\nexample 2: myorder = [:WindBusC :WindBusB :WindBusA] sortedresults = sortdata(res; PRenewableDispatch = my_order)\n\nsortedresults.variables[PRenewableDispatch] will be in the order\n\n[:WindBusC :WindBusB :WindBusA] (my_order)\n\nexample 3: myorder = [:WindBusC :WindBusA] sortedresults = sortdata(res; PRenewableDispatch = my_order)\n\nsortedresults.variables[PRenewableDispatch] will be in the order\n\n[:WindBusC :WindBusA] (my_order)\n\nexample 4: myvariableorder = [:PThermalStandard :ONThermalStandard] sortedresults = sortdata(res; Variables = myvariableorder)\n\nsorted_results.variables \n\nDict{Symbol,DataFrames.DataFrame} with 2 entries:\n:P_ThermalStandard => 24×5 DataFrames.DataFrame…\n:ON_ThermalStandard => 24×5 DataFrames.DataFrame…\n\nnote that only the generators included in 'my_order' will be in the \n\nresults, and consequently, only these will be plotted. This can be a nice feature for variables with more than 5 generators.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.write_model_results-Tuple{PowerSimulations.OperationModelResults,String}","page":"PowerSimulations","title":"PowerSimulations.write_model_results","text":"Exports Operational Model Results to a path\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.write_op_model-Tuple{OperationModel,String}","page":"PowerSimulations","title":"PowerSimulations.write_op_model","text":"Exports the OpModel JuMP object in MathOptFormat\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#Internal-1","page":"PowerSimulations","title":"Internal","text":"","category":"section"},{"location":"api/PowerSimulations/#","page":"PowerSimulations","title":"PowerSimulations","text":"Modules = [PowerSimulations]\nPublic = false","category":"page"},{"location":"api/PowerSimulations/#PowerSimulations.UpdateRef","page":"PowerSimulations","title":"PowerSimulations.UpdateRef","text":"Reference for parameters update when present\n\n\n\n\n\n","category":"type"},{"location":"api/PowerSimulations/#Base.show-Tuple{IO,MIME{Symbol(\"text/plain\")},OperationModel}","page":"PowerSimulations","title":"Base.show","text":"Base.show(io::IO, ::MIME\"text/plain\", op_model::OperationModel)\n\nThis function goes through the fields in OperationModel and then in ModelReference, if the field contains a Device model dictionary, it calls organizedevicemodel() &  prints the data by field, key, value. If the field is not a Device model dictionary, and a value exists for that field it prints the value.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations._container_spec-Union{Tuple{M}, Tuple{M,Vararg{Any,N} where N}} where M<:JuMP.AbstractModel","page":"PowerSimulations","title":"PowerSimulations._container_spec","text":"Returns the correct container spec for the selected type of JuMP Model\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations._get_data_for_rocc-Tuple{Array{InitialCondition,1},Dates.Period}","page":"PowerSimulations","title":"PowerSimulations._get_data_for_rocc","text":"This function gets the data for the generators\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations._get_data_for_tdc-Tuple{Array{InitialCondition,1},Array{InitialCondition,1},Dates.Period}","page":"PowerSimulations","title":"PowerSimulations._get_data_for_tdc","text":"If the fraction of hours that a generator has a duration constraint is less than the fraction of hours that a single time_step represents then it is not binding.\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations._internal_device_constructor!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.CanonicalModel,DeviceModel{T,D},Type{S},PowerSystems.System}} where S<:PowerModels.AbstractActivePowerFormulation where D<:PowerSimulations.AbstractThermalFormulation where T<:PowerSystems.ThermalGen","page":"PowerSimulations","title":"PowerSimulations._internal_device_constructor!","text":"This function creates the model for a full themal dispatch formulation depending on combination of devices, deviceformulation and systemformulation\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations._internal_device_constructor!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.CanonicalModel,DeviceModel{T,D},Type{S},PowerSystems.System}} where S<:PowerModels.AbstractPowerFormulation where D<:PowerSimulations.AbstractThermalFormulation where T<:PowerSystems.ThermalGen","page":"PowerSimulations","title":"PowerSimulations._internal_device_constructor!","text":"This function creates the model for a full themal dispatch formulation depending on combination of devices, deviceformulation and systemformulation\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations._internal_device_constructor!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.CanonicalModel,DeviceModel{T,ThermalBasicUnitCommitment},Type{S},PowerSystems.System}} where S<:PowerModels.AbstractActivePowerFormulation where T<:PowerSystems.ThermalGen","page":"PowerSimulations","title":"PowerSimulations._internal_device_constructor!","text":"This function creates the model for a full themal dispatch formulation depending on combination of devices, deviceformulation and systemformulation\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations._internal_device_constructor!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.CanonicalModel,DeviceModel{T,ThermalBasicUnitCommitment},Type{S},PowerSystems.System}} where S<:PowerModels.AbstractPowerFormulation where T<:PowerSystems.ThermalGen","page":"PowerSimulations","title":"PowerSimulations._internal_device_constructor!","text":"This function creates the model for a full themal dispatch formulation depending on combination of devices, deviceformulation and systemformulation\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations._internal_device_constructor!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.CanonicalModel,DeviceModel{T,ThermalRampLimited},Type{S},PowerSystems.System}} where S<:PowerModels.AbstractActivePowerFormulation where T<:PowerSystems.ThermalGen","page":"PowerSimulations","title":"PowerSimulations._internal_device_constructor!","text":"This function creates the model for a full themal dispatch formulation depending on combination of devices, deviceformulation and systemformulation\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations._internal_device_constructor!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.CanonicalModel,DeviceModel{T,ThermalRampLimited},Type{S},PowerSystems.System}} where S<:PowerModels.AbstractPowerFormulation where T<:PowerSystems.ThermalGen","page":"PowerSimulations","title":"PowerSimulations._internal_device_constructor!","text":"This function creates the model for a full themal dispatch formulation depending on combination of devices, deviceformulation and systemformulation\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations._pwl_cost-Union{Tuple{JV}, Tuple{PowerSimulations.CanonicalModel,JV,Array{Tuple{Float64,Float64},1}}} where JV<:JuMP.AbstractVariableRef","page":"PowerSimulations","title":"PowerSimulations._pwl_cost","text":"_gen_cost(cost_)\n\nReturns JuMP expression for a piecewise linear cost function depending on the data compatibility.\n\nReturns gen_cost\n\nArguments\n\ncanonical_model::CanonicalModel : the canonical model built in PowerSimulations\nvariable::JuMP.Containers.DenseAxisArray{JV} : variable array\ncost_component::PSY.VariableCost{NTuple{2, Float64}} : container for quadratic and linear factors\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations._pwlgencost_linear-Union{Tuple{JV}, Tuple{PowerSimulations.CanonicalModel,JV,Array{Tuple{Float64,Float64},1}}} where JV<:JuMP.AbstractVariableRef","page":"PowerSimulations","title":"PowerSimulations._pwlgencost_linear","text":"_pwlgencost_sos(canonical_model::CanonicalModel,\n            variable::JuMP.Containers.DenseAxisArray{JV},\n            cost_component::PSY.VariableCost{NTuple{2, Float64}}) where {JV <: JuMP.AbstractVariableRef}\n\nReturns piecewise cost expression using linear implementation for canonical model.\n\nEquations\n\n0 <= pwl_var[i] <= (cost_component[2][i] - cost_component[2][i-1])\n\nvariable = sum(pwl_var[i])\n\ngen_cost = sum(pwl_var[i]*cost_component[1][i]/cost_component[2][i])\n\nLaTeX\n\n0 = pwl_i = (c_2 i - c_2 i-1)\n\nvariable = (sum_iin I pwl_i)\n\ngen_cost = (sum_iin I  pwl_i) c_1 ic_2 i\n\nReturns gen_cost\n\nArguments\n\ncanonical_model::CanonicalModel : the canonical model built in PowerSimulations\nvariable::JuMP.Containers.DenseAxisArray{JV} : variable array\ncost_component::PSY.VariableCost{NTuple{2, Float64}} : container for quadratic and linear factors\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations._pwlgencost_sos-Union{Tuple{JV}, Tuple{PowerSimulations.CanonicalModel,JV,Array{Tuple{Float64,Float64},1}}} where JV<:JuMP.AbstractVariableRef","page":"PowerSimulations","title":"PowerSimulations._pwlgencost_sos","text":"_pwlgencost_sos(canonical_model::CanonicalModel,\n            variable::JuMP.Containers.DenseAxisArray{JV},\n            cost_component::PSY.VariableCost{NTuple{2, Float64}}) where {JV <: JuMP.AbstractVariableRef}\n\nReturns piecewise cost expression using SOS Type-2 implementation for canonical model.\n\nEquations\n\nvariable = sum(sos_var[i]*cost_component[2][i])\n\ngen_cost = sum(sos_var[i]*cost_component[1][i])\n\nLaTeX\n\nvariable = (sum_iin I c_2 i sos_i)\n\ngen_cost = (sum_iin I c_1 i sos_i)\n\nReturns gen_cost\n\nArguments\n\ncanonical_model::CanonicalModel : the canonical model built in PowerSimulations\nvariable::JuMP.Containers.DenseAxisArray{JV} : variable array\ncost_component::PSY.VariableCost{NTuple{2, Float64}} : container for quadratic and linear factors\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations._pwlparamcheck-Tuple{Any}","page":"PowerSimulations","title":"PowerSimulations._pwlparamcheck","text":"_pwlparamcheck(cost_)\n\nReturns True/False depending on compatibility of the cost data with the linear implementation method\n\nReturns flag\n\nArguments\n\ncost_::PSY.VariableCost{NTuple{2, Float64}} : container for quadratic and linear factors\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations._retrieve_forecasts-Union{Tuple{C}, Tuple{PowerSystems.System,Type{C}}} where C<:PowerSystems.Component","page":"PowerSimulations","title":"PowerSimulations._retrieve_forecasts","text":"Only used when building the model\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.activepower_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.CanonicalModel,InfrastructureSystems.FlattenIteratorWrapper{T},Type{D},Type{S}}} where S<:PowerModels.AbstractPowerFormulation where D<:PowerSimulations.AbstractThermalDispatchForm where T<:PowerSystems.ThermalGen","page":"PowerSimulations","title":"PowerSimulations.activepower_constraints!","text":"This function adds the active power limits of generators when there are no CommitmentVariables\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.activepower_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.CanonicalModel,InfrastructureSystems.FlattenIteratorWrapper{T},Type{D},Type{S}}} where S<:PowerModels.AbstractPowerFormulation where D<:PowerSimulations.AbstractThermalFormulation where T<:PowerSystems.ThermalGen","page":"PowerSimulations","title":"PowerSimulations.activepower_constraints!","text":"This function adds the active power limits of generators when there are CommitmentVariables\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.activepower_constraints!-Union{Tuple{S}, Tuple{T}, Tuple{PowerSimulations.CanonicalModel,InfrastructureSystems.FlattenIteratorWrapper{T},Type{ThermalDispatchNoMin},Type{S}}} where S<:PowerModels.AbstractPowerFormulation where T<:PowerSystems.ThermalGen","page":"PowerSimulations","title":"PowerSimulations.activepower_constraints!","text":"This function adds the active power limits of generators when there are     no CommitmentVariables\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.activepower_constraints-Union{Tuple{S}, Tuple{L}, Tuple{PowerSimulations.CanonicalModel,InfrastructureSystems.FlattenIteratorWrapper{L},Type{InterruptiblePowerLoad},Type{S}}} where S<:PowerModels.AbstractPowerFormulation where L<:PowerSystems.ElectricLoad","page":"PowerSimulations","title":"PowerSimulations.activepower_constraints","text":"This function works only if the the ParamL <= PSY.getmaxactivepower(g)\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.activepower_variables!-Union{Tuple{T}, Tuple{PowerSimulations.CanonicalModel,InfrastructureSystems.FlattenIteratorWrapper{T}}} where T<:PowerSystems.ThermalGen","page":"PowerSimulations","title":"PowerSimulations.activepower_variables!","text":"This function add the variables for power generation output to the model\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_to_cost-Union{Tuple{D}, Tuple{PowerSimulations.CanonicalModel,D,Symbol,Symbol}, Tuple{PowerSimulations.CanonicalModel,D,Symbol,Symbol,Float64}} where D<:(InfrastructureSystems.FlattenIteratorWrapper{#s61} where #s61<:PowerSystems.Device)","page":"PowerSimulations","title":"PowerSimulations.add_to_cost","text":"add_to_cost(canonical_model::CanonicalModel,\n                 devices::D,\n                 var_name::Symbol,\n                 cost_symbol::Symbol,\n                 sign::Float64 = 1.0) where {D<:IS.FlattenIteratorWrapper{<:PSY.Device}}\n\nAdds cost expression for each device using appropriate call to ps_cost.\n\nExpression\n\nfor d in devices\n\n                              variable[PSY.get_name(d), :],\n                              getfield(PSY.get_op_cost(d), cost_symbol),\n                              dt,\n                              sign) ```\n\ncanonicalmodel.costfunction += cost_expression ```\n\nLaTeX\n\nCOST = sum_din D cost_d\n\nArguments\n\ncanonical_model::CanonicalModel : the canonical model built in PowerSimulations\ndevices::D : set of devices\nvar_name::Symbol : name of variable\ncost_symbol::Symbol : symbol associated with costx\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.add_variable-Union{Tuple{D}, Tuple{PowerSimulations.CanonicalModel,D,Symbol,Bool}, Tuple{PowerSimulations.CanonicalModel,D,Symbol,Bool,Union{Nothing, Symbol}}, Tuple{PowerSimulations.CanonicalModel,D,Symbol,Bool,Union{Nothing, Symbol},Float64}} where D<:Union{Array{#s224,1} where #s224<:PowerSystems.Device, InfrastructureSystems.FlattenIteratorWrapper{#s225} where #s225<:PowerSystems.Device}","page":"PowerSimulations","title":"PowerSimulations.add_variable","text":"add_variable(canonical_model::CanonicalModel,\n                  devices::D,\n                  var_name::Symbol,\n                  binary::Bool,\n                  expression::Symbol,\n                  sign::Float64)\n\nAdds a variable to the optimization model and to the affine expressions contained in the canonical model according to the specified sign. Based on the inputs, the variable can be specified as binary.\n\nBounds\n\nlb_value_function <= varstart[name, t] <= ub_value_function\n\nIf binary = true:\n\nvarstart[name, t] in {0,1}\n\nLaTeX\n\nlb ge x^device_t le ub forall t\n\nx^device_t in 01 forall t iff textbinary = true\n\nArguments\n\ncanonical_model::CanonicalModel : the canonical model built in PowerSimulations\ndevices : Vector or Iterator with the devices\nvar_name::Symbol : Base Name for the variable\nbinary::Bool : Select if the variable is binary\nexpression::Symbol : Expression name stored in canonical_model.expressions to add the variable\nsign::Float64 : sign of the addition of the variable to the expression. Default Value is 1.0\n\nAccepted Keyword Arguments\n\nubvaluefunction : Provides the function over device to obtain the value for a upper_bound\nlbvaluefunction : Provides the function over device to obtain the value for a lower_bound. If the variable is meant to be positive define lb = x -> 0.0\ninitialvaluefunction : Provides the function over device to obtain the warm start value\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.build_nip_expr_model-Tuple{Dict{String,Any},Any}","page":"PowerSimulations","title":"PowerSimulations.build_nip_expr_model","text":"\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.build_nip_model-Tuple{Dict{String,Any},Any}","page":"PowerSimulations","title":"PowerSimulations.build_nip_model","text":"\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.commitment_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.CanonicalModel,InfrastructureSystems.FlattenIteratorWrapper{T},Type{D},Type{S}}} where S<:PowerModels.AbstractPowerFormulation where D<:PowerSimulations.AbstractThermalFormulation where T<:PowerSystems.ThermalGen","page":"PowerSimulations","title":"PowerSimulations.commitment_constraints!","text":"This function adds the Commitment Status constraint when there are CommitmentVariables\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.commitment_variables!-Union{Tuple{T}, Tuple{PowerSimulations.CanonicalModel,InfrastructureSystems.FlattenIteratorWrapper{T}}} where T<:PowerSystems.ThermalGen","page":"PowerSimulations","title":"PowerSimulations.commitment_variables!","text":"This function add the variables for power generation commitment to the model\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.constraint_power_balance_ni-Tuple{PowerModels.GenericPowerModel,Int64,Int64,Int64,Any,Any}","page":"PowerSimulations","title":"PowerSimulations.constraint_power_balance_ni","text":"\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.constraint_power_balance_ni-Tuple{PowerModels.GenericPowerModel,Int64}","page":"PowerSimulations","title":"PowerSimulations.constraint_power_balance_ni","text":"\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.constraint_power_balance_ni-Union{Tuple{T}, Tuple{PowerModels.GenericPowerModel{T},Int64,Int64,Int64,Any,Any}} where T<:PowerModels.AbstractDCPForm","page":"PowerSimulations","title":"PowerSimulations.constraint_power_balance_ni","text":"active power only models ignore reactive power flows\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.constraint_power_balance_ni_expr-Tuple{PowerModels.GenericPowerModel,Int64,Int64,Int64,Any,Any,Any,Any}","page":"PowerSimulations","title":"PowerSimulations.constraint_power_balance_ni_expr","text":"\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.constraint_power_balance_ni_expr-Tuple{PowerModels.GenericPowerModel,Int64}","page":"PowerSimulations","title":"PowerSimulations.constraint_power_balance_ni_expr","text":"\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.constraint_power_balance_ni_expr-Union{Tuple{T}, Tuple{PowerModels.GenericPowerModel{T},Int64,Int64,Int64,Any,Any,Any,Any}} where T<:PowerModels.AbstractDCPForm","page":"PowerSimulations","title":"PowerSimulations.constraint_power_balance_ni_expr","text":"\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.device_commitment-Tuple{PowerSimulations.CanonicalModel,Array{InitialCondition,1},Symbol,Tuple{Symbol,Symbol,Symbol}}","page":"PowerSimulations","title":"PowerSimulations.device_commitment","text":"device_commitment(canonical_model::CanonicalModel,\n                    initial_conditions::Vector{InitialCondition},\n                    cons_name::Symbol,\n                    var_names::Tuple{Symbol, Symbol, Symbol})\n\nConstructs multi-timestep constraint from initial conditions and binary variable tuple.\n\nConstraints\n\nvarstart + varstop <= 1.0\n\nIf t = 1:\n\nvaron[name, 1] == ic.value + varstart[name, 1] - varstop[name, 1]\n\nwhere ic in initial_condtions.\n\nIf t > 1:\n\nvaron[name, t] == varon[name, t-1] + varstart[name, t] - varstop[name, t]\n\nLaTeX\n\nx^on_t + x^off_t leq 10 forall t\n\nx^on_1 = x^on_init + x^start_1 - x^stop_1 text for  t = 1\n\nx^on_t = x^on_t-1 + x^start_t - x^stop_t forall t geq 2\n\nArguments\n\ncanonical_model::CanonicalModel : the canonical model built in PowerSimulations\ninitial_conditions::Vector{InitialCondition} : for time zero 'varon'\ncons_name::Symbol : name of the constraint\nvar_names::Tuple{Symbol, Symbol, Symbol} : the names of the variables\n: var_names[1] : varstart\n: var_names[2] : varstop\n: var_names[3] : varon\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.device_duration_look_ahead-Tuple{PowerSimulations.CanonicalModel,Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{InitialCondition,2},Symbol,Tuple{Symbol,Symbol,Symbol}}","page":"PowerSimulations","title":"PowerSimulations.device_duration_look_ahead","text":"device_duration_look_ahead(canonical_model::CanonicalModel,\n                            duration_data::Vector{UpDown},\n                            initial_duration::Matrix{InitialCondition},\n                            cons_name::Symbol,\n                            var_names::Tuple{Symbol, Symbol, Symbol})\n\nThis formulation of the duration constraints looks ahead in the time frame of the model.\n\nLaTeX\n\nMinimum up-time constraint:\n\nIf t leq d_min^up\n\nd_min^downx_t^stop - sum_i=t-d_min^up + 1^t x_i^on - x_init^up leq 0\n\nfor i in the set of time steps. Otherwise:\n\nd_min^downx_t^stop - sum_i=t-d_min^up + 1^t x_i^on leq 0\n\nfor i in the set of time steps.\n\nMinimum down-time constraint:\n\nIf t leq d_min^down\n\nd_min^upx_t^start - sum_i=t-d_min^down + 1^t (1 - x_i^on) - x_init^down leq 0\n\nfor i in the set of time steps. Otherwise:\n\nd_min^upx_t^start - sum_i=t-d_min^down + 1^t (1 - x_i^on) leq 0\n\nfor i in the set of time steps.\n\nArguments\n\ncanonical_model::CanonicalModel : the canonical model built in PowerSimulations\nduration_data::Vector{UpDown} : gives how many time steps variable needs to be up or down\ninitial_duration::Matrix{InitialCondition} : gives initial conditions for up (column 1) and down (column 2)\ncons_name::Symbol : name of the constraint\nvar_names::Tuple{Symbol, Symbol, Symbol}) : names of the variables\n: var_names[1] : varon\n: var_names[2] : varstart\n: var_names[3] : varstop\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.device_duration_param-Tuple{PowerSimulations.CanonicalModel,Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{InitialCondition,2},Symbol,Tuple{Symbol,Symbol,Symbol}}","page":"PowerSimulations","title":"PowerSimulations.device_duration_param","text":"device_duration_param(canonical_model::CanonicalModel,\n                         duration_data::Vector{UpDown},\n                         initial_duration_on::Vector{InitialCondition},\n                         initial_duration_off::Vector{InitialCondition},\n                         cons_name::Symbol,\n                         var_names::Tuple{Symbol, Symbol, Symbol})\n\nThis formulation of the duration constraints considers parameters.\n\nLaTeX\n\nMinimum up-time constraint:\n\nIf t leq d_min^up\n\nd_min^downx_t^stop - sum_i=t-d_min^up + 1^t x_i^on - x_init^up leq 0\n\nfor i in the set of time steps. Otherwise:\n\nsum_i=t-d_min^up + 1^t x_i^start - x_t^on leq 0\n\nfor i in the set of time steps.\n\nMinimum down-time constraint:\n\nIf t leq d_min^down\n\nd_min^upx_t^start - sum_i=t-d_min^down + 1^t (1 - x_i^on) - x_init^down leq 0\n\nfor i in the set of time steps. Otherwise:\n\nsum_i=t-d_min^down + 1^t x_i^stop + x_t^on leq 1\n\nfor i in the set of time steps.\n\nArguments\n\ncanonical_model::CanonicalModel : the canonical model built in PowerSimulations\nduration_data::Vector{UpDown} : gives how many time steps variable needs to be up or down\ninitialdurationon::Vector{InitialCondition} : gives initial number of time steps variable is up\ninitialdurationoff::Vector{InitialCondition} : gives initial number of time steps variable is down\ncons_name::Symbol : name of the constraint\nvar_names::Tuple{Symbol, Symbol, Symbol}) : names of the variables\n: var_names[1] : varon\n: var_names[2] : varstart\n: var_names[3] : varstop\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.device_duration_retrospective-Tuple{PowerSimulations.CanonicalModel,Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{InitialCondition,2},Symbol,Tuple{Symbol,Symbol,Symbol}}","page":"PowerSimulations","title":"PowerSimulations.device_duration_retrospective","text":"device_duration_retrospective(canonical_model::CanonicalModel,\n                                    duration_data::Vector{UpDown},\n                                    initial_duration::Matrix{InitialCondition},\n                                    cons_name::Symbol,\n                                    var_names::Tuple{Symbol, Symbol, Symbol})\n\nThis formulation of the duration constraints adds over the start times looking backwards.\n\nLaTeX\n\nMinimum up-time constraint:\n\nIf t leq d_min^up - d_init^up and d_init^up  0\n\n1 + sum_i=t-d_min^up + 1^t x_i^start - x_t^on leq 0\n\nfor i in the set of time steps. Otherwise:\n\nsum_i=t-d_min^up + 1^t x_i^start - x_t^on leq 0\n\nfor i in the set of time steps.\n\nMinimum down-time constraint:\n\nIf t leq d_min^down - d_init^down and d_init^down  0\n\n1 + sum_i=t-d_min^down + 1^t x_i^stop + x_t^on leq 1\n\nfor i in the set of time steps. Otherwise:\n\nsum_i=t-d_min^down + 1^t x_i^stop + x_t^on leq 1\n\nfor i in the set of time steps.\n\nArguments\n\ncanonical_model::CanonicalModel : the canonical model built in PowerSimulations\nduration_data::Vector{UpDown} : gives how many time steps variable needs to be up or down\ninitial_duration::Matrix{InitialCondition} : gives initial conditions for up (column 1) and down (column 2)\ncons_name::Symbol : name of the constraint\nvar_names::Tuple{Symbol, Symbol, Symbol}) : names of the variables\n: var_names[1] : varon\n: var_names[2] : varstart\n: var_names[3] : varstop\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.device_linear_rateofchange-Tuple{PowerSimulations.CanonicalModel,Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{InitialCondition,1},Symbol,Symbol}","page":"PowerSimulations","title":"PowerSimulations.device_linear_rateofchange","text":"device_linear_rateofchange(canonical_model::CanonicalModel,\n                                rate_data::Tuple{Vector{String}, Vector{UpDown}},\n                                initial_conditions::Vector{InitialCondition},\n                                cons_name::Symbol,\n                                var_name::Symbol)\n\nConstructs allowed rate-of-change constraints from variables, initial condtions, and rate data.\n\nConstraints\n\nIf t = 1:\n\nvariable[name, 1] - initial_conditions[ix].value <= rate_data[1][ix].up\n\ninitial_conditions[ix].value - variable[name, 1] <= rate_data[1][ix].down\n\nIf t > 1:\n\nvariable[name, t] - variable[name, t-1] <= rate_data[1][ix].up\n\nvariable[name, t-1] - variable[name, t] <= rate_data[1][ix].down\n\nLaTeX\n\nr^down leq x_1 - x_init leq r^up text for  t = 1\n\nr^down leq x_t - x_t-1 leq r^up forall t geq 2\n\nArguments\n\ncanonical_model::CanonicalModel : the canonical model built in PowerSimulations\nrate_data::Tuple{Vector{String}, Vector{UpDown}} : gives name (1) and max ramp up/down rates (2)\ninitial_conditions::Vector{InitialCondition} : for time zero 'variable'\ncons_name::Symbol : name of the constraint\nvar_name::Tuple{Symbol, Symbol, Symbol} : the name of the variable\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.device_mixedinteger_rateofchange-Tuple{PowerSimulations.CanonicalModel,Tuple{Array{NamedTuple{(:up, :down),Tuple{Float64,Float64}},1},Array{NamedTuple{(:min, :max),Tuple{Float64,Float64}},1}},Array{InitialCondition,1},Symbol,Tuple{Symbol,Symbol,Symbol}}","page":"PowerSimulations","title":"PowerSimulations.device_mixedinteger_rateofchange","text":"device_mixedinteger_rateofchange(canonical_model::CanonicalModel,\n                                      rate_data::Tuple{Vector{String}, Vector{UpDown}, Vector{MinMax}},\n                                      initial_conditions::Vector{InitialCondition},\n                                      cons_name::Symbol,\n                                      var_names::Tuple{Symbol, Symbol, Symbol})\n\nConstructs allowed rate-of-change constraints from variables, initial condtions, start/stop status, and rate data\n\nEquations\n\nIf t = 1:\n\nvariable[name, 1] - initial_conditions[ix].value <= rate_data[1][ix].up + rate_data[2][ix].max*varstart[name, 1]\n\ninitial_conditions[ix].value - variable[name, 1] <= rate_data[1][ix].down + rate_data[2][ix].min*varstop[name, 1]\n\nIf t > 1:\n\nvariable[name, t] - variable[name, t-1] <= rate_data[1][ix].up + rate_data[2][ix].max*varstart[name, t]\n\nvariable[name, t-1] - variable[name, t] <= rate_data[1][ix].down + rate_data[2][ix].min*varstop[name, t]\n\nLaTeX\n\nr^down + r^min x^stop_1 leq x_1 - x_init leq r^up + r^max x^start_1 text for  t = 1\n\nr^down + r^min x^stop_t leq x_t - x_t-1 leq r^up + r^max x^start_t forall t geq 2\n\nArguments\n\ncanonical_model::CanonicalModel : the canonical model built in PowerSimulations\nrate_data::Tuple{Vector{String}, Vector{UpDown}, Vector{MinMax}} : (1) gives name                                                                    (2) gives min/max ramp rates                                                                    (3) gives min/max for 'variable'\ninitial_conditions::Vector{InitialCondition} : for time zero 'variable'\ncons_name::Symbol : name of the constraint\nvar_names::Tuple{Symbol, Symbol, Symbol} : the names of the variables\n: var_names[1] : 'variable'\n: var_names[2] : 'varstart'\n: var_names[3] : 'varstop'\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.device_range-Tuple{PowerSimulations.CanonicalModel,Array{Tuple{String,NamedTuple{(:min, :max),Tuple{Float64,Float64}}},1},Symbol,Symbol}","page":"PowerSimulations","title":"PowerSimulations.device_range","text":"device_range(canonical_model::CanonicalModel,\n                    range_data::Vector{NamedMinMax},\n                    cons_name::Symbol,\n                    var_name::Symbol)\n\nConstructs min/max range constraint from device variable.\n\nConstraints\n\nIf min and max within an epsilon width:\n\nvariable[r[1], t] == r[2].max\n\nOtherwise:\n\nr[2].min <= variable[r[1], t] <= r[2].max\n\nwhere r in range_data.\n\nLaTeX\n\nx = r^max text for  r^max - r^min  varepsilon\n\nr^min leq x leq r^max text otherwise \n\nArguments\n\ncanonical_model::CanonicalModel : the canonical model built in PowerSimulations\nrange_data::Vector{NamedMinMax} : contains name of device (1) and its min/max (2)\ncons_name::Symbol : name of the constraint\nvar_name::Symbol : the name of the continuous variable\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.device_semicontinuousrange-Tuple{PowerSimulations.CanonicalModel,Array{Tuple{String,NamedTuple{(:min, :max),Tuple{Float64,Float64}}},1},Symbol,Symbol,Symbol}","page":"PowerSimulations","title":"PowerSimulations.device_semicontinuousrange","text":"device_semicontinuousrange(canonical_model::CanonicalModel,\n                                scrange_data::Vector{NamedMinMax},\n                                cons_name::Symbol,\n                                var_name::Symbol,\n                                binvar_name::Symbol)\n\nConstructs min/max range constraint from device variable and on/off decision variable.\n\nConstraints\n\nIf device min = 0:\n\nvarcts[r[1], t] <= r[2].max*varbin[r[1], t])\n\nvarcts[r[1], t] >= 0.0\n\nOtherwise:\n\nvarcts[r[1], t] <= r[2].max*varbin[r[1], t]\n\nvarcts[r[1], t] >= r[2].min*varbin[r[1], t]\n\nwhere r in range_data.\n\nLaTeX\n\n0 leq x^cts leq r^max x^bin text for  r^min = 0\n\nr^min x^bin leq x^cts leq r^max x^bin text otherwise \n\nArguments\n\ncanonical_model::CanonicalModel : the canonical model built in PowerSimulations\nscrange_data::Vector{NamedMinMax} : contains name of device (1) and its min/max (2)\ncons_name::Symbol : name of the constraint\nvar_name::Symbol : the name of the continuous variable\nbinvar_name::Symbol : the name of the binary variable\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.device_timeseries_lb-Tuple{PowerSimulations.CanonicalModel,Tuple{Array{String,1},Array{Float64,1},Array{Array{Float64,1},1}},Symbol,Symbol}","page":"PowerSimulations","title":"PowerSimulations.device_timeseries_lb","text":"device_timeseries_lb(canonical_model::CanonicalModel,\n                 ts_data::Tuple{Vector{String}, Vector{Float64}, Vector{Vector{Float64}}},\n                 cons_name::Symbol,\n                 var_name::Symbol)\n\nConstructs lower bound for given variable subject to time series data and a multiplier.\n\nConstraint\n\nts_data[2][ix]*ts_data[3][ix][t] <= variable[name, t]\n\nLaTeX\n\nr^val r_t leq x_t forall t\n\nwhere (ix, name) in enumerate(ts_data[1]).\n\nArguments\n\ncanonical_model::CanonicalModel : the canonical model built in PowerSimulations\nts_data::Tuple{Vector{String}, Vector{Float64}, Vector{Vector{Float64}}} : timeseries data name (1), multiplier (2) and values (3)\ncons_name::Symbol : name of the constraint\nvar_name::Symbol : the name of the variable\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.device_timeseries_param_lb-Tuple{PowerSimulations.CanonicalModel,Tuple{Array{String,1},Array{Float64,1},Array{Array{Float64,1},1}},Symbol,PowerSimulations.UpdateRef,Symbol}","page":"PowerSimulations","title":"PowerSimulations.device_timeseries_param_lb","text":"device_timeseries_param_lb(canonical_model::CanonicalModel,\n                                ts_data::Tuple{Vector{String}, Vector{Float64}, Vector{Vector{Float64}}},\n                                cons_name::Symbol,\n                                param_reference::UpdateRef,\n                                var_name::Symbol)\n\nConstructs lower bound for given variable using a parameter. The constraint is     built with a time series data vector and a multiplier\n\nConstraint\n\nts_data[2][ix] * param[name, t] <= variable[name, t]\n\nLaTeX\n\nr^val x^param_t leq x^var_t forall t\n\nArguments\n\ncanonical_model::CanonicalModel : the canonical model built in PowerSimulations\nts_data::Tuple{Vector{String}, Vector{Vector{Float64}}} : timeseries data name (1) and values (2)\ncons_name::Symbol : name of the constraint\nparam_reference::UpdateRef : UpdateRef to access the parameter\nvar_name::Symbol : the name of the variable\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.device_timeseries_param_ub-Tuple{PowerSimulations.CanonicalModel,Tuple{Array{String,1},Array{Float64,1},Array{Array{Float64,1},1}},Symbol,PowerSimulations.UpdateRef,Symbol}","page":"PowerSimulations","title":"PowerSimulations.device_timeseries_param_ub","text":"device_timeseries_param_ub(canonical_model::CanonicalModel,\n                                ts_data::Tuple{Vector{String}, Vector{Float64}, Vector{Vector{Float64}}},\n                                cons_name::Symbol,\n                                param_reference::UpdateRef,\n                                var_name::Symbol)\n\nConstructs upper bound for given variable using a parameter. The constraint is     built with a time series data vector and a multiplier\n\nConstraint\n\nvariable[name, t] <= ts_data[2][ix]*param[name, t]\n\nLaTeX\n\nx^var_t leq r^val x^param_t forall t\n\nArguments\n\ncanonical_model::CanonicalModel : the canonical model built in PowerSimulations\nts_data::Tuple{Vector{String}, Vector{Float64}, Vector{Vector{Float64}}} : timeseries data name (1), multiplier (2) and values (3)\ncons_name::Symbol : name of the constraint\nparam_reference::UpdateRef : UpdateRef to access the parameter\nvar_name::Symbol : the name of the variable\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.device_timeseries_ub-Tuple{PowerSimulations.CanonicalModel,Tuple{Array{String,1},Array{Float64,1},Array{Array{Float64,1},1}},Symbol,Symbol}","page":"PowerSimulations","title":"PowerSimulations.device_timeseries_ub","text":"device_timeseries_ub(canonical_model::CanonicalModel,\n                 ts_data::Tuple{Vector{String}, Vector{Float64}, Vector{Vector{Float64}}},\n                 cons_name::Symbol,\n                 var_name::Symbol)\n\nConstructs upper bound for given variable and time series data and a multiplier.\n\nConstraint\n\nvariable[name, t] <= ts_data[2][ix]*ts_data[3][ix][t]\n\nLaTeX\n\nx_t leq r^val r_t forall t\n\nArguments\n\ncanonical_model::CanonicalModel : the canonical model built in PowerSimulations\nts_data::Tuple{Vector{String}, Vector{Float64}, Vector{Vector{Float64}}} : timeseries data name (1), multiplier (2) and values (3)\ncons_name::Symbol : name of the constraint\nvar_name::Symbol : the name of the variable\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.device_timeseries_ub_bigM","page":"PowerSimulations","title":"PowerSimulations.device_timeseries_ub_bigM","text":"device_timeseries_ub_bigM(canonical_model::CanonicalModel,\n                                ts_data::Tuple{Vector{String}, Vector{Float64}, Vector{Vector{Float64}}},\n                                cons_name::Symbol,\n                                var_name::Symbol,\n                                param_reference::UpdateRef,\n                                binvar_name::Symbol,\n                                M_value::Float64 = 1e6)\n\nConstructs upper bound for variable and time series and a multiplier or confines to 0 depending on binary variable.     Uses BigM constraint type to allow for parameter since ParameterJuMP doesn't support var*parameter\n\nConstraints\n\nvarcts[name, t] - ts_data[2][ix] * param[name, t] <= (1 - varbin[name, t])*M_value\n\nvarcts[name, t] <= varbin[name, t]*M_value\n\nLaTeX\n\nx^cts_t - r^val x^param_t leq M(1 - x^bin_t ) forall t\n\nx^cts_t leq M x^bin_t forall t\n\nArguments\n\ncanonical_model::CanonicalModel : the canonical model built in PowerSimulations\nts_data::Tuple{Vector{String}, Vector{Vector{Float64}}} : timeseries data name (1) and values (2)\ncons_name::Symbol : name of the constraint\nvar_name::Symbol :  name of the variable\n\nparam_reference::UpdateRef : UpdateRef of access the parameters\n\nbinvar_name::Symbol : name of binary variable\nM_value::Float64 : bigM\n\n\n\n\n\n","category":"function"},{"location":"api/PowerSimulations/#PowerSimulations.device_timeseries_ub_bin-Tuple{PowerSimulations.CanonicalModel,Tuple{Array{String,1},Array{Float64,1},Array{Array{Float64,1},1}},Symbol,Symbol,Symbol}","page":"PowerSimulations","title":"PowerSimulations.device_timeseries_ub_bin","text":"device_timeseries_ub_bin(canonical_model::CanonicalModel,\n                                ts_data::Tuple{Vector{String}, Vector{Float64}, Vector{Vector{Float64}}},\n                                cons_name::Symbol,\n                                var_name::Symbol,\n                                binvar_name::Symbol)\n\nConstructs upper bound for variable and time series or confines to 0 depending on binary variable.     The upper bound is defined by a time series and a multiplier.\n\nConstraints\n\nvarcts[name, t] <= varbin[name, t]* ts_data[2][ix] * ts_data[3][ix][t]\n\nwhere (ix, name) in enumerate(ts_data[1]).\n\nLaTeX\n\nx^cts_t leq r^val r_t x^bin_t forall t\n\nArguments\n\ncanonical_model::CanonicalModel : the canonical model built in PowerSimulations\nts_data::Tuple{Vector{String}, Vector{Vector{Float64}}} : timeseries data name (1) and values (2)\ncons_name::Symbol : name of the constraint\nvar_name::Symbol :  name of the variable\nbinvar_name::Symbol : name of binary variable\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.energy_balance-Tuple{PowerSimulations.CanonicalModel,Array{InitialCondition,1},Tuple{Array{String,1},Array{NamedTuple{(:in, :out),Tuple{Float64,Float64}},1}},Symbol,Tuple{Symbol,Symbol,Symbol}}","page":"PowerSimulations","title":"PowerSimulations.energy_balance","text":"energy_balance(canonical_model::CanonicalModel,\n                    initial_conditions::Vector{InitialCondition},\n                    efficiency_data::Tuple{Vector{String}, Vector{InOut}},\n                    cons_name::Symbol,\n                    var_names::Tuple{Symbol, Symbol, Symbol})\n\nConstructs multi-timestep constraint from initial condition, efficiency data, and variable tuple\n\nConstraints\n\nIf t = 1:\n\nvarenergy[name, 1] == initial_conditions[ix].value + varin[name, 1]*eff_in*fraction_of_hour - varout[name, 1]*fraction_of_hour/eff_out\n\nIf t > 1:\n\nvarenergy[name, t] == varenergy[name, t-1] + varin[name, t]*eff_in*fraction_of_hour - varout[name, t]*fraction_of_hour/eff_out\n\nLaTeX\n\nx^energy_1 == x^energy_init + frhr eta^in x^in_1 - fracfrhreta^out x^out_1 text for  t = 1\n\nx^energy_t == x^energy_t-1 + frhr eta^in x^in_t - fracfrhreta^out x^out_t forall t geq 2\n\nArguments\n\ncanonical_model::CanonicalModel : the canonical model built in PowerSimulations\ninitial_conditions::Vector{InitialCondition} : for time zero 'varenergy'\nefficiency_data::Tuple{Vector{String}, Vector{InOut}} :: charging/discharging efficiencies\ncons_name::Symbol : name of the constraint\nvar_names::Tuple{Symbol, Symbol, Symbol} : the names of the variables\n: var_names[1] : varin\n: var_names[2] : varout\n: var_names[3] : varenergy\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.parameter_update!-Tuple{PowerSimulations.UpdateRef{JuMP.VariableRef},JuMP.Containers.DenseAxisArray{ParameterJuMP.ParameterRef,N,Ax,L} where L<:Tuple{Vararg{Dict,N}} where Ax where N,Int64,Simulation}","page":"PowerSimulations","title":"PowerSimulations.parameter_update!","text":"Updates the forecast parameter value\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.post_nip-Tuple{PowerModels.GenericPowerModel}","page":"PowerSimulations","title":"PowerSimulations.post_nip","text":"\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.post_nip_expr-Tuple{PowerModels.GenericPowerModel}","page":"PowerSimulations","title":"PowerSimulations.post_nip_expr","text":"\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.powermodels_network!-Union{Tuple{S}, Tuple{PowerSimulations.CanonicalModel,Type{S},PowerSystems.System}} where S<:PowerModels.AbstractActivePowerFormulation","page":"PowerSimulations","title":"PowerSimulations.powermodels_network!","text":"\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.powermodels_network!-Union{Tuple{S}, Tuple{PowerSimulations.CanonicalModel,Type{S},PowerSystems.System}} where S<:PowerModels.AbstractPowerFormulation","page":"PowerSimulations","title":"PowerSimulations.powermodels_network!","text":"\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.ps_cost-Union{Tuple{JV}, Tuple{PowerSimulations.CanonicalModel,JuMP.Containers.DenseAxisArray{JV,N,Ax,L} where L<:Tuple{Vararg{Dict,N}} where Ax where N,Float64,Float64,Float64}} where JV<:JuMP.AbstractVariableRef","page":"PowerSimulations","title":"PowerSimulations.ps_cost","text":"ps_cost(canonical_model::CanonicalModel,\n            variable::JuMP.Containers.DenseAxisArray{JV},\n            cost_component::Float64,\n            dt::Float64,\n            sign::Float64) where {JV <: JuMP.AbstractVariableRef}\n\nReturns linear cost terms for sum of variables with common factor to be used for cost expression for canonical model.\n\nEquation\n\ngen_cost = sum(variable)*cost_component\n\nLaTeX\n\ncost = dttimes signsum_iin I c x_i\n\nReturns:\n\nsign*gen_cost*dt\n\nArguments\n\ncanonical_model::CanonicalModel : the canonical model built in PowerSimulations\nvariable::JuMP.Containers.DenseAxisArray{JV} : variable array\ncost_component::Float64 : cost to be associated with variable\ndt::Float64 : fraction of hour\nsign::Float64 : positive or negative sign to be associated cost term\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.ps_cost-Union{Tuple{JV}, Tuple{PowerSimulations.CanonicalModel,JuMP.Containers.DenseAxisArray{JV,N,Ax,L} where L<:Tuple{Vararg{Dict,N}} where Ax where N,PowerSystems.VariableCost{Array{Tuple{Float64,Float64},1}},Float64,Float64}} where JV<:JuMP.AbstractVariableRef","page":"PowerSimulations","title":"PowerSimulations.ps_cost","text":"ps_cost(canonical_model::CanonicalModel,\n             variable::JuMP.Containers.DenseAxisArray{JV},\n             cost_component::PSY.VariableCost{Vector{NTuple{2, Float64}}},\n             dt::Float64,\n             sign::Float64) where {JV<:JuMP.AbstractVariableRef}\n\nCreates piecewise linear cost function using a sum of variables and expression with sign and time step included.\n\nExpression\n\nJuMP.add_to_expression!(gen_cost, c)\n\nReturns signgen_costdt\n\nLaTeX\n\ncost = signtimes dt sum_vin V c_v\n\nwhere c_v is given by\n\nc_v = sum_iin Ix fracy_i - y_i-1x_i - x_i-1 v^pw_i\n\nArguments\n\ncanonical_model::CanonicalModel : the canonical model built in PowerSimulations\nvariable::JuMP.Containers.DenseAxisArray{JV} : variable array\ncost_component::PSY.VariableCost{Vector{NTuple{2, Float64}}}\ndt::Float64 : fraction of hour\nsign::Float64 : positive or negative sign to be associated cost term\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.ps_cost-Union{Tuple{JV}, Tuple{PowerSimulations.CanonicalModel,JuMP.Containers.DenseAxisArray{JV,N,Ax,L} where L<:Tuple{Vararg{Dict,N}} where Ax where N,PowerSystems.VariableCost{Float64},Float64,Float64}} where JV<:JuMP.AbstractVariableRef","page":"PowerSimulations","title":"PowerSimulations.ps_cost","text":"ps_cost(canonical_model::CanonicalModel,\n            variable::JuMP.Containers.DenseAxisArray{JV},\n            cost_component::PSY.VariableCost{Float64},\n            dt::Float64,\n            sign::Float64) where {JV <: JuMP.AbstractVariableRef}\n\nReturns linear cost terms for sum of variables with common factor to be used for cost expression for canonical model. Does this by calling ps_cost that has Float64 cost component input.\n\nReturns:\n\nps_cost(canonical_model, variable, PSY.get_cost(cost_component), dt, sign)\n\nArguments\n\ncanonical_model::CanonicalModel : the canonical model built in PowerSimulations\nvariable::JuMP.Containers.DenseAxisArray{JV} : variable array\ncost_component::PSY.VariableCost{Float64} : container for cost to be associated with variable\ndt::Float64 : fraction of hour\nsign::Float64 : positive or negative sign to be associated cost term\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.ps_cost-Union{Tuple{JV}, Tuple{PowerSimulations.CanonicalModel,JuMP.Containers.DenseAxisArray{JV,N,Ax,L} where L<:Tuple{Vararg{Dict,N}} where Ax where N,PowerSystems.VariableCost{Tuple{Float64,Float64}},Float64,Float64}} where JV<:JuMP.AbstractVariableRef","page":"PowerSimulations","title":"PowerSimulations.ps_cost","text":"ps_cost(canonical_model::CanonicalModel,\n            variable::JuMP.Containers.DenseAxisArray{JV},\n            cost_component::PSY.VariableCost{NTuple{2, Float64}}\n            dt::Float64,\n            sign::Float64) where {JV <: JuMP.AbstractVariableRef}\n\nReturns quadratic cost terms for sum of variables with common factor to be used for cost expression for canonical model.\n\nEquation\n\ngen_cost = dt*sign*(sum(variable.^2)*cost_component[1] + sum(variable)*cost_component[2])\n\nLaTeX\n\ncost = dttimes sign (sum_iin I c_1 v_i^2 + sum_iin I c_2 v_i )\n\nfor quadratic factor large enough. Otherwise\n\nreturn ps_cost(canonical_model, variable, cost_component[2], dt, 1.0)\n\nReturns gen_cost\n\nArguments\n\ncanonical_model::CanonicalModel : the canonical model built in PowerSimulations\nvariable::JuMP.Containers.DenseAxisArray{JV} : variable array\ncost_component::PSY.VariableCost{NTuple{2, Float64}} : container for quadratic and linear factors\nsign::Float64 : positive or negative sign to be associated cost term\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.ramp_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.CanonicalModel,InfrastructureSystems.FlattenIteratorWrapper{T},Type{D},Type{S}}} where S<:PowerModels.AbstractPowerFormulation where D<:PowerSimulations.AbstractThermalFormulation where T<:PowerSystems.ThermalGen","page":"PowerSimulations","title":"PowerSimulations.ramp_constraints!","text":"This function adds the ramping limits of generators when there are CommitmentVariables\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.range_ff-Tuple{PowerSimulations.CanonicalModel,Symbol,Tuple{PowerSimulations.UpdateRef,PowerSimulations.UpdateRef},Symbol}","page":"PowerSimulations","title":"PowerSimulations.range_ff","text":"    range_ff(canonical_model::CanonicalModel,\n                    cons_name::Symbol,\n                    param_reference::NTuple{2, UpdateRef},\n                    var_name::Symbol)\n\nConstructs min/max range parametrized constraint from device variable to include feedforward.\n\nConstraints\n\nparam_reference[1][var_name] <= variable[var_name, t] variable[var_name, t] <= param_reference[2][var_name]\n\nwhere r in range_data.\n\nLaTeX\n\nparam^min leq x x leq param^max\n\nArguments\n\ncanonical_model::CanonicalModel : the canonical model built in PowerSimulations\nparam_reference::NTuple{2, UpdateRef} : Tuple with the lower bound and upper bound parameter reference\ncons_name::Symbol : name of the constraint\nvar_name::Symbol : the name of the continuous variable\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.rating_constraint-Tuple{PowerSimulations.CanonicalModel,Array{Tuple{String,Float64},1},Symbol,Tuple{Symbol,Symbol}}","page":"PowerSimulations","title":"PowerSimulations.rating_constraint","text":"rating_constraint(canonical_model::CanonicalModel,\n                        rating_data::Vector{Tuple{String, Float64}},\n                        cons_name::Symbol,\n                        var_names::Tuple{Symbol, Symbol})\n\nConstructs constraint from rating data and related variable tuple.\n\nConstraint\n\nvar1[r[1], t]^2 + var2[r[1], t]^2 <= r[2]^2\n\nwhere r in rating data and t in time steps.\n\nLaTeX\n\nx_1^2 + x_2^2 leq r^2\n\nArguments\n\ncanonical_model::CanonicalModel : the canonical model built in PowerSimulations\nrating_data::Vector{Tuple{String, Float64}} : rating data name (1) and value (2)\ncons_name::Symbol : name of the constraint\nvar_names::Tuple{Symbol, Symbol} : the names of the variables\n: var_names[1] : var1\n: var_names[2] : var2\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.reactive_power_constraints-Union{Tuple{S}, Tuple{D}, Tuple{St}, Tuple{PowerSimulations.CanonicalModel,InfrastructureSystems.FlattenIteratorWrapper{St},Type{D},Type{S}}} where S<:PowerModels.AbstractPowerFormulation where D<:PowerSimulations.AbstractStorageForm where St<:PowerSystems.Storage","page":"PowerSimulations","title":"PowerSimulations.reactive_power_constraints","text":"This function adds the reactive  power limits of generators when there are CommitmentVariables\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.reactivepower_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.CanonicalModel,InfrastructureSystems.FlattenIteratorWrapper{T},Type{D},Type{S}}} where S<:PowerModels.AbstractPowerFormulation where D<:PowerSimulations.AbstractThermalDispatchForm where T<:PowerSystems.ThermalGen","page":"PowerSimulations","title":"PowerSimulations.reactivepower_constraints!","text":"This function adds the reactive  power limits of generators when there are CommitmentVariables\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.reactivepower_constraints!-Union{Tuple{S}, Tuple{D}, Tuple{T}, Tuple{PowerSimulations.CanonicalModel,InfrastructureSystems.FlattenIteratorWrapper{T},Type{D},Type{S}}} where S<:PowerModels.AbstractPowerFormulation where D<:PowerSimulations.AbstractThermalFormulation where T<:PowerSystems.ThermalGen","page":"PowerSimulations","title":"PowerSimulations.reactivepower_constraints!","text":"This function adds the reactive power limits of generators when there CommitmentVariables\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.reactivepower_constraints-Union{Tuple{S}, Tuple{D}, Tuple{L}, Tuple{PowerSimulations.CanonicalModel,InfrastructureSystems.FlattenIteratorWrapper{L},Type{D},Type{S}}} where S<:PowerModels.AbstractPowerFormulation where D<:PowerSimulations.AbstractControllablePowerLoadForm where L<:PowerSystems.ElectricLoad","page":"PowerSimulations","title":"PowerSimulations.reactivepower_constraints","text":"Reactive Power Constraints on Loads Assume Constant PowerFactor\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.reactivepower_variables!-Union{Tuple{T}, Tuple{PowerSimulations.CanonicalModel,InfrastructureSystems.FlattenIteratorWrapper{T}}} where T<:PowerSystems.ThermalGen","page":"PowerSimulations","title":"PowerSimulations.reactivepower_variables!","text":"This function add the variables for power generation output to the model\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.remove_chars-Tuple{String,String}","page":"PowerSimulations","title":"PowerSimulations.remove_chars","text":"Removes the string char from the original string\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.replace_chars-Tuple{String,String,String}","page":"PowerSimulations","title":"PowerSimulations.replace_chars","text":"Replaces the string in char with the stringreplacement\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.reserve_device_semicontinuousrange-Tuple{PowerSimulations.CanonicalModel,Array{Tuple{String,NamedTuple{(:min, :max),Tuple{Float64,Float64}}},1},Symbol,Symbol,Symbol}","page":"PowerSimulations","title":"PowerSimulations.reserve_device_semicontinuousrange","text":"reserve_device_semicontinuousrange(canonical_model::CanonicalModel,\n                                scrange_data::Vector{NamedMinMax},\n                                cons_name::Symbol,\n                                var_name::Symbol,\n                                binvar_name::Symbol)\n\nConstructs min/max range constraint from device variable and on/off decision variable.\n\nConstraints\n\nIf device min = 0:\n\nvarcts[r[1], t] <= r[2].max*(1-varbin[r[1], t])\n\nvarcts[r[1], t] >= 0.0\n\nOtherwise:\n\nvarcts[r[1], t] <= r[2].max*(1-varbin[r[1], t])\n\nvarcts[r[1], t] >= r[2].min*(1-varbin[r[1], t])\n\nwhere r in range_data.\n\nLaTeX\n\n0 leq x^cts leq r^max (1 - x^bin ) text for  r^min = 0\n\nr^min (1 - x^bin ) leq x^cts leq r^max (1 - x^bin ) text otherwise \n\nArguments\n\ncanonical_model::CanonicalModel : the canonical model built in PowerSimulations\nscrange_data::Vector{NamedMinMax} : contains name of device (1) and its min/max (2)\ncons_name::Symbol : name of the constraint\nvar_name::Symbol : the name of the continuous variable\nbinvar_name::Symbol : the name of the binary variable\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.semicontinuousrange_ff-Tuple{PowerSimulations.CanonicalModel,Symbol,PowerSimulations.UpdateRef,Symbol}","page":"PowerSimulations","title":"PowerSimulations.semicontinuousrange_ff","text":"        semicontinuousrange_ff(canonical_model::CanonicalModel,\n                                cons_name::Symbol,\n                                var_name::Symbol,\n                                param_reference::UpdateRef)\n\nConstructs min/max range constraint from device variable with parameter setting.\n\nConstraints\n\nIf device min = 0:\n\nvariable[var_name, t] <= r[2].max*param_reference[var_name]\n\nOtherwise:\n\nvariable[var_name, t] <= r[2].max*param_reference[var_name]\n\nvariable[var_name, t] >= r[2].min*param_reference[var_name]\n\nwhere r in range_data.\n\nLaTeX\n\n00 leq x^var leq r^max x^param text for  r^min = 0\n\nr^min x^param leq x^var leq r^min x^param text otherwise \n\nArguments\n\ncanonical_model::CanonicalModel : the canonical model built in PowerSimulations\ncons_name::Symbol : name of the constraint\nvar_name::Symbol : the name of the continuous variable\nparam_reference::UpdateRef : UpdateRef of the parameter\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.set_variable_bounds-Tuple{PowerSimulations.CanonicalModel,Array{Tuple{String,NamedTuple{(:min, :max),Tuple{Float64,Float64}}},1},Symbol}","page":"PowerSimulations","title":"PowerSimulations.set_variable_bounds","text":"set_variable_bounds(canonical_model::CanonicalModel,\n                        bounds::Vector{NamedMinMax},\n                        var_name::Symbol)\n\nAdds a bounds to a variable in the optimization model.\n\nBounds\n\nbounds.min <= varstart[name, t] <= bounds.max\n\nLaTeX\n\nx^device_t = bound^min forall t\n\nx^device_t = bound^max forall t\n\nArguments\n\ncanonical_model::CanonicalModel : the canonical model built in PowerSimulations\nbounds::Vector{NamedMinMax} : contains name of device (1) and its min/max (2)\nvar_name::Symbol : Base Name for the variable\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.status_init-Union{Tuple{PSD}, Tuple{PowerSimulations.CanonicalModel,InfrastructureSystems.FlattenIteratorWrapper{PSD}}} where PSD<:PowerSystems.ThermalGen","page":"PowerSimulations","title":"PowerSimulations.status_init","text":"Status Initis is always calculated based on the Power Output of the device This is to make it easier to calculate when the previous model doesn't contain binaries. For instance, looking back on an ED model to find the IC of the UC model\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.ub_ff-Tuple{PowerSimulations.CanonicalModel,Symbol,PowerSimulations.UpdateRef,Symbol}","page":"PowerSimulations","title":"PowerSimulations.ub_ff","text":"    ub_ff(canonical_model::CanonicalModel,\n          cons_name::Symbol,\n          param_reference::UpdateRef,\n          var_name::Symbol)\n\nConstructs a parametrized upper bound constraint to implement feedforward from other models. The Parameters are initialized using the uppper boundary values of the provided variables.\n\nConstraints\n\nvariable[var_name, t] <= param_reference[var_name]\n\nLaTeX\n\nx leq param^max\n\nArguments\n\ncanonical_model::CanonicalModel : the canonical model built in PowerSimulations\ncons_name::Symbol : name of the constraint\nparam_reference : Reference to the Parameter used to determine the upperbound\nvar_name::Symbol : the name of the continuous variable\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.variable_active_net_injection-Tuple{PowerModels.GenericPowerModel}","page":"PowerSimulations","title":"PowerSimulations.variable_active_net_injection","text":"\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.variable_net_injection-Tuple{PowerModels.GenericPowerModel}","page":"PowerSimulations","title":"PowerSimulations.variable_net_injection","text":"generates variables for both active and reactive net injection\n\n\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.variable_reactive_net_injection-Tuple{PowerModels.GenericPowerModel}","page":"PowerSimulations","title":"PowerSimulations.variable_reactive_net_injection","text":"\n\n\n\n","category":"method"},{"location":"api/PowerSimulations/#PowerSimulations.variable_reactive_net_injection-Union{Tuple{PowerModels.GenericPowerModel{T}}, Tuple{T}} where T<:PowerModels.AbstractDCPForm","page":"PowerSimulations","title":"PowerSimulations.variable_reactive_net_injection","text":"active power only models ignore reactive power variables\n\n\n\n\n\n","category":"method"},{"location":"#PowerSimulations.jl-Documentation-1","page":"Home","title":"PowerSimulations.jl Documentation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"CurrentModule = PowerSimulations","category":"page"}]
}
